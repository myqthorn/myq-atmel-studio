
SeniorProjectPulseOx.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000027a  00800100  00000bdc  00000c70  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000bdc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000076  0080037a  0080037a  00000eea  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000eea  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000318  00000000  00000000  00000f1a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00004054  00000000  00000000  00001232  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000afd  00000000  00000000  00005286  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000ccf  00000000  00000000  00005d83  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000007b8  00000000  00000000  00006a54  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001359  00000000  00000000  0000720c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002432  00000000  00000000  00008565  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000002e0  00000000  00000000  0000a997  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 6a 00 	jmp	0xd4	; 0xd4 <__ctors_end>
   4:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
   8:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
   c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  10:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  14:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  18:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  1c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  20:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  24:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  28:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  2c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  30:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  34:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  38:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  3c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  40:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  44:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  48:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  4c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  50:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  54:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  58:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  5c:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  60:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  64:	0c 94 92 00 	jmp	0x124	; 0x124 <__bad_interrupt>
  68:	14 03       	mulsu	r17, r20
  6a:	18 03       	fmul	r17, r16
  6c:	1c 03       	fmul	r17, r20
  6e:	20 03       	mulsu	r18, r16
  70:	24 03       	mulsu	r18, r20
  72:	28 03       	fmul	r18, r16
  74:	32 03       	mulsu	r19, r18
  76:	36 03       	mulsu	r19, r22
  78:	3a 03       	fmul	r19, r18
  7a:	42 03       	mulsu	r20, r18
  7c:	46 03       	mulsu	r20, r22
  7e:	4a 03       	fmul	r20, r18
  80:	7c 03       	fmul	r23, r20
  82:	5d 03       	fmul	r21, r21
  84:	7c 03       	fmul	r23, r20
  86:	7c 03       	fmul	r23, r20
  88:	7c 03       	fmul	r23, r20
  8a:	61 03       	mulsu	r22, r17
  8c:	7c 03       	fmul	r23, r20
  8e:	7c 03       	fmul	r23, r20
  90:	7c 03       	fmul	r23, r20
  92:	7c 03       	fmul	r23, r20
  94:	7c 03       	fmul	r23, r20
  96:	7c 03       	fmul	r23, r20
  98:	65 03       	mulsu	r22, r21
  9a:	69 03       	fmul	r22, r17
  9c:	6d 03       	fmul	r22, r21
  9e:	71 03       	mulsu	r23, r17
  a0:	75 03       	mulsu	r23, r21
  a2:	79 03       	fmul	r23, r17
  a4:	d4 03       	fmuls	r21, r20
  a6:	f2 03       	fmuls	r23, r18
  a8:	fd 03       	fmulsu	r23, r21
  aa:	00 04       	cpc	r0, r0
  ac:	04 04       	cpc	r0, r4
  ae:	09 04       	cpc	r0, r9
  b0:	0c 04       	cpc	r0, r12
  b2:	15 04       	cpc	r1, r5
  b4:	28 04       	cpc	r2, r8
  b6:	31 04       	cpc	r3, r1
  b8:	50 04       	cpc	r5, r0
  ba:	ca 03       	fmulsu	r20, r18
  bc:	4c 04       	cpc	r4, r12
  be:	2b 04       	cpc	r2, r11
  c0:	2e 04       	cpc	r2, r14
  c2:	40 05       	cpc	r20, r0
  c4:	4c 05       	cpc	r20, r12
  c6:	51 05       	cpc	r21, r1
  c8:	5d 05       	cpc	r21, r13
  ca:	64 05       	cpc	r22, r4
  cc:	74 05       	cpc	r23, r4
  ce:	7b 05       	cpc	r23, r11

000000d0 <__ctors_start>:
  d0:	78 04       	cpc	r7, r8
  d2:	e1 05       	cpc	r30, r1

000000d4 <__ctors_end>:
  d4:	11 24       	eor	r1, r1
  d6:	1f be       	out	0x3f, r1	; 63
  d8:	cf ef       	ldi	r28, 0xFF	; 255
  da:	d4 e0       	ldi	r29, 0x04	; 4
  dc:	de bf       	out	0x3e, r29	; 62
  de:	cd bf       	out	0x3d, r28	; 61

000000e0 <__do_copy_data>:
  e0:	13 e0       	ldi	r17, 0x03	; 3
  e2:	a0 e0       	ldi	r26, 0x00	; 0
  e4:	b1 e0       	ldi	r27, 0x01	; 1
  e6:	ec ed       	ldi	r30, 0xDC	; 220
  e8:	fb e0       	ldi	r31, 0x0B	; 11
  ea:	02 c0       	rjmp	.+4      	; 0xf0 <__do_copy_data+0x10>
  ec:	05 90       	lpm	r0, Z+
  ee:	0d 92       	st	X+, r0
  f0:	aa 37       	cpi	r26, 0x7A	; 122
  f2:	b1 07       	cpc	r27, r17
  f4:	d9 f7       	brne	.-10     	; 0xec <__do_copy_data+0xc>

000000f6 <__do_clear_bss>:
  f6:	23 e0       	ldi	r18, 0x03	; 3
  f8:	aa e7       	ldi	r26, 0x7A	; 122
  fa:	b3 e0       	ldi	r27, 0x03	; 3
  fc:	01 c0       	rjmp	.+2      	; 0x100 <.do_clear_bss_start>

000000fe <.do_clear_bss_loop>:
  fe:	1d 92       	st	X+, r1

00000100 <.do_clear_bss_start>:
 100:	a0 3f       	cpi	r26, 0xF0	; 240
 102:	b2 07       	cpc	r27, r18
 104:	e1 f7       	brne	.-8      	; 0xfe <.do_clear_bss_loop>

00000106 <__do_global_ctors>:
 106:	10 e0       	ldi	r17, 0x00	; 0
 108:	c4 ed       	ldi	r28, 0xD4	; 212
 10a:	d0 e0       	ldi	r29, 0x00	; 0
 10c:	04 c0       	rjmp	.+8      	; 0x116 <__do_global_ctors+0x10>
 10e:	22 97       	sbiw	r28, 0x02	; 2
 110:	fe 01       	movw	r30, r28
 112:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <__tablejump__>
 116:	c0 3d       	cpi	r28, 0xD0	; 208
 118:	d1 07       	cpc	r29, r17
 11a:	c9 f7       	brne	.-14     	; 0x10e <__do_global_ctors+0x8>
 11c:	0e 94 c7 04 	call	0x98e	; 0x98e <main>
 120:	0c 94 ec 05 	jmp	0xbd8	; 0xbd8 <_exit>

00000124 <__bad_interrupt>:
 124:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000128 <_ZN6ANALOG12reinitializeEv>:
	
}

void ANALOG::reinitialize(){
	//Power reduction ADC bit must be zero to enable ADC
	PRR &= ~(1<<PRADC);
 128:	e4 e6       	ldi	r30, 0x64	; 100
 12a:	f0 e0       	ldi	r31, 0x00	; 0
 12c:	20 81       	ld	r18, Z
 12e:	2e 7f       	andi	r18, 0xFE	; 254
 130:	20 83       	st	Z, r18
	
	
	//ADC clock needs to be between 50kHz and 200kHz
	//8MHz/64 = 125kHz
	ADCSRA = (1<<ADEN | prescalar<<ADPS0);
 132:	dc 01       	movw	r26, r24
 134:	11 96       	adiw	r26, 0x01	; 1
 136:	2c 91       	ld	r18, X
 138:	11 97       	sbiw	r26, 0x01	; 1
 13a:	20 68       	ori	r18, 0x80	; 128
 13c:	20 93 7a 00 	sts	0x007A, r18
	
	//Disable the digital input for the ADC channel we will be using
	DIDR0 |= (1<<channel);
 140:	ee e7       	ldi	r30, 0x7E	; 126
 142:	f0 e0       	ldi	r31, 0x00	; 0
 144:	40 81       	ld	r20, Z
 146:	21 e0       	ldi	r18, 0x01	; 1
 148:	30 e0       	ldi	r19, 0x00	; 0
 14a:	b9 01       	movw	r22, r18
 14c:	0c 90       	ld	r0, X
 14e:	02 c0       	rjmp	.+4      	; 0x154 <_ZN6ANALOG12reinitializeEv+0x2c>
 150:	66 0f       	add	r22, r22
 152:	77 1f       	adc	r23, r23
 154:	0a 94       	dec	r0
 156:	e2 f7       	brpl	.-8      	; 0x150 <_ZN6ANALOG12reinitializeEv+0x28>
 158:	cb 01       	movw	r24, r22
 15a:	84 2b       	or	r24, r20
 15c:	80 83       	st	Z, r24
 15e:	08 95       	ret

00000160 <_ZN6ANALOGC1Ehh>:
	reinitialize();
}

//@brief initialize AD converter on Atmega168 for
ANALOG::ANALOG(uint8_t ch, uint8_t pscalar){
	channel = ch;
 160:	fc 01       	movw	r30, r24
 162:	60 83       	st	Z, r22
	prescalar = pscalar;
 164:	41 83       	std	Z+1, r20	; 0x01
	reinitialize();
 166:	0e 94 94 00 	call	0x128	; 0x128 <_ZN6ANALOG12reinitializeEv>
 16a:	08 95       	ret

0000016c <_ZN6ANALOG5startEv>:
	return (ADC);
}

void ANALOG::start(){
	//set ADC channel
	ADMUX = (1<<REFS0) | channel;
 16c:	fc 01       	movw	r30, r24
 16e:	80 81       	ld	r24, Z
 170:	80 64       	ori	r24, 0x40	; 64
 172:	80 93 7c 00 	sts	0x007C, r24
	
	//start conversion
	ADCSRA |= (1<<ADSC);
 176:	ea e7       	ldi	r30, 0x7A	; 122
 178:	f0 e0       	ldi	r31, 0x00	; 0
 17a:	80 81       	ld	r24, Z
 17c:	80 64       	ori	r24, 0x40	; 64
 17e:	80 83       	st	Z, r24
 180:	08 95       	ret

00000182 <_ZN6ANALOG18isInterruptFlagSetEv>:
uint8_t ANALOG::isReading(){
	return (ADCSRA & (1<<ADSC));	
}

uint8_t	ANALOG::isInterruptFlagSet(){
	return(ADCSRA & (1<<ADIF));
 182:	80 91 7a 00 	lds	r24, 0x007A
}
 186:	80 71       	andi	r24, 0x10	; 16
 188:	08 95       	ret

0000018a <_ZN6ANALOG9clearFlagEv>:

void ANALOG::clearFlag(){
	//clear interrupt by setting ADIF to 1
	ADCSRA |= (1<<ADIF);
 18a:	ea e7       	ldi	r30, 0x7A	; 122
 18c:	f0 e0       	ldi	r31, 0x00	; 0
 18e:	80 81       	ld	r24, Z
 190:	80 61       	ori	r24, 0x10	; 16
 192:	80 83       	st	Z, r24
 194:	08 95       	ret

00000196 <_ZN3SPI4initEh>:
		init(SPCRvalue);
	}
	void SPI::init(uint8_t SPCRvalue)
	// Initialize pins for spi communication
	{
		DDR_SPI &= ~((1<<DD_MOSI)|(1<<DD_MISO)|(1<<DD_SS)|(1<<DD_SCK));
 196:	84 b1       	in	r24, 0x04	; 4
 198:	83 7c       	andi	r24, 0xC3	; 195
 19a:	84 b9       	out	0x04, r24	; 4
		// Define the following pins as output
		DDR_SPI |= ((1<<DD_MOSI)|(1<<DD_SS)|(1<<DD_SCK));
 19c:	84 b1       	in	r24, 0x04	; 4
 19e:	8c 62       	ori	r24, 0x2C	; 44
 1a0:	84 b9       	out	0x04, r24	; 4

		if (SPCRvalue == 0x00){
 1a2:	61 11       	cpse	r22, r1
 1a4:	03 c0       	rjmp	.+6      	; 0x1ac <_ZN3SPI4initEh+0x16>
			(0<<SPIE)|              // SPI Interrupt Enable
			(0<<DORD)|              // Data Order (0:MSB first / 1:LSB first)
			(1<<MSTR)|              // Master/Slave select
			(0<<SPR1)|(1<<SPR0)|    // SPI Clock Rate
			(0<<CPOL)|              // Clock Polarity (0:SCK low / 1:SCK hi when idle)
			(0<<CPHA));             // Clock Phase (0:leading / 1:trailing edge sampling)
 1a6:	81 e5       	ldi	r24, 0x51	; 81
 1a8:	8c bd       	out	0x2c, r24	; 44
 1aa:	08 95       	ret
		}
		else SPCR = SPCRvalue;
 1ac:	6c bd       	out	0x2c, r22	; 44
 1ae:	08 95       	ret

000001b0 <_ZN3SPIC1Eh>:
	
	SPI::SPI(){
		init(0x00);
	}
	SPI::SPI(uint8_t SPCRvalue){
		init(SPCRvalue);
 1b0:	0e 94 cb 00 	call	0x196	; 0x196 <_ZN3SPI4initEh>
 1b4:	08 95       	ret

000001b6 <_ZN3SPI8transferEPhS0_h>:
	
	void SPI::transfer (uint8_t * dataout, uint8_t * datain, uint8_t length)
	// Shift full array through target device
	{
		uint8_t i;
		for (i = 0; i < length; i++) {
 1b6:	22 23       	and	r18, r18
 1b8:	81 f0       	breq	.+32     	; 0x1da <_ZN3SPI8transferEPhS0_h+0x24>
 1ba:	96 2f       	mov	r25, r22
 1bc:	a4 2f       	mov	r26, r20
 1be:	b5 2f       	mov	r27, r21
 1c0:	e6 2f       	mov	r30, r22
 1c2:	f7 2f       	mov	r31, r23
			SPDR = dataout[i];
 1c4:	81 91       	ld	r24, Z+
 1c6:	8e bd       	out	0x2e, r24	; 46
			while((SPSR & (1<<SPIF))==0);
 1c8:	0d b4       	in	r0, 0x2d	; 45
 1ca:	07 fe       	sbrs	r0, 7
 1cc:	fd cf       	rjmp	.-6      	; 0x1c8 <_ZN3SPI8transferEPhS0_h+0x12>
			datain[i] = SPDR;
 1ce:	8e b5       	in	r24, 0x2e	; 46
 1d0:	8d 93       	st	X+, r24
 1d2:	8e 2f       	mov	r24, r30
 1d4:	89 1b       	sub	r24, r25
	
	void SPI::transfer (uint8_t * dataout, uint8_t * datain, uint8_t length)
	// Shift full array through target device
	{
		uint8_t i;
		for (i = 0; i < length; i++) {
 1d6:	82 17       	cp	r24, r18
 1d8:	a8 f3       	brcs	.-22     	; 0x1c4 <_ZN3SPI8transferEPhS0_h+0xe>
 1da:	08 95       	ret

000001dc <_ZN3SPI13transfer1byteEh>:
	}
	
	uint8_t SPI::transfer1byte (uint8_t dataout)
	// Clocks only one byte to target device and returns the received one
	{
		SPDR = dataout;
 1dc:	6e bd       	out	0x2e, r22	; 46
		while((SPSR & (1<<SPIF))==0);
 1de:	0d b4       	in	r0, 0x2d	; 45
 1e0:	07 fe       	sbrs	r0, 7
 1e2:	fd cf       	rjmp	.-6      	; 0x1de <_ZN3SPI13transfer1byteEh+0x2>
		return SPDR;
 1e4:	8e b5       	in	r24, 0x2e	; 46
	}
 1e6:	08 95       	ret

000001e8 <_ZN3NRF14isInitializingEv>:
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 1e8:	fc 01       	movw	r30, r24
 1ea:	ef 58       	subi	r30, 0x8F	; 143
 1ec:	ff 4f       	sbci	r31, 0xFF	; 255
 1ee:	81 e0       	ldi	r24, 0x01	; 1
 1f0:	90 81       	ld	r25, Z
 1f2:	92 30       	cpi	r25, 0x02	; 2
 1f4:	09 f0       	breq	.+2      	; 0x1f8 <_ZN3NRF14isInitializingEv+0x10>
 1f6:	80 e0       	ldi	r24, 0x00	; 0
}
 1f8:	08 95       	ret

000001fa <_ZN3NRF13hasDataToSendEv>:
uint8_t NRF::hasDataToSend(void){
	return ((status & (1<<NRF_TX_READY))?TRUE:FALSE);
 1fa:	fc 01       	movw	r30, r24
 1fc:	82 8d       	ldd	r24, Z+26	; 0x1a
}
 1fe:	86 fb       	bst	r24, 6
 200:	88 27       	eor	r24, r24
 202:	80 f9       	bld	r24, 0
 204:	08 95       	ret

00000206 <_ZN3NRF18waitingForResponseEv>:
uint8_t NRF::isReadyToReceiveData(){
	return ((status & (1<<NRF_RX_READY))?TRUE:FALSE);
}
uint8_t NRF::waitingForResponse(void){
	return ((status & (1<<NRF_WAIT_FOR_RESPONSE))?TRUE:FALSE);
 206:	fc 01       	movw	r30, r24
 208:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
 20a:	82 95       	swap	r24
 20c:	81 70       	andi	r24, 0x01	; 1
 20e:	08 95       	ret

00000210 <_ZN3NRF11isConnectedEv>:
uint8_t NRF::isConnected(void){
	return ((status & (1<<NRF_CONNECTED))?TRUE:FALSE);
 210:	fc 01       	movw	r30, r24
 212:	82 8d       	ldd	r24, Z+26	; 0x1a
}	
 214:	83 fb       	bst	r24, 3
 216:	88 27       	eor	r24, r24
 218:	80 f9       	bld	r24, 0
 21a:	08 95       	ret

0000021c <_ZN3NRF16hasDataToProcessEv>:
uint8_t NRF::isBonded(void){
	return ((status & (1<<NRF_BONDED))?TRUE:FALSE);	
}
uint8_t NRF::hasDataToProcess(void){
	return ((status & (1<<NRF_DATA_TO_PROCESS))?TRUE:FALSE);
 21c:	fc 01       	movw	r30, r24
 21e:	82 8d       	ldd	r24, Z+26	; 0x1a
}
 220:	85 fb       	bst	r24, 5
 222:	88 27       	eor	r24, r24
 224:	80 f9       	bld	r24, 0
 226:	08 95       	ret

00000228 <_ZN3NRF20dataHasBeenProcessedEv>:
void	NRF::dataHasBeenProcessed(void){
	status &= ~(1<<NRF_DATA_TO_PROCESS);
 228:	fc 01       	movw	r30, r24
 22a:	22 8d       	ldd	r18, Z+26	; 0x1a
 22c:	2f 7d       	andi	r18, 0xDF	; 223
 22e:	22 8f       	std	Z+26, r18	; 0x1a
 230:	08 95       	ret

00000232 <_ZN3NRF15isSystemCommandEh>:
uint8_t	NRF::isSystemCommand(uint8_t command){
	return ((	command == NRF_CMD_SET_LOCAL_DATA	||
		command == NRF_CMD_SEND_DATA		||
		command == NRF_CMD_SEND_DATA_ACK	||
		command == NRF_CMD_REQUEST_DATA		||
		command == NRF_CMD_SEND_DATA_NACK	 )	? FALSE: TRUE);
 232:	6d 30       	cpi	r22, 0x0D	; 13
 234:	31 f0       	breq	.+12     	; 0x242 <_ZN3NRF15isSystemCommandEh+0x10>
	status &= ~(1<<NRF_DATA_TO_PROCESS);
}
#pragma endregion Status Functions

uint8_t	NRF::isSystemCommand(uint8_t command){
	return ((	command == NRF_CMD_SET_LOCAL_DATA	||
 236:	65 51       	subi	r22, 0x15	; 21
 238:	81 e0       	ldi	r24, 0x01	; 1
 23a:	64 30       	cpi	r22, 0x04	; 4
 23c:	18 f4       	brcc	.+6      	; 0x244 <_ZN3NRF15isSystemCommandEh+0x12>
 23e:	80 e0       	ldi	r24, 0x00	; 0
 240:	08 95       	ret
		command == NRF_CMD_SEND_DATA		||
		command == NRF_CMD_SEND_DATA_ACK	||
		command == NRF_CMD_REQUEST_DATA		||
		command == NRF_CMD_SEND_DATA_NACK	 )	? FALSE: TRUE);
 242:	80 e0       	ldi	r24, 0x00	; 0
}
 244:	08 95       	ret

00000246 <_ZN3NRF4initEv>:
}


void NRF::init(){
	//ACT and RDYN set as inputs	
	ACT_DDR &= ~(1<<ACT_PIN);	
 246:	20 98       	cbi	0x04, 0	; 4
	RDYN_DDR &= ~(1<<RDYN_PIN);
 248:	22 98       	cbi	0x04, 2	; 4
	
	//REQN set as output
	REQN_DDR |= (1<<REQN_PIN);
 24a:	21 9a       	sbi	0x04, 1	; 4
	//////DON'T KNOW WHY THIS IS CAUSING A PROBLEM********************************************************
	//set pullup on RDYN
	//RDYN_PORT |= (1<<RDYN_PIN);
	
	//REQN is active low, so initialize it HIGH
	SetREQN();
 24c:	29 9a       	sbi	0x05, 1	; 5
 24e:	08 95       	ret

00000250 <_ZN3NRFC1Ev>:

//uint8_t initCodes[12][32];
static uint8_t initCount = 0;

//NRF::NRF(hal_aci_data_t *message){
NRF::NRF(){
 250:	cf 93       	push	r28
 252:	df 93       	push	r29
 254:	ec 01       	movw	r28, r24
	//msg = message;
	
	init();
 256:	0e 94 23 01 	call	0x246	; 0x246 <_ZN3NRF4initEv>
	RxCount = 0x00;
 25a:	1d 8a       	std	Y+21, r1	; 0x15
	//mode = 0x00;
	//set to INIT_MODE and RX_READY
	//we are waiting for a NRF_EVT_DEVICE_STARTED in NRF_MODE_SETUP
	//status |= (1<<NRF_RX_READY | 1<<NRF_INIT_MODE | 1<<NRF_WAIT_FOR_RESPONSE);
	status |= (1<<NRF_RX_READY | 1<<NRF_WAIT_FOR_RESPONSE);
 25c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 25e:	80 69       	ori	r24, 0x90	; 144
 260:	8a 8f       	std	Y+26, r24	; 0x1a
}
 262:	df 91       	pop	r29
 264:	cf 91       	pop	r28
 266:	08 95       	ret

00000268 <_ZN3NRF11clearTxDataEv>:
		}
		
	}//else if(RDYN == 0)	
	
}//transferACI()
void NRF::clearTxData(){
 268:	fc 01       	movw	r30, r24
 26a:	fb 96       	adiw	r30, 0x3b	; 59
	for(int i = 0; i<32; i++) 
 26c:	20 e0       	ldi	r18, 0x00	; 0
 26e:	30 e0       	ldi	r19, 0x00	; 0
		TxData[i] = 0x00;		
 270:	11 92       	st	Z+, r1
		
	}//else if(RDYN == 0)	
	
}//transferACI()
void NRF::clearTxData(){
	for(int i = 0; i<32; i++) 
 272:	2f 5f       	subi	r18, 0xFF	; 255
 274:	3f 4f       	sbci	r19, 0xFF	; 255
 276:	20 32       	cpi	r18, 0x20	; 32
 278:	31 05       	cpc	r19, r1
 27a:	d1 f7       	brne	.-12     	; 0x270 <_ZN3NRF11clearTxDataEv+0x8>
		TxData[i] = 0x00;		
}
 27c:	08 95       	ret

0000027e <_ZN3NRF13PrepareTxDataEhPhh>:
///@brief Send data from uC to nRF8001
///@param command
///@param data
///@param length Length of data
///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::PrepareTxData(uint8_t command, uint8_t *data, uint8_t length){
 27e:	ef 92       	push	r14
 280:	ff 92       	push	r15
 282:	0f 93       	push	r16
 284:	1f 93       	push	r17
 286:	cf 93       	push	r28
 288:	df 93       	push	r29
 28a:	ec 01       	movw	r28, r24
 28c:	16 2f       	mov	r17, r22
 28e:	e4 2e       	mov	r14, r20
 290:	f5 2e       	mov	r15, r21
 292:	02 2f       	mov	r16, r18
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 294:	fc 01       	movw	r30, r24
 296:	ef 58       	subi	r30, 0x8F	; 143
 298:	ff 4f       	sbci	r31, 0xFF	; 255
///@param length Length of data
///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::PrepareTxData(uint8_t command, uint8_t *data, uint8_t length){
	//TODO: write this function
	int i;
	if (isInitializing())
 29a:	80 81       	ld	r24, Z
 29c:	82 30       	cpi	r24, 0x02	; 2
 29e:	e1 f0       	breq	.+56     	; 0x2d8 <_ZN3NRF13PrepareTxDataEhPhh+0x5a>
		return 0x01;
	if (hasDataToSend())
 2a0:	ce 01       	movw	r24, r28
 2a2:	0e 94 fd 00 	call	0x1fa	; 0x1fa <_ZN3NRF13hasDataToSendEv>
 2a6:	81 11       	cpse	r24, r1
 2a8:	19 c0       	rjmp	.+50     	; 0x2dc <_ZN3NRF13PrepareTxDataEhPhh+0x5e>
		return 0x02;
	if (waitingForResponse() && isSystemCommand(command))
 2aa:	ce 01       	movw	r24, r28
 2ac:	0e 94 03 01 	call	0x206	; 0x206 <_ZN3NRF18waitingForResponseEv>
 2b0:	88 23       	and	r24, r24
 2b2:	c1 f0       	breq	.+48     	; 0x2e4 <_ZN3NRF13PrepareTxDataEhPhh+0x66>
 2b4:	61 2f       	mov	r22, r17
 2b6:	ce 01       	movw	r24, r28
 2b8:	0e 94 19 01 	call	0x232	; 0x232 <_ZN3NRF15isSystemCommandEh>
 2bc:	81 11       	cpse	r24, r1
 2be:	10 c0       	rjmp	.+32     	; 0x2e0 <_ZN3NRF13PrepareTxDataEhPhh+0x62>
 2c0:	11 c0       	rjmp	.+34     	; 0x2e4 <_ZN3NRF13PrepareTxDataEhPhh+0x66>
	
	//populate TxData with length and data
	TxData[0] = length + 1;
	TxData[1] = command;
	for(i = 0; i < length; i++)
		TxData[i+2] = data[i];	
 2c2:	41 91       	ld	r20, Z+
 2c4:	4d 93       	st	X+, r20
	clearTxData();
	
	//populate TxData with length and data
	TxData[0] = length + 1;
	TxData[1] = command;
	for(i = 0; i < length; i++)
 2c6:	01 96       	adiw	r24, 0x01	; 1
 2c8:	82 17       	cp	r24, r18
 2ca:	93 07       	cpc	r25, r19
 2cc:	d4 f3       	brlt	.-12     	; 0x2c2 <_ZN3NRF13PrepareTxDataEhPhh+0x44>
		TxData[i+2] = data[i];	
		
	//data to send flag
	status |= (1<<NRF_TX_READY);
 2ce:	8a 8d       	ldd	r24, Y+26	; 0x1a
 2d0:	80 64       	ori	r24, 0x40	; 64
 2d2:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;	//success
 2d4:	80 e0       	ldi	r24, 0x00	; 0
 2d6:	1d c0       	rjmp	.+58     	; 0x312 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::PrepareTxData(uint8_t command, uint8_t *data, uint8_t length){
	//TODO: write this function
	int i;
	if (isInitializing())
		return 0x01;
 2d8:	81 e0       	ldi	r24, 0x01	; 1
 2da:	1b c0       	rjmp	.+54     	; 0x312 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
	if (hasDataToSend())
		return 0x02;
 2dc:	82 e0       	ldi	r24, 0x02	; 2
 2de:	19 c0       	rjmp	.+50     	; 0x312 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
	if (waitingForResponse() && isSystemCommand(command))
		return 0x03;
 2e0:	83 e0       	ldi	r24, 0x03	; 3
 2e2:	17 c0       	rjmp	.+46     	; 0x312 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
	
	lastCommand = command;
 2e4:	fe 01       	movw	r30, r28
 2e6:	ed 58       	subi	r30, 0x8D	; 141
 2e8:	ff 4f       	sbci	r31, 0xFF	; 255
 2ea:	10 83       	st	Z, r17
	
	clearTxData();
 2ec:	ce 01       	movw	r24, r28
 2ee:	0e 94 34 01 	call	0x268	; 0x268 <_ZN3NRF11clearTxDataEv>
	
	//populate TxData with length and data
	TxData[0] = length + 1;
 2f2:	81 e0       	ldi	r24, 0x01	; 1
 2f4:	80 0f       	add	r24, r16
 2f6:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = command;
 2f8:	1c af       	std	Y+60, r17	; 0x3c
	for(i = 0; i < length; i++)
 2fa:	20 2f       	mov	r18, r16
 2fc:	30 e0       	ldi	r19, 0x00	; 0
 2fe:	12 16       	cp	r1, r18
 300:	13 06       	cpc	r1, r19
 302:	2c f7       	brge	.-54     	; 0x2ce <_ZN3NRF13PrepareTxDataEhPhh+0x50>
 304:	ee 2d       	mov	r30, r14
 306:	ff 2d       	mov	r31, r15
 308:	de 01       	movw	r26, r28
 30a:	dd 96       	adiw	r26, 0x3d	; 61
 30c:	80 e0       	ldi	r24, 0x00	; 0
 30e:	90 e0       	ldi	r25, 0x00	; 0
 310:	d8 cf       	rjmp	.-80     	; 0x2c2 <_ZN3NRF13PrepareTxDataEhPhh+0x44>
		TxData[i+2] = data[i];	
		
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData
 312:	df 91       	pop	r29
 314:	cf 91       	pop	r28
 316:	1f 91       	pop	r17
 318:	0f 91       	pop	r16
 31a:	ff 90       	pop	r15
 31c:	ef 90       	pop	r14
 31e:	08 95       	ret

00000320 <_ZN3NRF11requestDataEh>:
	if (retVal == 0x00)
		dataCredit-=1;
	return (retVal);
}//

uint8_t NRF::requestData(uint8_t servicePipeNumber){
 320:	0f 93       	push	r16
 322:	1f 93       	push	r17
 324:	cf 93       	push	r28
 326:	df 93       	push	r29
 328:	1f 92       	push	r1
 32a:	cd b7       	in	r28, 0x3d	; 61
 32c:	de b7       	in	r29, 0x3e	; 62
 32e:	8c 01       	movw	r16, r24
 330:	69 83       	std	Y+1, r22	; 0x01
	uint8_t retVal = PrepareTxData(NRF_CMD_REQUEST_DATA, &servicePipeNumber, 1);
 332:	21 e0       	ldi	r18, 0x01	; 1
 334:	ae 01       	movw	r20, r28
 336:	4f 5f       	subi	r20, 0xFF	; 255
 338:	5f 4f       	sbci	r21, 0xFF	; 255
 33a:	67 e1       	ldi	r22, 0x17	; 23
 33c:	0e 94 3f 01 	call	0x27e	; 0x27e <_ZN3NRF13PrepareTxDataEhPhh>
	if (retVal == 0x00)
 340:	81 11       	cpse	r24, r1
 342:	06 c0       	rjmp	.+12     	; 0x350 <_ZN3NRF11requestDataEh+0x30>
		dataCredit-=1;
 344:	f8 01       	movw	r30, r16
 346:	ee 58       	subi	r30, 0x8E	; 142
 348:	ff 4f       	sbci	r31, 0xFF	; 255
 34a:	90 81       	ld	r25, Z
 34c:	91 50       	subi	r25, 0x01	; 1
 34e:	90 83       	st	Z, r25
	return (retVal);
}//
 350:	0f 90       	pop	r0
 352:	df 91       	pop	r29
 354:	cf 91       	pop	r28
 356:	1f 91       	pop	r17
 358:	0f 91       	pop	r16
 35a:	08 95       	ret

0000035c <_ZN3NRF13PrepareTxDataEhhPhh>:
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command, uint8_t content, uint8_t *data, uint8_t length){
 35c:	df 92       	push	r13
 35e:	ef 92       	push	r14
 360:	ff 92       	push	r15
 362:	0f 93       	push	r16
 364:	1f 93       	push	r17
 366:	cf 93       	push	r28
 368:	df 93       	push	r29
 36a:	ec 01       	movw	r28, r24
 36c:	16 2f       	mov	r17, r22
 36e:	f4 2e       	mov	r15, r20
 370:	d2 2e       	mov	r13, r18
 372:	e3 2e       	mov	r14, r19
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 374:	fc 01       	movw	r30, r24
 376:	ef 58       	subi	r30, 0x8F	; 143
 378:	ff 4f       	sbci	r31, 0xFF	; 255
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command, uint8_t content, uint8_t *data, uint8_t length){
	
	int i;
	if (isInitializing())
 37a:	80 81       	ld	r24, Z
 37c:	82 30       	cpi	r24, 0x02	; 2
 37e:	e1 f0       	breq	.+56     	; 0x3b8 <_ZN3NRF13PrepareTxDataEhhPhh+0x5c>
		return 0x01;
	if (hasDataToSend())
 380:	ce 01       	movw	r24, r28
 382:	0e 94 fd 00 	call	0x1fa	; 0x1fa <_ZN3NRF13hasDataToSendEv>
 386:	81 11       	cpse	r24, r1
 388:	19 c0       	rjmp	.+50     	; 0x3bc <_ZN3NRF13PrepareTxDataEhhPhh+0x60>
		return 0x02;
	if (waitingForResponse() && isSystemCommand(command))
 38a:	ce 01       	movw	r24, r28
 38c:	0e 94 03 01 	call	0x206	; 0x206 <_ZN3NRF18waitingForResponseEv>
 390:	88 23       	and	r24, r24
 392:	c1 f0       	breq	.+48     	; 0x3c4 <_ZN3NRF13PrepareTxDataEhhPhh+0x68>
 394:	61 2f       	mov	r22, r17
 396:	ce 01       	movw	r24, r28
 398:	0e 94 19 01 	call	0x232	; 0x232 <_ZN3NRF15isSystemCommandEh>
 39c:	81 11       	cpse	r24, r1
 39e:	10 c0       	rjmp	.+32     	; 0x3c0 <_ZN3NRF13PrepareTxDataEhhPhh+0x64>
 3a0:	11 c0       	rjmp	.+34     	; 0x3c4 <_ZN3NRF13PrepareTxDataEhhPhh+0x68>
	//populate TxData with length and data
	TxData[0] = length + 2;
	TxData[1] = command;
	TxData[2] = content;
	for(i = 0; i < length; i++)
		TxData[i+3] = data[i];
 3a2:	21 91       	ld	r18, Z+
 3a4:	2d 93       	st	X+, r18
	clearTxData();
	//populate TxData with length and data
	TxData[0] = length + 2;
	TxData[1] = command;
	TxData[2] = content;
	for(i = 0; i < length; i++)
 3a6:	01 96       	adiw	r24, 0x01	; 1
 3a8:	80 17       	cp	r24, r16
 3aa:	91 07       	cpc	r25, r17
 3ac:	d4 f3       	brlt	.-12     	; 0x3a2 <_ZN3NRF13PrepareTxDataEhhPhh+0x46>
		TxData[i+3] = data[i];
	
	//data to send flag
	status |= (1<<NRF_TX_READY);
 3ae:	8a 8d       	ldd	r24, Y+26	; 0x1a
 3b0:	80 64       	ori	r24, 0x40	; 64
 3b2:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;	//success
 3b4:	80 e0       	ldi	r24, 0x00	; 0
 3b6:	1d c0       	rjmp	.+58     	; 0x3f2 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>

uint8_t NRF::PrepareTxData(uint8_t command, uint8_t content, uint8_t *data, uint8_t length){
	
	int i;
	if (isInitializing())
		return 0x01;
 3b8:	81 e0       	ldi	r24, 0x01	; 1
 3ba:	1b c0       	rjmp	.+54     	; 0x3f2 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>
	if (hasDataToSend())
		return 0x02;
 3bc:	82 e0       	ldi	r24, 0x02	; 2
 3be:	19 c0       	rjmp	.+50     	; 0x3f2 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>
	if (waitingForResponse() && isSystemCommand(command))
		return 0x03;
 3c0:	83 e0       	ldi	r24, 0x03	; 3
 3c2:	17 c0       	rjmp	.+46     	; 0x3f2 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>
	
	lastCommand = command;
 3c4:	fe 01       	movw	r30, r28
 3c6:	ed 58       	subi	r30, 0x8D	; 141
 3c8:	ff 4f       	sbci	r31, 0xFF	; 255
 3ca:	10 83       	st	Z, r17
	
	clearTxData();
 3cc:	ce 01       	movw	r24, r28
 3ce:	0e 94 34 01 	call	0x268	; 0x268 <_ZN3NRF11clearTxDataEv>
	//populate TxData with length and data
	TxData[0] = length + 2;
 3d2:	82 e0       	ldi	r24, 0x02	; 2
 3d4:	80 0f       	add	r24, r16
 3d6:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = command;
 3d8:	1c af       	std	Y+60, r17	; 0x3c
	TxData[2] = content;
 3da:	fd ae       	std	Y+61, r15	; 0x3d
	for(i = 0; i < length; i++)
 3dc:	10 e0       	ldi	r17, 0x00	; 0
 3de:	10 16       	cp	r1, r16
 3e0:	11 06       	cpc	r1, r17
 3e2:	2c f7       	brge	.-54     	; 0x3ae <_ZN3NRF13PrepareTxDataEhhPhh+0x52>
 3e4:	ed 2d       	mov	r30, r13
 3e6:	fe 2d       	mov	r31, r14
 3e8:	de 01       	movw	r26, r28
 3ea:	de 96       	adiw	r26, 0x3e	; 62
 3ec:	80 e0       	ldi	r24, 0x00	; 0
 3ee:	90 e0       	ldi	r25, 0x00	; 0
 3f0:	d8 cf       	rjmp	.-80     	; 0x3a2 <_ZN3NRF13PrepareTxDataEhhPhh+0x46>
		TxData[i+3] = data[i];
	
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData
 3f2:	df 91       	pop	r29
 3f4:	cf 91       	pop	r28
 3f6:	1f 91       	pop	r17
 3f8:	0f 91       	pop	r16
 3fa:	ff 90       	pop	r15
 3fc:	ef 90       	pop	r14
 3fe:	df 90       	pop	r13
 400:	08 95       	ret

00000402 <_ZN3NRF12setLocalDataEhPhh>:
return (PrepareTxData(NRF_CMD_CLOSE_REMOTE_PIPE, &servicePipeNumber, 1));
}//
#pragma endregion System Command Functions

#pragma region Data Command Functions
uint8_t NRF::setLocalData(uint8_t servicePipeNumber, uint8_t *data, uint8_t length){	
 402:	0f 93       	push	r16
	return (PrepareTxData(NRF_CMD_SET_LOCAL_DATA, servicePipeNumber, data, length));
 404:	02 2f       	mov	r16, r18
 406:	9a 01       	movw	r18, r20
 408:	46 2f       	mov	r20, r22
 40a:	6d e0       	ldi	r22, 0x0D	; 13
 40c:	0e 94 ae 01 	call	0x35c	; 0x35c <_ZN3NRF13PrepareTxDataEhhPhh>
}//
 410:	0f 91       	pop	r16
 412:	08 95       	ret

00000414 <_ZN3NRF13PrepareTxDataEh>:
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command){
 414:	1f 93       	push	r17
 416:	cf 93       	push	r28
 418:	df 93       	push	r29
 41a:	ec 01       	movw	r28, r24
 41c:	16 2f       	mov	r17, r22
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 41e:	fc 01       	movw	r30, r24
 420:	ef 58       	subi	r30, 0x8F	; 143
 422:	ff 4f       	sbci	r31, 0xFF	; 255
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command){
	if (isInitializing())
 424:	80 81       	ld	r24, Z
 426:	82 30       	cpi	r24, 0x02	; 2
 428:	91 f0       	breq	.+36     	; 0x44e <_ZN3NRF13PrepareTxDataEh+0x3a>
		return 0x01;
	if (hasDataToSend())
 42a:	ce 01       	movw	r24, r28
 42c:	0e 94 fd 00 	call	0x1fa	; 0x1fa <_ZN3NRF13hasDataToSendEv>
 430:	81 11       	cpse	r24, r1
 432:	0f c0       	rjmp	.+30     	; 0x452 <_ZN3NRF13PrepareTxDataEh+0x3e>
		return 0x02;
	if (waitingForResponse() && isSystemCommand(command))
 434:	ce 01       	movw	r24, r28
 436:	0e 94 03 01 	call	0x206	; 0x206 <_ZN3NRF18waitingForResponseEv>
 43a:	88 23       	and	r24, r24
 43c:	61 f0       	breq	.+24     	; 0x456 <_ZN3NRF13PrepareTxDataEh+0x42>
 43e:	61 2f       	mov	r22, r17
 440:	ce 01       	movw	r24, r28
 442:	0e 94 19 01 	call	0x232	; 0x232 <_ZN3NRF15isSystemCommandEh>
 446:	88 23       	and	r24, r24
 448:	31 f0       	breq	.+12     	; 0x456 <_ZN3NRF13PrepareTxDataEh+0x42>
		return 0x03;
 44a:	83 e0       	ldi	r24, 0x03	; 3
 44c:	12 c0       	rjmp	.+36     	; 0x472 <_ZN3NRF13PrepareTxDataEh+0x5e>
	return 0x00;	//success
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command){
	if (isInitializing())
		return 0x01;
 44e:	81 e0       	ldi	r24, 0x01	; 1
 450:	10 c0       	rjmp	.+32     	; 0x472 <_ZN3NRF13PrepareTxDataEh+0x5e>
	if (hasDataToSend())
		return 0x02;
 452:	82 e0       	ldi	r24, 0x02	; 2
 454:	0e c0       	rjmp	.+28     	; 0x472 <_ZN3NRF13PrepareTxDataEh+0x5e>
	if (waitingForResponse() && isSystemCommand(command))
		return 0x03;
	
	lastCommand = command;
 456:	fe 01       	movw	r30, r28
 458:	ed 58       	subi	r30, 0x8D	; 141
 45a:	ff 4f       	sbci	r31, 0xFF	; 255
 45c:	10 83       	st	Z, r17
	
	clearTxData();
 45e:	ce 01       	movw	r24, r28
 460:	0e 94 34 01 	call	0x268	; 0x268 <_ZN3NRF11clearTxDataEv>
	TxData[0] = 0x01;
 464:	81 e0       	ldi	r24, 0x01	; 1
 466:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = command;
 468:	1c af       	std	Y+60, r17	; 0x3c
	status |= (1<<NRF_TX_READY);
 46a:	8a 8d       	ldd	r24, Y+26	; 0x1a
 46c:	80 64       	ori	r24, 0x40	; 64
 46e:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;
 470:	80 e0       	ldi	r24, 0x00	; 0
}
 472:	df 91       	pop	r29
 474:	cf 91       	pop	r28
 476:	1f 91       	pop	r17
 478:	08 95       	ret

0000047a <_ZN3NRF10radioResetEv>:
uint8_t NRF::getTemperature(void){	
	return (PrepareTxData(NRF_CMD_GET_TEMPERATURE));
}//getTemperature

uint8_t NRF::radioReset(){
	return (PrepareTxData(NRF_CMD_RADIO_RESET));
 47a:	6e e0       	ldi	r22, 0x0E	; 14
 47c:	0e 94 0a 02 	call	0x414	; 0x414 <_ZN3NRF13PrepareTxDataEh>
}//
 480:	08 95       	ret

00000482 <_ZN3NRF7connectEjj>:

uint8_t NRF::connect(uint16_t timeout, uint16_t advInterval){	
 482:	ef 92       	push	r14
 484:	ff 92       	push	r15
 486:	0f 93       	push	r16
 488:	1f 93       	push	r17
 48a:	cf 93       	push	r28
 48c:	df 93       	push	r29
 48e:	ec 01       	movw	r28, r24
 490:	e6 2e       	mov	r14, r22
 492:	f7 2e       	mov	r15, r23
 494:	04 2f       	mov	r16, r20
 496:	15 2f       	mov	r17, r21
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 498:	fc 01       	movw	r30, r24
 49a:	ef 58       	subi	r30, 0x8F	; 143
 49c:	ff 4f       	sbci	r31, 0xFF	; 255
	//localData[1] = (timeout&0xFF00)>>8; //MSB
	//localData[2] = (advInterval&0x00FF);	//LSB
	//localData[3] = (advInterval&0xFF00)>>8; //MSB
	//return (PrepareTxData(NRF_CMD_CONNECT, localData, 4));
	
	if (isInitializing())
 49e:	80 81       	ld	r24, Z
 4a0:	82 30       	cpi	r24, 0x02	; 2
 4a2:	11 f1       	breq	.+68     	; 0x4e8 <_ZN3NRF7connectEjj+0x66>
	return 0x01;
	if (hasDataToSend())
 4a4:	ce 01       	movw	r24, r28
 4a6:	0e 94 fd 00 	call	0x1fa	; 0x1fa <_ZN3NRF13hasDataToSendEv>
 4aa:	81 11       	cpse	r24, r1
 4ac:	1f c0       	rjmp	.+62     	; 0x4ec <_ZN3NRF7connectEjj+0x6a>
	return 0x02;
	if (waitingForResponse())
 4ae:	ce 01       	movw	r24, r28
 4b0:	0e 94 03 01 	call	0x206	; 0x206 <_ZN3NRF18waitingForResponseEv>
 4b4:	81 11       	cpse	r24, r1
 4b6:	1c c0       	rjmp	.+56     	; 0x4f0 <_ZN3NRF7connectEjj+0x6e>
	return 0x03;
	
	lastCommand = TxData[1];
 4b8:	fe 01       	movw	r30, r28
 4ba:	ed 58       	subi	r30, 0x8D	; 141
 4bc:	ff 4f       	sbci	r31, 0xFF	; 255
 4be:	8c ad       	ldd	r24, Y+60	; 0x3c
 4c0:	80 83       	st	Z, r24
	
	clearTxData();
 4c2:	ce 01       	movw	r24, r28
 4c4:	0e 94 34 01 	call	0x268	; 0x268 <_ZN3NRF11clearTxDataEv>
	TxData[0] = 0x05;	//length
 4c8:	85 e0       	ldi	r24, 0x05	; 5
 4ca:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = NRF_CMD_CONNECT;
 4cc:	8f e0       	ldi	r24, 0x0F	; 15
 4ce:	8c af       	std	Y+60, r24	; 0x3c
	TxData[2] = (timeout&0x00FF);	//LSB
 4d0:	ed ae       	std	Y+61, r14	; 0x3d
	TxData[3] = (timeout&0xFF00)>>8; //MSB
 4d2:	fe ae       	std	Y+62, r15	; 0x3e
	TxData[4] = (advInterval&0x00FF);	//LSB
 4d4:	0f af       	std	Y+63, r16	; 0x3f
	TxData[5] = (advInterval&0xFF00)>>8; //MSB
 4d6:	fe 01       	movw	r30, r28
 4d8:	e0 5c       	subi	r30, 0xC0	; 192
 4da:	ff 4f       	sbci	r31, 0xFF	; 255
 4dc:	10 83       	st	Z, r17
	status |= (1<<NRF_TX_READY);
 4de:	8a 8d       	ldd	r24, Y+26	; 0x1a
 4e0:	80 64       	ori	r24, 0x40	; 64
 4e2:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;
 4e4:	80 e0       	ldi	r24, 0x00	; 0
 4e6:	05 c0       	rjmp	.+10     	; 0x4f2 <_ZN3NRF7connectEjj+0x70>
	//localData[2] = (advInterval&0x00FF);	//LSB
	//localData[3] = (advInterval&0xFF00)>>8; //MSB
	//return (PrepareTxData(NRF_CMD_CONNECT, localData, 4));
	
	if (isInitializing())
	return 0x01;
 4e8:	81 e0       	ldi	r24, 0x01	; 1
 4ea:	03 c0       	rjmp	.+6      	; 0x4f2 <_ZN3NRF7connectEjj+0x70>
	if (hasDataToSend())
	return 0x02;
 4ec:	82 e0       	ldi	r24, 0x02	; 2
 4ee:	01 c0       	rjmp	.+2      	; 0x4f2 <_ZN3NRF7connectEjj+0x70>
	if (waitingForResponse())
	return 0x03;
 4f0:	83 e0       	ldi	r24, 0x03	; 3
	TxData[3] = (timeout&0xFF00)>>8; //MSB
	TxData[4] = (advInterval&0x00FF);	//LSB
	TxData[5] = (advInterval&0xFF00)>>8; //MSB
	status |= (1<<NRF_TX_READY);
	return 0x00;
}//
 4f2:	df 91       	pop	r29
 4f4:	cf 91       	pop	r28
 4f6:	1f 91       	pop	r17
 4f8:	0f 91       	pop	r16
 4fa:	ff 90       	pop	r15
 4fc:	ef 90       	pop	r14
 4fe:	08 95       	ret

00000500 <_ZN3NRF11transferACIEv>:
nRF8001 is capable of receiving an ACI command simultaneously as it sends an ACI event to the
application controller.
The application controller shall always read the length byte from nRF8001 and check if the length is
greater than 0. If the length is greater than 0 the data on the MISO line shall be read
*/
void NRF::transferACI(void){
 500:	1f 93       	push	r17
 502:	cf 93       	push	r28
 504:	df 93       	push	r29
 506:	ec 01       	movw	r28, r24
	uint8_t length; 
	
	//transmit and receive
	if (hasDataToSend() && (TxData[0] > 0)){			
 508:	0e 94 fd 00 	call	0x1fa	; 0x1fa <_ZN3NRF13hasDataToSendEv>
 50c:	88 23       	and	r24, r24
 50e:	09 f4       	brne	.+2      	; 0x512 <_ZN3NRF11transferACIEv+0x12>
 510:	40 c0       	rjmp	.+128    	; 0x592 <_ZN3NRF11transferACIEv+0x92>
 512:	8b ad       	ldd	r24, Y+59	; 0x3b
 514:	81 11       	cpse	r24, r1
 516:	40 c0       	rjmp	.+128    	; 0x598 <_ZN3NRF11transferACIEv+0x98>
 518:	3c c0       	rjmp	.+120    	; 0x592 <_ZN3NRF11transferACIEv+0x92>
		SetREQN();
		
		//when data is received, clear the ready to receive flag until
		//the received data is handled by the process function
		if (RxData[0] != 0x00){
			status &= ~(1<<NRF_RX_READY);
 51a:	8a 8d       	ldd	r24, Y+26	; 0x1a
 51c:	8f 77       	andi	r24, 0x7F	; 127
 51e:	8a 8f       	std	Y+26, r24	; 0x1a
		}
		
		
		lastCommand = TxData[1];
 520:	6c ad       	ldd	r22, Y+60	; 0x3c
 522:	fe 01       	movw	r30, r28
 524:	ed 58       	subi	r30, 0x8D	; 141
 526:	ff 4f       	sbci	r31, 0xFF	; 255
 528:	60 83       	st	Z, r22
		
		//clear the NRF_TX_READY flag in the status register
		status &= ~(1<<NRF_TX_READY);
 52a:	1a 8d       	ldd	r17, Y+26	; 0x1a
 52c:	1f 7b       	andi	r17, 0xBF	; 191
		
		if (isSystemCommand(TxData[1]))
 52e:	ce 01       	movw	r24, r28
 530:	0e 94 19 01 	call	0x232	; 0x232 <_ZN3NRF15isSystemCommandEh>
 534:	81 11       	cpse	r24, r1
 536:	02 c0       	rjmp	.+4      	; 0x53c <_ZN3NRF11transferACIEv+0x3c>
		
		
		lastCommand = TxData[1];
		
		//clear the NRF_TX_READY flag in the status register
		status &= ~(1<<NRF_TX_READY);
 538:	1a 8f       	std	Y+26, r17	; 0x1a
 53a:	58 c0       	rjmp	.+176    	; 0x5ec <_ZN3NRF11transferACIEv+0xec>
		
		if (isSystemCommand(TxData[1]))
			status |= (1<<NRF_WAIT_FOR_RESPONSE);
 53c:	10 61       	ori	r17, 0x10	; 16
 53e:	1a 8f       	std	Y+26, r17	; 0x1a
 540:	55 c0       	rjmp	.+170    	; 0x5ec <_ZN3NRF11transferACIEv+0xec>
	}//if hasDataToSend
	
	//receive only
	else if(RDYN == 0)
	{
		clearTxData();
 542:	ce 01       	movw	r24, r28
 544:	0e 94 34 01 	call	0x268	; 0x268 <_ZN3NRF11clearTxDataEv>
		//Request communication with nRF8001
		ClearREQN();
 548:	29 98       	cbi	0x05, 1	; 5
		
		//transmit the DUMMY BYTE and receive the Rx DEBUG BYTE
		//the LENGTH BYTE is not counted as part of the length
		RxData[0] = spi.transfer1byte(0x00);
 54a:	60 e0       	ldi	r22, 0x00	; 0
 54c:	8b e7       	ldi	r24, 0x7B	; 123
 54e:	93 e0       	ldi	r25, 0x03	; 3
 550:	0e 94 ee 00 	call	0x1dc	; 0x1dc <_ZN3SPI13transfer1byteEh>
 554:	8b 8f       	std	Y+27, r24	; 0x1b
		
		//Transmit a DUMMY BYTE and receive the LENGTH BYTE
		RxData[0] = spi.transfer1byte(0x00);
 556:	60 e0       	ldi	r22, 0x00	; 0
 558:	8b e7       	ldi	r24, 0x7B	; 123
 55a:	93 e0       	ldi	r25, 0x03	; 3
 55c:	0e 94 ee 00 	call	0x1dc	; 0x1dc <_ZN3SPI13transfer1byteEh>
 560:	8b 8f       	std	Y+27, r24	; 0x1b
 562:	28 2f       	mov	r18, r24
 564:	80 32       	cpi	r24, 0x20	; 32
 566:	08 f0       	brcs	.+2      	; 0x56a <_ZN3NRF11transferACIEv+0x6a>
 568:	2f e1       	ldi	r18, 0x1F	; 31
		
		length = RxData[0];
		if (length>HAL_ACI_MAX_LENGTH)
			length = HAL_ACI_MAX_LENGTH;
		if (length>0)
 56a:	22 23       	and	r18, r18
 56c:	51 f0       	breq	.+20     	; 0x582 <_ZN3NRF11transferACIEv+0x82>
		{
			
			spi.transfer(&TxData[2],&RxData[1],length);
 56e:	ae 01       	movw	r20, r28
 570:	44 5e       	subi	r20, 0xE4	; 228
 572:	5f 4f       	sbci	r21, 0xFF	; 255
 574:	be 01       	movw	r22, r28
 576:	63 5c       	subi	r22, 0xC3	; 195
 578:	7f 4f       	sbci	r23, 0xFF	; 255
 57a:	8b e7       	ldi	r24, 0x7B	; 123
 57c:	93 e0       	ldi	r25, 0x03	; 3
 57e:	0e 94 db 00 	call	0x1b6	; 0x1b6 <_ZN3SPI8transferEPhS0_h>
		}//if length>0
		
		//Set REQN high to terminate the transfer
		SetREQN();
 582:	29 9a       	sbi	0x05, 1	; 5
		
		//when data is received, clear the ready to receive flag until
		//the received data is handled by the process function
		if (RxData[0] != 0x00){
 584:	8b 8d       	ldd	r24, Y+27	; 0x1b
 586:	88 23       	and	r24, r24
 588:	89 f1       	breq	.+98     	; 0x5ec <_ZN3NRF11transferACIEv+0xec>
			status &= ~(1<<NRF_RX_READY);
 58a:	8a 8d       	ldd	r24, Y+26	; 0x1a
 58c:	8f 77       	andi	r24, 0x7F	; 127
 58e:	8a 8f       	std	Y+26, r24	; 0x1a
 590:	2d c0       	rjmp	.+90     	; 0x5ec <_ZN3NRF11transferACIEv+0xec>
			status |= (1<<NRF_WAIT_FOR_RESPONSE);
				
	}//if hasDataToSend
	
	//receive only
	else if(RDYN == 0)
 592:	2a 99       	sbic	0x05, 2	; 5
 594:	2b c0       	rjmp	.+86     	; 0x5ec <_ZN3NRF11transferACIEv+0xec>
 596:	d5 cf       	rjmp	.-86     	; 0x542 <_ZN3NRF11transferACIEv+0x42>
	//transmit and receive
	if (hasDataToSend() && (TxData[0] > 0)){			
		length = TxData[0];
	
		//Request communication with nRF8001
		ClearREQN();
 598:	29 98       	cbi	0x05, 1	; 5
	
		//Wait for nRF8001 to clear RDYN pin indicating it is ready to receive
		while (RDYN == 1);
 59a:	85 b1       	in	r24, 0x05	; 5
	
		//transmit the Tx LENGTH BYTE and receive the Rx DEBUG BYTE
		//the LENGTH BYTE is not counted as part of the length
		RxData[0] = spi.transfer1byte(TxData[0]);
 59c:	6b ad       	ldd	r22, Y+59	; 0x3b
 59e:	8b e7       	ldi	r24, 0x7B	; 123
 5a0:	93 e0       	ldi	r25, 0x03	; 3
 5a2:	0e 94 ee 00 	call	0x1dc	; 0x1dc <_ZN3SPI13transfer1byteEh>
 5a6:	8b 8f       	std	Y+27, r24	; 0x1b
	
	
		//transmit the first byte of data while receiving the length byte
		//we are discarding the Rx DEBUG BYTE
		RxData[0] = spi.transfer1byte(TxData[1]);
 5a8:	6c ad       	ldd	r22, Y+60	; 0x3c
 5aa:	8b e7       	ldi	r24, 0x7B	; 123
 5ac:	93 e0       	ldi	r25, 0x03	; 3
 5ae:	0e 94 ee 00 	call	0x1dc	; 0x1dc <_ZN3SPI13transfer1byteEh>
 5b2:	8b 8f       	std	Y+27, r24	; 0x1b
	
		////set length to the greater of TxData less the byte we already sent or 
		////RxData length
		length = (RxData[0]>(TxData[0] -1))?RxData[0]:(TxData[0]-1);
 5b4:	4b ad       	ldd	r20, Y+59	; 0x3b
 5b6:	50 e0       	ldi	r21, 0x00	; 0
 5b8:	41 50       	subi	r20, 0x01	; 1
 5ba:	51 09       	sbc	r21, r1
 5bc:	28 2f       	mov	r18, r24
 5be:	30 e0       	ldi	r19, 0x00	; 0
 5c0:	24 17       	cp	r18, r20
 5c2:	35 07       	cpc	r19, r21
 5c4:	0c f4       	brge	.+2      	; 0x5c8 <_ZN3NRF11transferACIEv+0xc8>
 5c6:	9a 01       	movw	r18, r20
 5c8:	20 32       	cpi	r18, 0x20	; 32
 5ca:	08 f0       	brcs	.+2      	; 0x5ce <_ZN3NRF11transferACIEv+0xce>
 5cc:	2f e1       	ldi	r18, 0x1F	; 31
		if (length>HAL_ACI_MAX_LENGTH) 
			length = HAL_ACI_MAX_LENGTH;
			
		//if (length>0)
		spi.transfer(&TxData[2],&RxData[1],length);
 5ce:	ae 01       	movw	r20, r28
 5d0:	44 5e       	subi	r20, 0xE4	; 228
 5d2:	5f 4f       	sbci	r21, 0xFF	; 255
 5d4:	be 01       	movw	r22, r28
 5d6:	63 5c       	subi	r22, 0xC3	; 195
 5d8:	7f 4f       	sbci	r23, 0xFF	; 255
 5da:	8b e7       	ldi	r24, 0x7B	; 123
 5dc:	93 e0       	ldi	r25, 0x03	; 3
 5de:	0e 94 db 00 	call	0x1b6	; 0x1b6 <_ZN3SPI8transferEPhS0_h>
		//for (uint8_t i = 0; i< length; i++){
			//RxData[i+1] = spi.transfer1byte(TxData[i+2]); 
		//}
	
		//Set REQN high to terminate the transfer
		SetREQN();
 5e2:	29 9a       	sbi	0x05, 1	; 5
		
		//when data is received, clear the ready to receive flag until
		//the received data is handled by the process function
		if (RxData[0] != 0x00){
 5e4:	8b 8d       	ldd	r24, Y+27	; 0x1b
 5e6:	81 11       	cpse	r24, r1
 5e8:	98 cf       	rjmp	.-208    	; 0x51a <_ZN3NRF11transferACIEv+0x1a>
 5ea:	9a cf       	rjmp	.-204    	; 0x520 <_ZN3NRF11transferACIEv+0x20>
			status &= ~(1<<NRF_RX_READY);
		}
		
	}//else if(RDYN == 0)	
	
}//transferACI()
 5ec:	df 91       	pop	r29
 5ee:	cf 91       	pop	r28
 5f0:	1f 91       	pop	r17
 5f2:	08 95       	ret

000005f4 <_ZN3NRF11clearRxDataEv>:
void NRF::clearTxData(){
	for(int i = 0; i<32; i++) 
		TxData[i] = 0x00;		
}
void NRF::clearRxData(){
 5f4:	fc 01       	movw	r30, r24
 5f6:	7b 96       	adiw	r30, 0x1b	; 27
	for(int i = 0; i<32; i++)
 5f8:	20 e0       	ldi	r18, 0x00	; 0
 5fa:	30 e0       	ldi	r19, 0x00	; 0
		RxData[i] = 0x00;
 5fc:	11 92       	st	Z+, r1
void NRF::clearTxData(){
	for(int i = 0; i<32; i++) 
		TxData[i] = 0x00;		
}
void NRF::clearRxData(){
	for(int i = 0; i<32; i++)
 5fe:	2f 5f       	subi	r18, 0xFF	; 255
 600:	3f 4f       	sbci	r19, 0xFF	; 255
 602:	20 32       	cpi	r18, 0x20	; 32
 604:	31 05       	cpc	r19, r1
 606:	d1 f7       	brne	.-12     	; 0x5fc <_ZN3NRF11clearRxDataEv+0x8>
		RxData[i] = 0x00;
}
 608:	08 95       	ret

0000060a <_ZN3NRF22processCommandResponseEv>:
			
		}
	}//else RxData
}//process

void NRF::processCommandResponse(){
 60a:	cf 93       	push	r28
 60c:	df 93       	push	r29
 60e:	ec 01       	movw	r28, r24
	//	2		CommandOpCode (see switch statement below)
	//	3		Status of command execution
	//	4..31	Command specific data
	
	
	switch (RxData[2]){	//CommandOpCode
 610:	4d 8d       	ldd	r20, Y+29	; 0x1d
 612:	50 e0       	ldi	r21, 0x00	; 0
 614:	fa 01       	movw	r30, r20
 616:	31 97       	sbiw	r30, 0x01	; 1
 618:	ee 31       	cpi	r30, 0x1E	; 30
 61a:	f1 05       	cpc	r31, r1
 61c:	08 f0       	brcs	.+2      	; 0x620 <_ZN3NRF22processCommandResponseEv+0x16>
 61e:	6c c0       	rjmp	.+216    	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
 620:	ec 5c       	subi	r30, 0xCC	; 204
 622:	ff 4f       	sbci	r31, 0xFF	; 255
 624:	0c 94 e6 05 	jmp	0xbcc	; 0xbcc <__tablejump2__>
			//RxData[3]	:	Status
			//					ACI_STATUS_ERROR_DEVICE_STATE_INVALID when used in incorrect mode
			//						can only be used in NRF_MODE_TEST, NRF_MODE_SETUP, NRF_MODE_STANDBY
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 628:	8a 8d       	ldd	r24, Y+26	; 0x1a
 62a:	8f 7e       	andi	r24, 0xEF	; 239
 62c:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 62e:	64 c0       	rjmp	.+200    	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[3]	:	Status
			//					ACI_STATUS_ERROR_DEVICE_STATE_INVALID when used in incorrect mode
			//						can only be used in NRF_MODE_TEST
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 630:	8a 8d       	ldd	r24, Y+26	; 0x1a
 632:	8f 7e       	andi	r24, 0xEF	; 239
 634:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 636:	60 c0       	rjmp	.+192    	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[4-5]	:	DTM Event (2 bytes MSB/LSB)
			//Refer to Bluetooth Core specification v4.0, Volume 6, Part F, Direct Test Mode,
			//Sect.3.4, ‘Events’, for description of DTM event format and content
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 638:	8a 8d       	ldd	r24, Y+26	; 0x1a
 63a:	8f 7e       	andi	r24, 0xEF	; 239
 63c:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 63e:	5c c0       	rjmp	.+184    	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[3]	:	Status
			//					ACI_STATUS_ERROR_DEVICE_STATE_INVALID when used in incorrect mode
			//						can only be used in NRF_MODE_STANDBY
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 640:	8a 8d       	ldd	r24, Y+26	; 0x1a
 642:	8f 7e       	andi	r24, 0xEF	; 239
 644:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 646:	58 c0       	rjmp	.+176    	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
			//then a NRF_EVT_COMMAND_RESPONSE with a NRF_CMD_WAKEUP, which brings us here
			//RxData[3]		: status - better be success
			//RxData[4]		: none
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 648:	8a 8d       	ldd	r24, Y+26	; 0x1a
 64a:	8f 7e       	andi	r24, 0xEF	; 239
 64c:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 64e:	54 c0       	rjmp	.+168    	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
			
				
			//on the last run of CMD_SETUP
			//do NOT clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			//the NRF_CMD_SETUP will be followed by NRF_EVT_DEVICE_STARTED			
			if (RxData[3] == ACI_STATUS_TRANSACTION_CONTINUE){
 650:	8e 8d       	ldd	r24, Y+30	; 0x1e
 652:	81 30       	cpi	r24, 0x01	; 1
 654:	19 f4       	brne	.+6      	; 0x65c <_ZN3NRF22processCommandResponseEv+0x52>
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 656:	8a 8d       	ldd	r24, Y+26	; 0x1a
 658:	8f 7e       	andi	r24, 0xEF	; 239
 65a:	8a 8f       	std	Y+26, r24	; 0x1a
			}
			
			//set the NRF_RX_READY bit in the status register
			status |= (1<<NRF_RX_READY);
 65c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 65e:	80 68       	ori	r24, 0x80	; 128
 660:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 662:	4a c0       	rjmp	.+148    	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_READ_DYNAMIC_DATA:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 664:	8a 8d       	ldd	r24, Y+26	; 0x1a
 666:	8f 7e       	andi	r24, 0xEF	; 239
 668:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 66a:	46 c0       	rjmp	.+140    	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_WRITE_DYNAMIC_DATA:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 66c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 66e:	8f 7e       	andi	r24, 0xEF	; 239
 670:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 672:	42 c0       	rjmp	.+132    	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[4-5]	:	Config ID - (LSB/MSB)
			//RxData[6]		:	ACI Protocol version
			//
		
			//TODO: finish this
			version = RxData[6];
 674:	89 a1       	ldd	r24, Y+33	; 0x21
 676:	90 e0       	ldi	r25, 0x00	; 0
 678:	99 8f       	std	Y+25, r25	; 0x19
 67a:	88 8f       	std	Y+24, r24	; 0x18
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 67c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 67e:	8f 7e       	andi	r24, 0xEF	; 239
 680:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 682:	3a c0       	rjmp	.+116    	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_GET_DEVICE_ADDRESS:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 684:	8a 8d       	ldd	r24, Y+26	; 0x1a
 686:	8f 7e       	andi	r24, 0xEF	; 239
 688:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 68a:	36 c0       	rjmp	.+108    	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_GET_BATTERY_LEVEL:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 68c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 68e:	8f 7e       	andi	r24, 0xEF	; 239
 690:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 692:	32 c0       	rjmp	.+100    	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
			// RxData[5] : temperature MSB
		
			//data[0] = NRF_CMD_GET_TEMPERATURE;
			//data[1] = RxData[4];
			//data[2] = RxData[3];
			if (RxData[3] == ACI_STATUS_SUCCESS)
 694:	8e 8d       	ldd	r24, Y+30	; 0x1e
 696:	81 11       	cpse	r24, r1
 698:	09 c0       	rjmp	.+18     	; 0x6ac <_ZN3NRF22processCommandResponseEv+0xa2>
			temperature = (RxData[5]<<4 | RxData[4]);
 69a:	88 a1       	ldd	r24, Y+32	; 0x20
 69c:	20 e1       	ldi	r18, 0x10	; 16
 69e:	82 9f       	mul	r24, r18
 6a0:	c0 01       	movw	r24, r0
 6a2:	11 24       	eor	r1, r1
 6a4:	2f 8d       	ldd	r18, Y+31	; 0x1f
 6a6:	82 2b       	or	r24, r18
 6a8:	9f 8b       	std	Y+23, r25	; 0x17
 6aa:	8e 8b       	std	Y+22, r24	; 0x16
			clearRxData();
 6ac:	ce 01       	movw	r24, r28
 6ae:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <_ZN3NRF11clearRxDataEv>
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6b2:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6b4:	8f 7e       	andi	r24, 0xEF	; 239
 6b6:	8a 8f       	std	Y+26, r24	; 0x1a
		break;
 6b8:	1f c0       	rjmp	.+62     	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
			case NRF_CMD_RADIO_RESET:
			//will initialization have to be redone upon reset?
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6ba:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6bc:	8f 7e       	andi	r24, 0xEF	; 239
 6be:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6c0:	1b c0       	rjmp	.+54     	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
			//status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
			break;
		case NRF_CMD_SET_TX_POWER:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6c2:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6c4:	8f 7e       	andi	r24, 0xEF	; 239
 6c6:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6c8:	17 c0       	rjmp	.+46     	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
			//or by NRF_EVT_PIPE_ERROR(failure)
			break;
		case NRF_CMD_SET_APP_LATENCY:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6ca:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6cc:	8f 7e       	andi	r24, 0xEF	; 239
 6ce:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6d0:	13 c0       	rjmp	.+38     	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_SET_KEY:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6d2:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6d4:	8f 7e       	andi	r24, 0xEF	; 239
 6d6:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6d8:	0f c0       	rjmp	.+30     	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_OPEN_ADV_PIPE:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6da:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6dc:	8f 7e       	andi	r24, 0xEF	; 239
 6de:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6e0:	0b c0       	rjmp	.+22     	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_BROADCAST:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6e2:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6e4:	8f 7e       	andi	r24, 0xEF	; 239
 6e6:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6e8:	07 c0       	rjmp	.+14     	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_BOND_SEC_REQUEST:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6ea:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6ec:	8f 7e       	andi	r24, 0xEF	; 239
 6ee:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6f0:	03 c0       	rjmp	.+6      	; 0x6f8 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_DIRECT_CONNECT:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6f2:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6f4:	8f 7e       	andi	r24, 0xEF	; 239
 6f6:	8a 8f       	std	Y+26, r24	; 0x1a
		default:
			break;
		
	}//end switch RxData[2]
	
}//processCommandResponse()
 6f8:	df 91       	pop	r29
 6fa:	cf 91       	pop	r28
 6fc:	08 95       	ret

000006fe <_ZN3NRF7processEv>:
	//set to INIT_MODE and RX_READY
	//we are waiting for a NRF_EVT_DEVICE_STARTED in NRF_MODE_SETUP
	//status |= (1<<NRF_RX_READY | 1<<NRF_INIT_MODE | 1<<NRF_WAIT_FOR_RESPONSE);
	status |= (1<<NRF_RX_READY | 1<<NRF_WAIT_FOR_RESPONSE);
}
void NRF::process(void){	
 6fe:	1f 93       	push	r17
 700:	cf 93       	push	r28
 702:	df 93       	push	r29
 704:	ec 01       	movw	r28, r24
	uint8_t i;
	if (isReadyToReceiveData()){
 706:	8a 8d       	ldd	r24, Y+26	; 0x1a
 708:	88 23       	and	r24, r24
 70a:	1c f4       	brge	.+6      	; 0x712 <_ZN3NRF7processEv+0x14>
		clearRxData();
 70c:	ce 01       	movw	r24, r28
 70e:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <_ZN3NRF11clearRxDataEv>
	}
		
	
	//setup message from services.h file loaded onto nRF8001
	if( (mode == NRF_MODE_SETUP)  && !hasDataToSend() && !waitingForResponse() ) {
 712:	fe 01       	movw	r30, r28
 714:	ef 58       	subi	r30, 0x8F	; 143
 716:	ff 4f       	sbci	r31, 0xFF	; 255
 718:	80 81       	ld	r24, Z
 71a:	82 30       	cpi	r24, 0x02	; 2
 71c:	31 f5       	brne	.+76     	; 0x76a <_ZN3NRF7processEv+0x6c>
 71e:	ce 01       	movw	r24, r28
 720:	0e 94 fd 00 	call	0x1fa	; 0x1fa <_ZN3NRF13hasDataToSendEv>
 724:	81 11       	cpse	r24, r1
 726:	21 c0       	rjmp	.+66     	; 0x76a <_ZN3NRF7processEv+0x6c>
 728:	ce 01       	movw	r24, r28
 72a:	0e 94 03 01 	call	0x206	; 0x206 <_ZN3NRF18waitingForResponseEv>
 72e:	88 23       	and	r24, r24
 730:	09 f4       	brne	.+2      	; 0x734 <_ZN3NRF7processEv+0x36>
 732:	c5 c0       	rjmp	.+394    	; 0x8be <_ZN3NRF7processEv+0x1c0>
 734:	1a c0       	rjmp	.+52     	; 0x76a <_ZN3NRF7processEv+0x6c>
		//load current line of setup msg into TX buffer
		for(int i = 0; i <= setup_msgs[initCount].buffer[0]; i++){
#ifdef PROGRAMSPACE			
			TxData[i] = pgm_read_byte(&setup_msgs[initCount].buffer[i]);
#else
			TxData[i] = setup_msgs[initCount].buffer[i];
 736:	dc 01       	movw	r26, r24
 738:	a2 0f       	add	r26, r18
 73a:	b3 1f       	adc	r27, r19
 73c:	11 96       	adiw	r26, 0x01	; 1
 73e:	6c 91       	ld	r22, X
 740:	61 93       	st	Z+, r22
		
	
	//setup message from services.h file loaded onto nRF8001
	if( (mode == NRF_MODE_SETUP)  && !hasDataToSend() && !waitingForResponse() ) {
		//load current line of setup msg into TX buffer
		for(int i = 0; i <= setup_msgs[initCount].buffer[0]; i++){
 742:	2f 5f       	subi	r18, 0xFF	; 255
 744:	3f 4f       	sbci	r19, 0xFF	; 255
 746:	42 17       	cp	r20, r18
 748:	53 07       	cpc	r21, r19
 74a:	ac f7       	brge	.-22     	; 0x736 <_ZN3NRF7processEv+0x38>
			TxData[i] = setup_msgs[initCount].buffer[i];
#endif
		}
		
		//set transmit ready and wait for response flags in status register
		status |= ((1<<NRF_TX_READY));
 74c:	9a 8d       	ldd	r25, Y+26	; 0x1a
 74e:	90 64       	ori	r25, 0x40	; 64
 750:	9a 8f       	std	Y+26, r25	; 0x1a
		
		initCount++;
 752:	81 e0       	ldi	r24, 0x01	; 1
 754:	87 0f       	add	r24, r23
		////after the last setup message
		if (initCount > NB_SETUP_MESSAGES) 
 756:	84 31       	cpi	r24, 0x14	; 20
 758:	18 f4       	brcc	.+6      	; 0x760 <_ZN3NRF7processEv+0x62>
		}
		
		//set transmit ready and wait for response flags in status register
		status |= ((1<<NRF_TX_READY));
		
		initCount++;
 75a:	80 93 7a 03 	sts	0x037A, r24
 75e:	05 c0       	rjmp	.+10     	; 0x76a <_ZN3NRF7processEv+0x6c>
		////after the last setup message
		if (initCount > NB_SETUP_MESSAGES) 
		{
			initCount = 0;
 760:	10 92 7a 03 	sts	0x037A, r1
			
			clearTxData();
 764:	ce 01       	movw	r24, r28
 766:	0e 94 34 01 	call	0x268	; 0x268 <_ZN3NRF11clearTxDataEv>
}
uint8_t NRF::hasDataToSend(void){
	return ((status & (1<<NRF_TX_READY))?TRUE:FALSE);
}
uint8_t NRF::isReadyToReceiveData(){
	return ((status & (1<<NRF_RX_READY))?TRUE:FALSE);
 76a:	1a 8d       	ldd	r17, Y+26	; 0x1a
	}//setup message
	
	
	//handle messages received from nRF8001
	//else //testing**************************************************************************************
	if (!isReadyToReceiveData()){
 76c:	11 23       	and	r17, r17
 76e:	0c f4       	brge	.+2      	; 0x772 <_ZN3NRF7processEv+0x74>
 770:	9b c0       	rjmp	.+310    	; 0x8a8 <_ZN3NRF7processEv+0x1aa>
		RxCount++;
 772:	8d 89       	ldd	r24, Y+21	; 0x15
 774:	91 e0       	ldi	r25, 0x01	; 1
 776:	98 0f       	add	r25, r24
 778:	9d 8b       	std	Y+21, r25	; 0x15
				
		switch (RxData[1]){
 77a:	4c 8d       	ldd	r20, Y+28	; 0x1c
 77c:	50 e0       	ldi	r21, 0x00	; 0
 77e:	fa 01       	movw	r30, r20
 780:	e1 58       	subi	r30, 0x81	; 129
 782:	f1 09       	sbc	r31, r1
 784:	ef 30       	cpi	r30, 0x0F	; 15
 786:	f1 05       	cpc	r31, r1
 788:	08 f0       	brcs	.+2      	; 0x78c <_ZN3NRF7processEv+0x8e>
 78a:	89 c0       	rjmp	.+274    	; 0x89e <_ZN3NRF7processEv+0x1a0>
 78c:	ee 5a       	subi	r30, 0xAE	; 174
 78e:	ff 4f       	sbci	r31, 0xFF	; 255
 790:	0c 94 e6 05 	jmp	0xbcc	; 0xbcc <__tablejump2__>
				//RxData[2]		:	service pipe number
				//RxData[3..23]	:	Data
				
				// Fill data with RxData values
				
				for (i = 0; i< RxData[0] - 1;i++){
 794:	5b 8d       	ldd	r21, Y+27	; 0x1b
 796:	25 2f       	mov	r18, r21
 798:	30 e0       	ldi	r19, 0x00	; 0
 79a:	21 50       	subi	r18, 0x01	; 1
 79c:	31 09       	sbc	r19, r1
 79e:	12 16       	cp	r1, r18
 7a0:	13 06       	cpc	r1, r19
 7a2:	0c f4       	brge	.+2      	; 0x7a6 <_ZN3NRF7processEv+0xa8>
 7a4:	68 c0       	rjmp	.+208    	; 0x876 <_ZN3NRF7processEv+0x178>
 7a6:	75 c0       	rjmp	.+234    	; 0x892 <_ZN3NRF7processEv+0x194>
				//					0x02	Setup
				//					0x03	Standby
				//RxData[3]	:	HWError 0x01 = error, 0x00 = no error
				//RxData[4]	:	DataCreditAvailable - Number of DataCommand buffers available
				
				if (RxData[2]>0)
 7a8:	8d 8d       	ldd	r24, Y+29	; 0x1d
 7aa:	88 23       	and	r24, r24
 7ac:	21 f0       	breq	.+8      	; 0x7b6 <_ZN3NRF7processEv+0xb8>
					mode = RxData[2];
 7ae:	fe 01       	movw	r30, r28
 7b0:	ef 58       	subi	r30, 0x8F	; 143
 7b2:	ff 4f       	sbci	r31, 0xFF	; 255
 7b4:	80 83       	st	Z, r24
				
				
				//when NRF_CMD_WAKEUP has been called, the NRF_WAIT_FOR_RESPONSE bit in the status register should NOT be cleared
				//when finishing a NRF_CMD_SETUP, the NRF_WAIT_FOR_RESPONSE bit in the status register SHOULD be cleared
				if (mode == NRF_MODE_SETUP){
 7b6:	fe 01       	movw	r30, r28
 7b8:	ef 58       	subi	r30, 0x8F	; 143
 7ba:	ff 4f       	sbci	r31, 0xFF	; 255
 7bc:	80 81       	ld	r24, Z
 7be:	82 30       	cpi	r24, 0x02	; 2
 7c0:	19 f4       	brne	.+6      	; 0x7c8 <_ZN3NRF7processEv+0xca>
				//if (isInitializing()){
					//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
					status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 7c2:	1f 7e       	andi	r17, 0xEF	; 239
 7c4:	1a 8f       	std	Y+26, r17	; 0x1a
 7c6:	0a c0       	rjmp	.+20     	; 0x7dc <_ZN3NRF7processEv+0xde>
					
				}
				
				
				if (mode == NRF_MODE_STANDBY){
 7c8:	83 30       	cpi	r24, 0x03	; 3
 7ca:	41 f4       	brne	.+16     	; 0x7dc <_ZN3NRF7processEv+0xde>
					//clear the NRF_INIT_MODE bit in the status register when SETUP finishes
					//status &= ~(1<<NRF_INIT_MODE);
					dataCredit = RxData[4];
 7cc:	8f 8d       	ldd	r24, Y+31	; 0x1f
 7ce:	fe 01       	movw	r30, r28
 7d0:	ee 58       	subi	r30, 0x8E	; 142
 7d2:	ff 4f       	sbci	r31, 0xFF	; 255
 7d4:	80 83       	st	Z, r24
					status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 7d6:	8a 8d       	ldd	r24, Y+26	; 0x1a
 7d8:	8f 7e       	andi	r24, 0xEF	; 239
 7da:	8a 8f       	std	Y+26, r24	; 0x1a
				}
				
				
				
				//set the NRF_RX_READY bit in the status register
				status |= (1<<NRF_RX_READY);
 7dc:	8a 8d       	ldd	r24, Y+26	; 0x1a
 7de:	80 68       	ori	r24, 0x80	; 128
 7e0:	8a 8f       	std	Y+26, r24	; 0x1a
				
				//TODO: error handling
				break;
 7e2:	5e c0       	rjmp	.+188    	; 0x8a0 <_ZN3NRF7processEv+0x1a2>
			case NRF_EVT_ECHO:				//0x82
				//returns an identical copy of the PDU sent using the echo command in Test Mode
				//RxData[0]	:	length
				//RxData[1]	:	NRF_EVT_ECHO (0x82)
				//RxData[2..31]	:	Identical message to one sent with NRF_CMD_ECHO
				data[0] = RxData[0];
 7e4:	8b 8d       	ldd	r24, Y+27	; 0x1b
 7e6:	88 83       	st	Y, r24
				data[1] = RxData[1];
 7e8:	82 e8       	ldi	r24, 0x82	; 130
 7ea:	89 83       	std	Y+1, r24	; 0x01
				data[2] = RxData[2];
 7ec:	8d 8d       	ldd	r24, Y+29	; 0x1d
 7ee:	8a 83       	std	Y+2, r24	; 0x02
				data[3] = RxData[3];
 7f0:	8e 8d       	ldd	r24, Y+30	; 0x1e
 7f2:	8b 83       	std	Y+3, r24	; 0x03
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 7f4:	1f 7e       	andi	r17, 0xEF	; 239
 7f6:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 7f8:	53 c0       	rjmp	.+166    	; 0x8a0 <_ZN3NRF7processEv+0x1a2>
			case NRF_EVT_HARDWARE_ERROR:	//0x83
				//provides debug information
				//in case of firmware failure, this event follows NRF_EVT_DEVICE_STARTED
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 7fa:	1f 7e       	andi	r17, 0xEF	; 239
 7fc:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 7fe:	50 c0       	rjmp	.+160    	; 0x8a0 <_ZN3NRF7processEv+0x1a2>
			case NRF_EVT_COMMAND_RESPONSE:	//0x84
				//confirms reception or execution of an ACI command
				processCommandResponse();				
 800:	ce 01       	movw	r24, r28
 802:	0e 94 05 03 	call	0x60a	; 0x60a <_ZN3NRF22processCommandResponseEv>
				break;
 806:	4c c0       	rjmp	.+152    	; 0x8a0 <_ZN3NRF7processEv+0x1a2>
				status |= (1<<NRF_CONNECTED);
				
							//do NOT clear the NRF_WAIT_FOR_RESPONSE bit of the status register here
							//there will be either a NRF_EVT_BOND_STATUS or a NRF_EVT_PIPE_STATUS following NRF_EVT_CONNECTED
				//actually it seems to need to be cleared here
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 808:	81 2f       	mov	r24, r17
 80a:	8f 7e       	andi	r24, 0xEF	; 239
 80c:	88 60       	ori	r24, 0x08	; 8
 80e:	8a 8f       	std	Y+26, r24	; 0x1a
				
				break;
 810:	47 c0       	rjmp	.+142    	; 0x8a0 <_ZN3NRF7processEv+0x1a2>
				
				//TODO: can we be still connected if we get here through a failure to bond
				status &= ~(1<<NRF_CONNECTED | 1<<NRF_BONDED);
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 812:	13 7e       	andi	r17, 0xE3	; 227
 814:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 816:	44 c0       	rjmp	.+136    	; 0x8a0 <_ZN3NRF7processEv+0x1a2>
				//					0x02		: generated by the remote peer.
				//	4		:	BondStatus-SecMode1 - LE Security Mode 1
				//	5		:	LE Security Mode 2
				//	6		:	Keys Exchanged (slave)
				//	7		:	Keys Exchanged (master)
				if (RxData[2] == 0x00){ // successful bond
 818:	8d 8d       	ldd	r24, Y+29	; 0x1d
 81a:	81 11       	cpse	r24, r1
 81c:	02 c0       	rjmp	.+4      	; 0x822 <_ZN3NRF7processEv+0x124>
					status |= (1<<NRF_BONDED);
 81e:	14 60       	ori	r17, 0x04	; 4
 820:	1a 8f       	std	Y+26, r17	; 0x1a
				}
				
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 822:	8a 8d       	ldd	r24, Y+26	; 0x1a
 824:	8f 7e       	andi	r24, 0xEF	; 239
 826:	8a 8f       	std	Y+26, r24	; 0x1a
				break;
 828:	3b c0       	rjmp	.+118    	; 0x8a0 <_ZN3NRF7processEv+0x1a2>
 82a:	fe 01       	movw	r30, r28
 82c:	ed 59       	subi	r30, 0x9D	; 157
 82e:	ff 4f       	sbci	r31, 0xFF	; 255
	//handle messages received from nRF8001
	//else //testing**************************************************************************************
	if (!isReadyToReceiveData()){
		RxCount++;
				
		switch (RxData[1]){
 830:	80 e0       	ldi	r24, 0x00	; 0
 832:	df 01       	movw	r26, r30
 834:	a6 54       	subi	r26, 0x46	; 70
 836:	b1 09       	sbc	r27, r1
				//this event is sent when there is a change in service pipe availability
				//RxData[2..9]		: 64-bit PipesOpen bitmap
				//RxData[10..17]	: 64-bit PipesClosed bitmap
				//see pg 148 of datasheet for details
				for (i = 0 ; i<8; i++){
					pipesOpen[i] = RxData[i+2];
 838:	9c 91       	ld	r25, X
 83a:	de 96       	adiw	r26, 0x3e	; 62
 83c:	9c 93       	st	X, r25
 83e:	d6 97       	sbiw	r26, 0x36	; 54
					pipesClosed[i] = RxData[i+10];
 840:	9c 91       	ld	r25, X
 842:	91 93       	st	Z+, r25
			case NRF_EVT_PIPE_STATUS:
				//this event is sent when there is a change in service pipe availability
				//RxData[2..9]		: 64-bit PipesOpen bitmap
				//RxData[10..17]	: 64-bit PipesClosed bitmap
				//see pg 148 of datasheet for details
				for (i = 0 ; i<8; i++){
 844:	8f 5f       	subi	r24, 0xFF	; 255
 846:	88 30       	cpi	r24, 0x08	; 8
 848:	a1 f7       	brne	.-24     	; 0x832 <_ZN3NRF7processEv+0x134>
					pipesOpen[i] = RxData[i+2];
					pipesClosed[i] = RxData[i+10];
				}
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 84a:	1f 7e       	andi	r17, 0xEF	; 239
 84c:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 84e:	28 c0       	rjmp	.+80     	; 0x8a0 <_ZN3NRF7processEv+0x1a2>
				//RxData[2-3]	: ConnectionInterval (MSB first)
				//RxData[4-5]	: SlaveLatency (LSB/MSB)
				//RxData[6-7]	: SupervisionTimeout (x10ms)
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 850:	1f 7e       	andi	r17, 0xEF	; 239
 852:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 854:	25 c0       	rjmp	.+74     	; 0x8a0 <_ZN3NRF7processEv+0x1a2>
			case NRF_EVT_DISPLAY_KEY:
				//RxData[2..7] A fixed 6-byte ASCII string representing the passkey
				//padded with zeros if shorter than 6 digits
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 856:	1f 7e       	andi	r17, 0xEF	; 239
 858:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 85a:	22 c0       	rjmp	.+68     	; 0x8a0 <_ZN3NRF7processEv+0x1a2>
			case NRF_EVT_KEY_REQUEST:
				//RxData[2] : key requested
				//must send the SetKey command within 30 seconds after receiving this command
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 85c:	1f 7e       	andi	r17, 0xEF	; 239
 85e:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 860:	1f c0       	rjmp	.+62     	; 0x8a0 <_ZN3NRF7processEv+0x1a2>
			//Data Events:
			case NRF_EVT_DATA_CREDIT:		//0x8A
				//RxData[2]	:	number of data credits returned to the application controller
				dataCredit += RxData[2];	
 862:	fe 01       	movw	r30, r28
 864:	ee 58       	subi	r30, 0x8E	; 142
 866:	ff 4f       	sbci	r31, 0xFF	; 255
 868:	9d 8d       	ldd	r25, Y+29	; 0x1d
 86a:	80 81       	ld	r24, Z
 86c:	89 0f       	add	r24, r25
 86e:	80 83       	st	Z, r24
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);			
 870:	1f 7e       	andi	r17, 0xEF	; 239
 872:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 874:	15 c0       	rjmp	.+42     	; 0x8a0 <_ZN3NRF7processEv+0x1a2>
				//RxData[2]		:	service pipe number
				//RxData[3..23]	:	Data
				
				// Fill data with RxData values
				
				for (i = 0; i< RxData[0] - 1;i++){
 876:	80 e0       	ldi	r24, 0x00	; 0
 878:	90 e0       	ldi	r25, 0x00	; 0
 87a:	40 e0       	ldi	r20, 0x00	; 0
					data[i] = RxData[0] + 2;
 87c:	5e 5f       	subi	r21, 0xFE	; 254
 87e:	fe 01       	movw	r30, r28
 880:	e8 0f       	add	r30, r24
 882:	f9 1f       	adc	r31, r25
 884:	50 83       	st	Z, r21
				//RxData[2]		:	service pipe number
				//RxData[3..23]	:	Data
				
				// Fill data with RxData values
				
				for (i = 0; i< RxData[0] - 1;i++){
 886:	4f 5f       	subi	r20, 0xFF	; 255
 888:	84 2f       	mov	r24, r20
 88a:	90 e0       	ldi	r25, 0x00	; 0
 88c:	82 17       	cp	r24, r18
 88e:	93 07       	cpc	r25, r19
 890:	b4 f3       	brlt	.-20     	; 0x87e <_ZN3NRF7processEv+0x180>
					data[i] = RxData[0] + 2;
				}
				//
				//status |= (1<<NRF_DATA_TO_PROCESS);
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 892:	1f 7e       	andi	r17, 0xEF	; 239
 894:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 896:	04 c0       	rjmp	.+8      	; 0x8a0 <_ZN3NRF7processEv+0x1a2>
			case NRF_EVT_PIPE_ERROR:
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 898:	1f 7e       	andi	r17, 0xEF	; 239
 89a:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 89c:	01 c0       	rjmp	.+2      	; 0x8a0 <_ZN3NRF7processEv+0x1a2>
			default:			
				RxCount--;
 89e:	8d 8b       	std	Y+21, r24	; 0x15
				//RxData[0] = 0x00;					
				break;
		}//end switch		
		
		//set the NRF_RX_READY bit in the status register
		status |= (1<<NRF_RX_READY);
 8a0:	8a 8d       	ldd	r24, Y+26	; 0x1a
 8a2:	80 68       	ori	r24, 0x80	; 128
 8a4:	8a 8f       	std	Y+26, r24	; 0x1a
 8a6:	20 c0       	rjmp	.+64     	; 0x8e8 <_ZN3NRF7processEv+0x1ea>
	else{
		//Receive Buffer doesn't contain useful data
		
		//if nRF8001 is requesting transfer, receive it
		//if we have data to send, send it
		if ((RDYN == 0) || (hasDataToSend())) {			
 8a8:	2a 9b       	sbis	0x05, 2	; 5
 8aa:	05 c0       	rjmp	.+10     	; 0x8b6 <_ZN3NRF7processEv+0x1b8>
 8ac:	ce 01       	movw	r24, r28
 8ae:	0e 94 fd 00 	call	0x1fa	; 0x1fa <_ZN3NRF13hasDataToSendEv>
 8b2:	88 23       	and	r24, r24
 8b4:	c9 f0       	breq	.+50     	; 0x8e8 <_ZN3NRF7processEv+0x1ea>
			transferACI();
 8b6:	ce 01       	movw	r24, r28
 8b8:	0e 94 80 02 	call	0x500	; 0x500 <_ZN3NRF11transferACIEv>
 8bc:	15 c0       	rjmp	.+42     	; 0x8e8 <_ZN3NRF7processEv+0x1ea>
		
	
	//setup message from services.h file loaded onto nRF8001
	if( (mode == NRF_MODE_SETUP)  && !hasDataToSend() && !waitingForResponse() ) {
		//load current line of setup msg into TX buffer
		for(int i = 0; i <= setup_msgs[initCount].buffer[0]; i++){
 8be:	70 91 7a 03 	lds	r23, 0x037A
 8c2:	61 e2       	ldi	r22, 0x21	; 33
 8c4:	76 9f       	mul	r23, r22
 8c6:	f0 01       	movw	r30, r0
 8c8:	11 24       	eor	r1, r1
 8ca:	e9 5f       	subi	r30, 0xF9	; 249
 8cc:	fe 4f       	sbci	r31, 0xFE	; 254
 8ce:	41 81       	ldd	r20, Z+1	; 0x01
 8d0:	50 e0       	ldi	r21, 0x00	; 0
 8d2:	fe 01       	movw	r30, r28
 8d4:	fb 96       	adiw	r30, 0x3b	; 59
 8d6:	20 e0       	ldi	r18, 0x00	; 0
 8d8:	30 e0       	ldi	r19, 0x00	; 0
#ifdef PROGRAMSPACE			
			TxData[i] = pgm_read_byte(&setup_msgs[initCount].buffer[i]);
#else
			TxData[i] = setup_msgs[initCount].buffer[i];
 8da:	61 e2       	ldi	r22, 0x21	; 33
 8dc:	76 9f       	mul	r23, r22
 8de:	c0 01       	movw	r24, r0
 8e0:	11 24       	eor	r1, r1
 8e2:	89 5f       	subi	r24, 0xF9	; 249
 8e4:	9e 4f       	sbci	r25, 0xFE	; 254
 8e6:	27 cf       	rjmp	.-434    	; 0x736 <_ZN3NRF7processEv+0x38>
		if ((RDYN == 0) || (hasDataToSend())) {			
			transferACI();
			
		}
	}//else RxData
}//process
 8e8:	df 91       	pop	r29
 8ea:	cf 91       	pop	r28
 8ec:	1f 91       	pop	r17
 8ee:	08 95       	ret

000008f0 <_GLOBAL__sub_I_spi>:
	//(1<<MSTR)|             // Master/Slave select
	//(0<<SPR1)|(1<<SPR0)|   // SPI Clock Rate
	//(0<<CPOL)|             // Clock Polarity (0:SCK low / 1:SCK hi when idle)
	//(0<<CPHA))             // Clock Phase (0:leading / 1:trailing edge sampling)

SPI spi(SPI_SETTING);
 8f0:	63 e7       	ldi	r22, 0x73	; 115
 8f2:	8b e7       	ldi	r24, 0x7B	; 123
 8f4:	93 e0       	ldi	r25, 0x03	; 3
 8f6:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <_ZN3SPIC1Eh>
 8fa:	08 95       	ret

000008fc <_ZN6TIMER1C1Ehhj>:
TIMER1::TIMER1(){
	TIMER1(TIMER_DIV1, 0, 0);
}

///@brief initialize AD converter on Atmega168 for
TIMER1::TIMER1(uint8_t pscalar, uint8_t WGMmode, uint16_t rload){
 8fc:	fc 01       	movw	r30, r24
	reload = rload;
 8fe:	33 83       	std	Z+3, r19	; 0x03
 900:	22 83       	std	Z+2, r18	; 0x02
	mode = WGMmode;
 902:	41 83       	std	Z+1, r20	; 0x01
	prescalar = pscalar;
 904:	60 83       	st	Z, r22
	
	// The PRTIM1 bit in the Power reduction register must be written to zero to enable Timer/Counter1 module.
	PRR &= ~(1<<PRTIM1);
 906:	a4 e6       	ldi	r26, 0x64	; 100
 908:	b0 e0       	ldi	r27, 0x00	; 0
 90a:	8c 91       	ld	r24, X
 90c:	87 7f       	andi	r24, 0xF7	; 247
 90e:	8c 93       	st	X, r24
	
	//disable timer1
	TCCR1B = 0x00;
 910:	10 92 81 00 	sts	0x0081, r1
	
	//clear counter	
	TCNT1 = 0;
 914:	10 92 85 00 	sts	0x0085, r1
 918:	10 92 84 00 	sts	0x0084, r1
	
	//set reload value
	if (mode == 4) OCR1A = reload;
 91c:	81 81       	ldd	r24, Z+1	; 0x01
 91e:	84 30       	cpi	r24, 0x04	; 4
 920:	31 f4       	brne	.+12     	; 0x92e <_ZN6TIMER1C1Ehhj+0x32>
 922:	82 81       	ldd	r24, Z+2	; 0x02
 924:	93 81       	ldd	r25, Z+3	; 0x03
 926:	90 93 89 00 	sts	0x0089, r25
 92a:	80 93 88 00 	sts	0x0088, r24
	if (mode == 12) ICR1 = reload;
 92e:	81 81       	ldd	r24, Z+1	; 0x01
 930:	8c 30       	cpi	r24, 0x0C	; 12
 932:	31 f4       	brne	.+12     	; 0x940 <_ZN6TIMER1C1Ehhj+0x44>
 934:	82 81       	ldd	r24, Z+2	; 0x02
 936:	93 81       	ldd	r25, Z+3	; 0x03
 938:	90 93 87 00 	sts	0x0087, r25
 93c:	80 93 86 00 	sts	0x0086, r24
	if (mode == 0) TCNT1 = reload;
 940:	81 81       	ldd	r24, Z+1	; 0x01
 942:	81 11       	cpse	r24, r1
 944:	06 c0       	rjmp	.+12     	; 0x952 <_ZN6TIMER1C1Ehhj+0x56>
 946:	82 81       	ldd	r24, Z+2	; 0x02
 948:	93 81       	ldd	r25, Z+3	; 0x03
 94a:	90 93 85 00 	sts	0x0085, r25
 94e:	80 93 84 00 	sts	0x0084, r24
	
	//setup and enable timer
	TCCR1A = (mode & 0x03);		//normal timer operation, no PWM, etc
 952:	81 81       	ldd	r24, Z+1	; 0x01
 954:	83 70       	andi	r24, 0x03	; 3
 956:	80 93 80 00 	sts	0x0080, r24
	//TCCR1B = ((mode & 0x0C)<<WGM12) | (prescalar << CS10);
	TCCR1C = 0x00;		//force output compare off	
 95a:	10 92 82 00 	sts	0x0082, r1
 95e:	08 95       	ret

00000960 <_ZN6TIMER15startEv>:
	//sei();
}

void	TIMER1::start(void)
{
	TCCR1B = ((mode & 0x0C)<<WGM12) | (prescalar << CS10);
 960:	fc 01       	movw	r30, r24
 962:	21 81       	ldd	r18, Z+1	; 0x01
 964:	2c 70       	andi	r18, 0x0C	; 12
 966:	22 0f       	add	r18, r18
 968:	22 0f       	add	r18, r18
 96a:	22 0f       	add	r18, r18
 96c:	90 81       	ld	r25, Z
 96e:	82 2f       	mov	r24, r18
 970:	89 2b       	or	r24, r25
 972:	80 93 81 00 	sts	0x0081, r24
 976:	08 95       	ret

00000978 <_ZN6TIMER117isCompareAFlagSetEv>:
	return ((TIFR1 & 1<<TOV1)? 1:0);
	//return ((EIFR & 1<< INTF0)?1:0);
}

uint8_t TIMER1::isCompareAFlagSet(){
	return ((TIFR1 & 1<<OCF1A)? 1:0);
 978:	86 b3       	in	r24, 0x16	; 22
	
}
 97a:	86 95       	lsr	r24
 97c:	81 70       	andi	r24, 0x01	; 1
 97e:	08 95       	ret

00000980 <_ZN6TIMER117clearCompareAFlagEv>:
	
	//EIFR = (1<<INTF0);		//Reset flag
}

void	TIMER1::clearCompareAFlag(){
	TIFR1 |= (1<<OCF1A);
 980:	b1 9a       	sbi	0x16, 1	; 22
 982:	08 95       	ret

00000984 <_ZN6TIMER18setCountEj>:
	
	//EIFR = (1<<INTF0);		//Reset flag
}

void	TIMER1::setCount(uint16_t count){
	TCNT1 = count;
 984:	70 93 85 00 	sts	0x0085, r23
 988:	60 93 84 00 	sts	0x0084, r22
 98c:	08 95       	ret

0000098e <main>:
#define HEART_RATE_DATA_LENGTH 2

void SetSleepMode(uint8_t mode);
void init(void);

int main(void){	
 98e:	cf 93       	push	r28
 990:	df 93       	push	r29
 992:	cd b7       	in	r28, 0x3d	; 61
 994:	de b7       	in	r29, 0x3e	; 62
 996:	2d 97       	sbiw	r28, 0x0d	; 13
 998:	0f b6       	in	r0, 0x3f	; 63
 99a:	f8 94       	cli
 99c:	de bf       	out	0x3e, r29	; 62
 99e:	0f be       	out	0x3f, r0	; 63
 9a0:	cd bf       	out	0x3d, r28	; 61
	//timer
	// 8MHz/90Hz			= 88,888.8888 cycles to count
	// 88,888.888 / 8 (div8)	= 11,111 = 0x2B67
	
	//prescalar, mode, reload
	TIMER1 timer(TIMER_DIV8, 4, 0x2B67);
 9a2:	27 e6       	ldi	r18, 0x67	; 103
 9a4:	3b e2       	ldi	r19, 0x2B	; 43
 9a6:	44 e0       	ldi	r20, 0x04	; 4
 9a8:	62 e0       	ldi	r22, 0x02	; 2
 9aa:	ce 01       	movw	r24, r28
 9ac:	08 96       	adiw	r24, 0x08	; 8
 9ae:	0e 94 7e 04 	call	0x8fc	; 0x8fc <_ZN6TIMER1C1Ehhj>
	
	//pin, prescalar
	ANALOG sensor(ADC_PIN, ADC_DIV64);
 9b2:	46 e0       	ldi	r20, 0x06	; 6
 9b4:	60 e0       	ldi	r22, 0x00	; 0
 9b6:	ce 01       	movw	r24, r28
 9b8:	0c 96       	adiw	r24, 0x0c	; 12
 9ba:	0e 94 b0 00 	call	0x160	; 0x160 <_ZN6ANALOGC1Ehh>
		
	uint8_t count = 0;
		 
	state_t state = INIT;
	//uint8_t heartRateData[HEART_RATE_DATA_LENGTH];
	uint8_t oxygenSaturationData[PIPE_OXYGEN_SATURATION_O2_SET_MAX_SIZE] = {0,1,2,3,4,5,6};
 9be:	87 e0       	ldi	r24, 0x07	; 7
 9c0:	e0 e0       	ldi	r30, 0x00	; 0
 9c2:	f1 e0       	ldi	r31, 0x01	; 1
 9c4:	de 01       	movw	r26, r28
 9c6:	11 96       	adiw	r26, 0x01	; 1
 9c8:	01 90       	ld	r0, Z+
 9ca:	0d 92       	st	X+, r0
 9cc:	8a 95       	dec	r24
 9ce:	e1 f7       	brne	.-8      	; 0x9c8 <main+0x3a>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 9d0:	2f ef       	ldi	r18, 0xFF	; 255
 9d2:	84 e3       	ldi	r24, 0x34	; 52
 9d4:	9c e0       	ldi	r25, 0x0C	; 12
 9d6:	21 50       	subi	r18, 0x01	; 1
 9d8:	80 40       	sbci	r24, 0x00	; 0
 9da:	90 40       	sbci	r25, 0x00	; 0
 9dc:	e1 f7       	brne	.-8      	; 0x9d6 <main+0x48>
 9de:	00 c0       	rjmp	.+0      	; 0x9e0 <main+0x52>
 9e0:	00 00       	nop
#endif
	
	_delay_ms(500);
	
	//d6,d7 - LEDs
	DDRD = 0xC0;			//set PD7:6 to outputs for LEDs
 9e2:	80 ec       	ldi	r24, 0xC0	; 192
 9e4:	8a b9       	out	0x0a, r24	; 10
	//PD2 as an input for switch
	RED_ON;					//Set PD7 high and PD6 low
 9e6:	8b b1       	in	r24, 0x0b	; 11
 9e8:	8f 73       	andi	r24, 0x3F	; 63
 9ea:	80 68       	ori	r24, 0x80	; 128
 9ec:	8b b9       	out	0x0b, r24	; 11
	
	//Switch
	PORTD |= (1<<PD2);		//set PD2 to high(pullup resistor) for switch
 9ee:	5a 9a       	sbi	0x0b, 2	; 11
	
	//opamp is Powered Down when PD is low, initialize HIGH?
	//250nS delay when powering up, 50nS delay when powering down (1/8MHz = 125nS)
	WakeOpAmp();
 9f0:	41 9a       	sbi	0x08, 1	; 8
	sensor.clearFlag();
 9f2:	ce 01       	movw	r24, r28
 9f4:	0c 96       	adiw	r24, 0x0c	; 12
 9f6:	0e 94 c5 00 	call	0x18a	; 0x18a <_ZN6ANALOG9clearFlagEv>
 9fa:	ef ef       	ldi	r30, 0xFF	; 255
 9fc:	f4 e3       	ldi	r31, 0x34	; 52
 9fe:	2c e0       	ldi	r18, 0x0C	; 12
 a00:	e1 50       	subi	r30, 0x01	; 1
 a02:	f0 40       	sbci	r31, 0x00	; 0
 a04:	20 40       	sbci	r18, 0x00	; 0
 a06:	e1 f7       	brne	.-8      	; 0xa00 <main+0x72>
 a08:	00 c0       	rjmp	.+0      	; 0xa0a <main+0x7c>
 a0a:	00 00       	nop
		 
	enum lights_t {I,R,O} led_state = R;
		
	uint8_t count = 0;
		 
	state_t state = INIT;
 a0c:	b1 2c       	mov	r11, r1
	//pin, prescalar
	ANALOG sensor(ADC_PIN, ADC_DIV64);
	
	enum state_t {INIT = 0x00, RESET, CONNECT, CONNECTING, SEND, RECEIVE, IDLE};
		 
	enum lights_t {I,R,O} led_state = R;
 a0e:	66 24       	eor	r6, r6
 a10:	63 94       	inc	r6
				settings = nrf.data[1];				
			}
			nrf.dataHasBeenProcessed();
		}
		
		if (nrf.mode == NRF_MODE_STANDBY){
 a12:	0d ee       	ldi	r16, 0xED	; 237
 a14:	13 e0       	ldi	r17, 0x03	; 3
					state = IDLE;
					break;				
																
				case IDLE:		//idle
					if(!nrf.isConnected()){
						state = CONNECT;
 a16:	68 94       	set
 a18:	aa 24       	eor	r10, r10
 a1a:	a1 f8       	bld	r10, 1
									oxygenSaturationData[5] = ADCH;
									RED_ON;
									led_state = R;
									break;
								case R:
									oxygenSaturationData[2] = ADCL;
 a1c:	0f 2e       	mov	r0, r31
 a1e:	f8 e7       	ldi	r31, 0x78	; 120
 a20:	cf 2e       	mov	r12, r31
 a22:	d1 2c       	mov	r13, r1
 a24:	f0 2d       	mov	r31, r0
									oxygenSaturationData[1] = ADCH;
 a26:	0f 2e       	mov	r0, r31
 a28:	f9 e7       	ldi	r31, 0x79	; 121
 a2a:	ef 2e       	mov	r14, r31
 a2c:	f1 2c       	mov	r15, r1
 a2e:	f0 2d       	mov	r31, r0
									IR_ON;
									led_state = I;
									state = SEND;
 a30:	68 94       	set
 a32:	44 24       	eor	r4, r4
 a34:	42 f8       	bld	r4, 2
									break;
								case R:
									oxygenSaturationData[2] = ADCL;
									oxygenSaturationData[1] = ADCH;
									IR_ON;
									led_state = I;
 a36:	51 2c       	mov	r5, r1
									break;
								case O:
									oxygenSaturationData[6] = ADCL;
									oxygenSaturationData[5] = ADCH;
									RED_ON;
									led_state = R;
 a38:	88 24       	eor	r8, r8
 a3a:	83 94       	inc	r8
					}					
					break;
				
				case RECEIVE:
					nrf.requestData(PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX);
					state = IDLE;
 a3c:	0f 2e       	mov	r0, r31
 a3e:	f6 e0       	ldi	r31, 0x06	; 6
 a40:	9f 2e       	mov	r9, r31
 a42:	f0 2d       	mov	r31, r0
						//state = IDLE;
					break;
					
				case CONNECT:	//connect
					if (nrf.connect(180,0x0100) == 0x00)
						state = CONNECTING;
 a44:	0f 2e       	mov	r0, r31
 a46:	f3 e0       	ldi	r31, 0x03	; 3
 a48:	7f 2e       	mov	r7, r31
 a4a:	f0 2d       	mov	r31, r0
	lcdClearDisplay();
#endif	
	
	while(1)
	{
		if (nrf.hasDataToProcess()){
 a4c:	8c e7       	ldi	r24, 0x7C	; 124
 a4e:	93 e0       	ldi	r25, 0x03	; 3
 a50:	0e 94 0e 01 	call	0x21c	; 0x21c <_ZN3NRF16hasDataToProcessEv>
 a54:	88 23       	and	r24, r24
 a56:	21 f0       	breq	.+8      	; 0xa60 <main+0xd2>
			if (nrf.data[0] == PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX){
				settings = nrf.data[1];				
			}
			nrf.dataHasBeenProcessed();
 a58:	8c e7       	ldi	r24, 0x7C	; 124
 a5a:	93 e0       	ldi	r25, 0x03	; 3
 a5c:	0e 94 14 01 	call	0x228	; 0x228 <_ZN3NRF20dataHasBeenProcessedEv>
		}
		
		if (nrf.mode == NRF_MODE_STANDBY){
 a60:	f8 01       	movw	r30, r16
 a62:	80 81       	ld	r24, Z
 a64:	83 30       	cpi	r24, 0x03	; 3
 a66:	09 f0       	breq	.+2      	; 0xa6a <main+0xdc>
 a68:	9d c0       	rjmp	.+314    	; 0xba4 <main+0x216>
			
			
			
			switch (state){
 a6a:	8b 2d       	mov	r24, r11
 a6c:	90 e0       	ldi	r25, 0x00	; 0
 a6e:	87 30       	cpi	r24, 0x07	; 7
 a70:	91 05       	cpc	r25, r1
 a72:	08 f0       	brcs	.+2      	; 0xa76 <main+0xe8>
 a74:	97 c0       	rjmp	.+302    	; 0xba4 <main+0x216>
 a76:	fc 01       	movw	r30, r24
 a78:	ef 59       	subi	r30, 0x9F	; 159
 a7a:	ff 4f       	sbci	r31, 0xFF	; 255
 a7c:	0c 94 e6 05 	jmp	0xbcc	; 0xbcc <__tablejump2__>
				case INIT:	//initializing
					if (!nrf.isInitializing()){
 a80:	8c e7       	ldi	r24, 0x7C	; 124
 a82:	93 e0       	ldi	r25, 0x03	; 3
 a84:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <_ZN3NRF14isInitializingEv>
 a88:	81 11       	cpse	r24, r1
 a8a:	8c c0       	rjmp	.+280    	; 0xba4 <main+0x216>
						timer.start();
 a8c:	ce 01       	movw	r24, r28
 a8e:	08 96       	adiw	r24, 0x08	; 8
 a90:	0e 94 b0 04 	call	0x960	; 0x960 <_ZN6TIMER15startEv>
						state = CONNECT;						
 a94:	ba 2c       	mov	r11, r10
 a96:	86 c0       	rjmp	.+268    	; 0xba4 <main+0x216>
					//_delay_ms(25);
#endif
					break;
				case RESET:	//temp
					//TODO:
					nrf.radioReset();
 a98:	8c e7       	ldi	r24, 0x7C	; 124
 a9a:	93 e0       	ldi	r25, 0x03	; 3
 a9c:	0e 94 3d 02 	call	0x47a	; 0x47a <_ZN3NRF10radioResetEv>
						//state = IDLE;
					break;
 aa0:	81 c0       	rjmp	.+258    	; 0xba4 <main+0x216>
					
				case CONNECT:	//connect
					if (nrf.connect(180,0x0100) == 0x00)
 aa2:	40 e0       	ldi	r20, 0x00	; 0
 aa4:	51 e0       	ldi	r21, 0x01	; 1
 aa6:	64 eb       	ldi	r22, 0xB4	; 180
 aa8:	70 e0       	ldi	r23, 0x00	; 0
 aaa:	8c e7       	ldi	r24, 0x7C	; 124
 aac:	93 e0       	ldi	r25, 0x03	; 3
 aae:	0e 94 41 02 	call	0x482	; 0x482 <_ZN3NRF7connectEjj>
 ab2:	88 23       	and	r24, r24
 ab4:	09 f4       	brne	.+2      	; 0xab8 <main+0x12a>
 ab6:	71 c0       	rjmp	.+226    	; 0xb9a <main+0x20c>
 ab8:	75 c0       	rjmp	.+234    	; 0xba4 <main+0x216>
						state = CONNECTING;
					break;				
				
				case CONNECTING:	
					if (nrf.isConnected())
 aba:	8c e7       	ldi	r24, 0x7C	; 124
 abc:	93 e0       	ldi	r25, 0x03	; 3
 abe:	0e 94 08 01 	call	0x210	; 0x210 <_ZN3NRF11isConnectedEv>
 ac2:	81 11       	cpse	r24, r1
 ac4:	6c c0       	rjmp	.+216    	; 0xb9e <main+0x210>
 ac6:	6e c0       	rjmp	.+220    	; 0xba4 <main+0x216>
						state = IDLE;
					break;
					
				case SEND:					
					if (0x00 == nrf.setLocalData(PIPE_OXYGEN_SATURATION_O2_SET, oxygenSaturationData, PIPE_OXYGEN_SATURATION_O2_SET_MAX_SIZE)){						
 ac8:	27 e0       	ldi	r18, 0x07	; 7
 aca:	ae 01       	movw	r20, r28
 acc:	4f 5f       	subi	r20, 0xFF	; 255
 ace:	5f 4f       	sbci	r21, 0xFF	; 255
 ad0:	68 2d       	mov	r22, r8
 ad2:	8c e7       	ldi	r24, 0x7C	; 124
 ad4:	93 e0       	ldi	r25, 0x03	; 3
 ad6:	0e 94 01 02 	call	0x402	; 0x402 <_ZN3NRF12setLocalDataEhPhh>
 ada:	81 11       	cpse	r24, r1
 adc:	63 c0       	rjmp	.+198    	; 0xba4 <main+0x216>
						oxygenSaturationData[0]++;						
 ade:	89 81       	ldd	r24, Y+1	; 0x01
 ae0:	8f 5f       	subi	r24, 0xFF	; 255
 ae2:	89 83       	std	Y+1, r24	; 0x01
						
						state = IDLE;	
 ae4:	b9 2c       	mov	r11, r9
 ae6:	5e c0       	rjmp	.+188    	; 0xba4 <main+0x216>
					}					
					break;
				
				case RECEIVE:
					nrf.requestData(PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX);
 ae8:	6a 2d       	mov	r22, r10
 aea:	8c e7       	ldi	r24, 0x7C	; 124
 aec:	93 e0       	ldi	r25, 0x03	; 3
 aee:	0e 94 90 01 	call	0x320	; 0x320 <_ZN3NRF11requestDataEh>
					state = IDLE;
 af2:	b9 2c       	mov	r11, r9
					break;				
 af4:	57 c0       	rjmp	.+174    	; 0xba4 <main+0x216>
																
				case IDLE:		//idle
					if(!nrf.isConnected()){
 af6:	8c e7       	ldi	r24, 0x7C	; 124
 af8:	93 e0       	ldi	r25, 0x03	; 3
 afa:	0e 94 08 01 	call	0x210	; 0x210 <_ZN3NRF11isConnectedEv>
 afe:	88 23       	and	r24, r24
 b00:	09 f4       	brne	.+2      	; 0xb04 <main+0x176>
 b02:	4f c0       	rjmp	.+158    	; 0xba2 <main+0x214>
					
					
						
					
					else {
						if (timer.isCompareAFlagSet()){
 b04:	ce 01       	movw	r24, r28
 b06:	08 96       	adiw	r24, 0x08	; 8
 b08:	0e 94 bc 04 	call	0x978	; 0x978 <_ZN6TIMER117isCompareAFlagSetEv>
 b0c:	88 23       	and	r24, r24
 b0e:	71 f0       	breq	.+28     	; 0xb2c <main+0x19e>
							timer.clearCompareAFlag();
 b10:	ce 01       	movw	r24, r28
 b12:	08 96       	adiw	r24, 0x08	; 8
 b14:	0e 94 c0 04 	call	0x980	; 0x980 <_ZN6TIMER117clearCompareAFlagEv>
							timer.setCount(0);
 b18:	60 e0       	ldi	r22, 0x00	; 0
 b1a:	70 e0       	ldi	r23, 0x00	; 0
 b1c:	ce 01       	movw	r24, r28
 b1e:	08 96       	adiw	r24, 0x08	; 8
 b20:	0e 94 c2 04 	call	0x984	; 0x984 <_ZN6TIMER18setCountEj>
						
 							sensor.start();
 b24:	ce 01       	movw	r24, r28
 b26:	0c 96       	adiw	r24, 0x0c	; 12
 b28:	0e 94 b6 00 	call	0x16c	; 0x16c <_ZN6ANALOG5startEv>
 						
 						}//if
 					
 						
						if (sensor.isInterruptFlagSet()){
 b2c:	ce 01       	movw	r24, r28
 b2e:	0c 96       	adiw	r24, 0x0c	; 12
 b30:	0e 94 c1 00 	call	0x182	; 0x182 <_ZN6ANALOG18isInterruptFlagSetEv>
 b34:	88 23       	and	r24, r24
 b36:	b1 f1       	breq	.+108    	; 0xba4 <main+0x216>
							
							sensor.clearFlag();
 b38:	ce 01       	movw	r24, r28
 b3a:	0c 96       	adiw	r24, 0x0c	; 12
 b3c:	0e 94 c5 00 	call	0x18a	; 0x18a <_ZN6ANALOG9clearFlagEv>
							switch (led_state){
 b40:	f1 e0       	ldi	r31, 0x01	; 1
 b42:	6f 16       	cp	r6, r31
 b44:	e9 f0       	breq	.+58     	; 0xb80 <main+0x1f2>
 b46:	6f 16       	cp	r6, r31
 b48:	20 f0       	brcs	.+8      	; 0xb52 <main+0x1c4>
 b4a:	22 e0       	ldi	r18, 0x02	; 2
 b4c:	62 16       	cp	r6, r18
 b4e:	61 f0       	breq	.+24     	; 0xb68 <main+0x1da>
 b50:	29 c0       	rjmp	.+82     	; 0xba4 <main+0x216>
								case I:
									oxygenSaturationData[4] = ADCL;
 b52:	f6 01       	movw	r30, r12
 b54:	80 81       	ld	r24, Z
 b56:	8d 83       	std	Y+5, r24	; 0x05
									oxygenSaturationData[3] = ADCH;
 b58:	f7 01       	movw	r30, r14
 b5a:	80 81       	ld	r24, Z
 b5c:	8c 83       	std	Y+4, r24	; 0x04
									LEDS_OFF;
 b5e:	8b b1       	in	r24, 0x0b	; 11
 b60:	8f 73       	andi	r24, 0x3F	; 63
 b62:	8b b9       	out	0x0b, r24	; 11
									led_state = O;
 b64:	6a 2c       	mov	r6, r10
									break;
 b66:	1e c0       	rjmp	.+60     	; 0xba4 <main+0x216>
								case O:
									oxygenSaturationData[6] = ADCL;
 b68:	f6 01       	movw	r30, r12
 b6a:	80 81       	ld	r24, Z
 b6c:	8f 83       	std	Y+7, r24	; 0x07
									oxygenSaturationData[5] = ADCH;
 b6e:	f7 01       	movw	r30, r14
 b70:	80 81       	ld	r24, Z
 b72:	8e 83       	std	Y+6, r24	; 0x06
									RED_ON;
 b74:	8b b1       	in	r24, 0x0b	; 11
 b76:	8f 73       	andi	r24, 0x3F	; 63
 b78:	80 68       	ori	r24, 0x80	; 128
 b7a:	8b b9       	out	0x0b, r24	; 11
									led_state = R;
 b7c:	68 2c       	mov	r6, r8
									break;
 b7e:	12 c0       	rjmp	.+36     	; 0xba4 <main+0x216>
								case R:
									oxygenSaturationData[2] = ADCL;
 b80:	f6 01       	movw	r30, r12
 b82:	80 81       	ld	r24, Z
 b84:	8b 83       	std	Y+3, r24	; 0x03
									oxygenSaturationData[1] = ADCH;
 b86:	f7 01       	movw	r30, r14
 b88:	80 81       	ld	r24, Z
 b8a:	8a 83       	std	Y+2, r24	; 0x02
									IR_ON;
 b8c:	8b b1       	in	r24, 0x0b	; 11
 b8e:	8f 73       	andi	r24, 0x3F	; 63
 b90:	80 64       	ori	r24, 0x40	; 64
 b92:	8b b9       	out	0x0b, r24	; 11
									led_state = I;
									state = SEND;
 b94:	b4 2c       	mov	r11, r4
									break;
								case R:
									oxygenSaturationData[2] = ADCL;
									oxygenSaturationData[1] = ADCH;
									IR_ON;
									led_state = I;
 b96:	65 2c       	mov	r6, r5
									state = SEND;
									break;
 b98:	05 c0       	rjmp	.+10     	; 0xba4 <main+0x216>
						//state = IDLE;
					break;
					
				case CONNECT:	//connect
					if (nrf.connect(180,0x0100) == 0x00)
						state = CONNECTING;
 b9a:	b7 2c       	mov	r11, r7
 b9c:	03 c0       	rjmp	.+6      	; 0xba4 <main+0x216>
					break;				
				
				case CONNECTING:	
					if (nrf.isConnected())
						state = IDLE;
 b9e:	b9 2c       	mov	r11, r9
 ba0:	01 c0       	rjmp	.+2      	; 0xba4 <main+0x216>
					state = IDLE;
					break;				
																
				case IDLE:		//idle
					if(!nrf.isConnected()){
						state = CONNECT;
 ba2:	ba 2c       	mov	r11, r10
		//display
		//sprintf(line1, " %02X%02X %02X %02X%02X ", nrf.RxCount, nrf.dataCredit, state, nrf.status, nrf.mode);
		sprintf(line2, "%02X%02X %02X %02X%02X ", nrf.RxCount, /*nrf.dataCredit,*/ state, nrf.status, nrf.mode, nrf.lastCommand);
		displayLCD();
#else
		if (nrf.mode == NRF_MODE_SETUP)
 ba4:	f8 01       	movw	r30, r16
 ba6:	80 81       	ld	r24, Z
 ba8:	82 30       	cpi	r24, 0x02	; 2
 baa:	31 f4       	brne	.+12     	; 0xbb8 <main+0x22a>
 bac:	8f e2       	ldi	r24, 0x2F	; 47
 bae:	95 e7       	ldi	r25, 0x75	; 117
 bb0:	01 97       	sbiw	r24, 0x01	; 1
 bb2:	f1 f7       	brne	.-4      	; 0xbb0 <main+0x222>
 bb4:	00 c0       	rjmp	.+0      	; 0xbb6 <main+0x228>
 bb6:	00 00       	nop
			_delay_ms(15);
#endif			

		nrf.process();
 bb8:	8c e7       	ldi	r24, 0x7C	; 124
 bba:	93 e0       	ldi	r25, 0x03	; 3
 bbc:	0e 94 7f 03 	call	0x6fe	; 0x6fe <_ZN3NRF7processEv>
		
	}//while 1
 bc0:	45 cf       	rjmp	.-374    	; 0xa4c <main+0xbe>

00000bc2 <_GLOBAL__sub_I_nrf>:



//#include "hal_aci_tl.h"

NRF nrf;
 bc2:	8c e7       	ldi	r24, 0x7C	; 124
 bc4:	93 e0       	ldi	r25, 0x03	; 3
 bc6:	0e 94 28 01 	call	0x250	; 0x250 <_ZN3NRFC1Ev>
 bca:	08 95       	ret

00000bcc <__tablejump2__>:
 bcc:	ee 0f       	add	r30, r30
 bce:	ff 1f       	adc	r31, r31

00000bd0 <__tablejump__>:
 bd0:	05 90       	lpm	r0, Z+
 bd2:	f4 91       	lpm	r31, Z
 bd4:	e0 2d       	mov	r30, r0
 bd6:	09 94       	ijmp

00000bd8 <_exit>:
 bd8:	f8 94       	cli

00000bda <__stop_program>:
 bda:	ff cf       	rjmp	.-2      	; 0xbda <__stop_program>
