
SeniorProjectPulseOx.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000274  00800100  00000d74  00000e08  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000d74  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000077  00800374  00800374  0000107c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000107c  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000328  00000000  00000000  000010ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00004297  00000000  00000000  000013d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000b49  00000000  00000000  0000566b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000d18  00000000  00000000  000061b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000007ec  00000000  00000000  00006ecc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000013b9  00000000  00000000  000076b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000025e5  00000000  00000000  00008a71  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000308  00000000  00000000  0000b056  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 6c 00 	jmp	0xd8	; 0xd8 <__ctors_end>
   4:	0c 94 94 06 	jmp	0xd28	; 0xd28 <__vector_1>
   8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
   c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  10:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  14:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  18:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  1c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  20:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  24:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  28:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  2c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  30:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  34:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  38:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  3c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  40:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  44:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  48:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  4c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  50:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  54:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  58:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  5c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  60:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  64:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  68:	36 03       	mulsu	r19, r22
  6a:	3a 03       	fmul	r19, r18
  6c:	3e 03       	fmul	r19, r22
  6e:	42 03       	mulsu	r20, r18
  70:	46 03       	mulsu	r20, r22
  72:	4a 03       	fmul	r20, r18
  74:	54 03       	mulsu	r21, r20
  76:	58 03       	fmul	r21, r16
  78:	5c 03       	fmul	r21, r20
  7a:	64 03       	mulsu	r22, r20
  7c:	68 03       	fmul	r22, r16
  7e:	6c 03       	fmul	r22, r20
  80:	9e 03       	fmulsu	r17, r22
  82:	7f 03       	fmul	r23, r23
  84:	9e 03       	fmulsu	r17, r22
  86:	9e 03       	fmulsu	r17, r22
  88:	9e 03       	fmulsu	r17, r22
  8a:	83 03       	fmuls	r16, r19
  8c:	9e 03       	fmulsu	r17, r22
  8e:	9e 03       	fmulsu	r17, r22
  90:	9e 03       	fmulsu	r17, r22
  92:	9e 03       	fmulsu	r17, r22
  94:	9e 03       	fmulsu	r17, r22
  96:	9e 03       	fmulsu	r17, r22
  98:	87 03       	fmuls	r16, r23
  9a:	8b 03       	fmulsu	r16, r19
  9c:	8f 03       	fmulsu	r16, r23
  9e:	93 03       	fmuls	r17, r19
  a0:	97 03       	fmuls	r17, r23
  a2:	9b 03       	fmulsu	r17, r19
  a4:	f6 03       	fmuls	r23, r22
  a6:	17 04       	cpc	r1, r7
  a8:	22 04       	cpc	r2, r2
  aa:	25 04       	cpc	r2, r5
  ac:	29 04       	cpc	r2, r9
  ae:	2e 04       	cpc	r2, r14
  b0:	31 04       	cpc	r3, r1
  b2:	3a 04       	cpc	r3, r10
  b4:	4d 04       	cpc	r4, r13
  b6:	56 04       	cpc	r5, r6
  b8:	77 04       	cpc	r7, r7
  ba:	ec 03       	fmulsu	r22, r20
  bc:	73 04       	cpc	r7, r3
  be:	50 04       	cpc	r5, r0
  c0:	53 04       	cpc	r5, r3
  c2:	89 05       	cpc	r24, r9
  c4:	9c 05       	cpc	r25, r12
  c6:	ad 05       	cpc	r26, r13
  c8:	b4 05       	cpc	r27, r4
  ca:	c7 05       	cpc	r28, r7
  cc:	d1 05       	cpc	r29, r1
  ce:	1e 06       	cpc	r1, r30
  d0:	51 06       	cpc	r5, r17
  d2:	63 06       	cpc	r6, r19

000000d4 <__ctors_start>:
  d4:	9f 04       	cpc	r9, r15
  d6:	ad 06       	cpc	r10, r29

000000d8 <__ctors_end>:
  d8:	11 24       	eor	r1, r1
  da:	1f be       	out	0x3f, r1	; 63
  dc:	cf ef       	ldi	r28, 0xFF	; 255
  de:	d8 e0       	ldi	r29, 0x08	; 8
  e0:	de bf       	out	0x3e, r29	; 62
  e2:	cd bf       	out	0x3d, r28	; 61

000000e4 <__do_copy_data>:
  e4:	13 e0       	ldi	r17, 0x03	; 3
  e6:	a0 e0       	ldi	r26, 0x00	; 0
  e8:	b1 e0       	ldi	r27, 0x01	; 1
  ea:	e4 e7       	ldi	r30, 0x74	; 116
  ec:	fd e0       	ldi	r31, 0x0D	; 13
  ee:	02 c0       	rjmp	.+4      	; 0xf4 <__do_copy_data+0x10>
  f0:	05 90       	lpm	r0, Z+
  f2:	0d 92       	st	X+, r0
  f4:	a4 37       	cpi	r26, 0x74	; 116
  f6:	b1 07       	cpc	r27, r17
  f8:	d9 f7       	brne	.-10     	; 0xf0 <__do_copy_data+0xc>

000000fa <__do_clear_bss>:
  fa:	23 e0       	ldi	r18, 0x03	; 3
  fc:	a4 e7       	ldi	r26, 0x74	; 116
  fe:	b3 e0       	ldi	r27, 0x03	; 3
 100:	01 c0       	rjmp	.+2      	; 0x104 <.do_clear_bss_start>

00000102 <.do_clear_bss_loop>:
 102:	1d 92       	st	X+, r1

00000104 <.do_clear_bss_start>:
 104:	ab 3e       	cpi	r26, 0xEB	; 235
 106:	b2 07       	cpc	r27, r18
 108:	e1 f7       	brne	.-8      	; 0x102 <.do_clear_bss_loop>

0000010a <__do_global_ctors>:
 10a:	10 e0       	ldi	r17, 0x00	; 0
 10c:	c8 ed       	ldi	r28, 0xD8	; 216
 10e:	d0 e0       	ldi	r29, 0x00	; 0
 110:	04 c0       	rjmp	.+8      	; 0x11a <__do_global_ctors+0x10>
 112:	22 97       	sbiw	r28, 0x02	; 2
 114:	fe 01       	movw	r30, r28
 116:	0e 94 b4 06 	call	0xd68	; 0xd68 <__tablejump__>
 11a:	c4 3d       	cpi	r28, 0xD4	; 212
 11c:	d1 07       	cpc	r29, r17
 11e:	c9 f7       	brne	.-14     	; 0x112 <__do_global_ctors+0x8>
 120:	0e 94 ee 04 	call	0x9dc	; 0x9dc <main>
 124:	0c 94 b8 06 	jmp	0xd70	; 0xd70 <_exit>

00000128 <__bad_interrupt>:
 128:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012c <_ZN6ANALOG12reinitializeEv>:
	
}

void ANALOG::reinitialize(){
	//Power reduction ADC bit must be zero to enable ADC
	PRR &= ~(1<<PRADC);
 12c:	e4 e6       	ldi	r30, 0x64	; 100
 12e:	f0 e0       	ldi	r31, 0x00	; 0
 130:	20 81       	ld	r18, Z
 132:	2e 7f       	andi	r18, 0xFE	; 254
 134:	20 83       	st	Z, r18
	
	
	//ADC clock needs to be between 50kHz and 200kHz
	//8MHz/64 = 125kHz
	ADCSRA = (1<<ADEN | prescalar<<ADPS0);
 136:	dc 01       	movw	r26, r24
 138:	11 96       	adiw	r26, 0x01	; 1
 13a:	2c 91       	ld	r18, X
 13c:	11 97       	sbiw	r26, 0x01	; 1
 13e:	20 68       	ori	r18, 0x80	; 128
 140:	20 93 7a 00 	sts	0x007A, r18
	
	//Disable the digital input for the ADC channel we will be using
	DIDR0 |= (1<<channel);
 144:	ee e7       	ldi	r30, 0x7E	; 126
 146:	f0 e0       	ldi	r31, 0x00	; 0
 148:	40 81       	ld	r20, Z
 14a:	21 e0       	ldi	r18, 0x01	; 1
 14c:	30 e0       	ldi	r19, 0x00	; 0
 14e:	b9 01       	movw	r22, r18
 150:	0c 90       	ld	r0, X
 152:	02 c0       	rjmp	.+4      	; 0x158 <_ZN6ANALOG12reinitializeEv+0x2c>
 154:	66 0f       	add	r22, r22
 156:	77 1f       	adc	r23, r23
 158:	0a 94       	dec	r0
 15a:	e2 f7       	brpl	.-8      	; 0x154 <_ZN6ANALOG12reinitializeEv+0x28>
 15c:	cb 01       	movw	r24, r22
 15e:	84 2b       	or	r24, r20
 160:	80 83       	st	Z, r24
 162:	08 95       	ret

00000164 <_ZN6ANALOGC1Ehh>:
	reinitialize();
}

//@brief initialize AD converter on Atmega168 for
ANALOG::ANALOG(uint8_t ch, uint8_t pscalar){
	channel = ch;
 164:	fc 01       	movw	r30, r24
 166:	60 83       	st	Z, r22
	prescalar = pscalar;
 168:	41 83       	std	Z+1, r20	; 0x01
	reinitialize();
 16a:	0e 94 96 00 	call	0x12c	; 0x12c <_ZN6ANALOG12reinitializeEv>
 16e:	08 95       	ret

00000170 <_ZN6ANALOG5startEv>:
	return (ADC);
}

void ANALOG::start(){
	//set ADC channel
	ADMUX = (1<<REFS0) | channel;
 170:	fc 01       	movw	r30, r24
 172:	80 81       	ld	r24, Z
 174:	80 64       	ori	r24, 0x40	; 64
 176:	80 93 7c 00 	sts	0x007C, r24
	
	//start conversion
	ADCSRA |= (1<<ADSC);
 17a:	ea e7       	ldi	r30, 0x7A	; 122
 17c:	f0 e0       	ldi	r31, 0x00	; 0
 17e:	80 81       	ld	r24, Z
 180:	80 64       	ori	r24, 0x40	; 64
 182:	80 83       	st	Z, r24
 184:	08 95       	ret

00000186 <_ZN6ANALOG18isInterruptFlagSetEv>:
uint8_t ANALOG::isReading(){
	return (ADCSRA & (1<<ADSC));	
}

uint8_t	ANALOG::isInterruptFlagSet(){
	return(ADCSRA & (1<<ADIF));
 186:	80 91 7a 00 	lds	r24, 0x007A
}
 18a:	80 71       	andi	r24, 0x10	; 16
 18c:	08 95       	ret

0000018e <_ZN6ANALOG9clearFlagEv>:

void ANALOG::clearFlag(){
	//clear interrupt by setting ADIF to 1
	ADCSRA |= (1<<ADIF);
 18e:	ea e7       	ldi	r30, 0x7A	; 122
 190:	f0 e0       	ldi	r31, 0x00	; 0
 192:	80 81       	ld	r24, Z
 194:	80 61       	ori	r24, 0x10	; 16
 196:	80 83       	st	Z, r24
 198:	08 95       	ret

0000019a <_ZN3SPI4initEh>:
		init(SPCRvalue);
	}
	void SPI::init(uint8_t SPCRvalue)
	// Initialize pins for spi communication
	{
		DDR_SPI &= ~((1<<DD_MOSI)|(1<<DD_MISO)|(1<<DD_SS)|(1<<DD_SCK));
 19a:	84 b1       	in	r24, 0x04	; 4
 19c:	83 7c       	andi	r24, 0xC3	; 195
 19e:	84 b9       	out	0x04, r24	; 4
		// Define the following pins as output
		DDR_SPI |= ((1<<DD_MOSI)|(1<<DD_SS)|(1<<DD_SCK));
 1a0:	84 b1       	in	r24, 0x04	; 4
 1a2:	8c 62       	ori	r24, 0x2C	; 44
 1a4:	84 b9       	out	0x04, r24	; 4

		if (SPCRvalue == 0x00){
 1a6:	61 11       	cpse	r22, r1
 1a8:	03 c0       	rjmp	.+6      	; 0x1b0 <_ZN3SPI4initEh+0x16>
			(0<<SPIE)|              // SPI Interrupt Enable
			(0<<DORD)|              // Data Order (0:MSB first / 1:LSB first)
			(1<<MSTR)|              // Master/Slave select
			(0<<SPR1)|(1<<SPR0)|    // SPI Clock Rate
			(0<<CPOL)|              // Clock Polarity (0:SCK low / 1:SCK hi when idle)
			(0<<CPHA));             // Clock Phase (0:leading / 1:trailing edge sampling)
 1aa:	81 e5       	ldi	r24, 0x51	; 81
 1ac:	8c bd       	out	0x2c, r24	; 44
 1ae:	08 95       	ret
		}
		else SPCR = SPCRvalue;
 1b0:	6c bd       	out	0x2c, r22	; 44
 1b2:	08 95       	ret

000001b4 <_ZN3SPIC1Eh>:
	
	SPI::SPI(){
		init(0x00);
	}
	SPI::SPI(uint8_t SPCRvalue){
		init(SPCRvalue);
 1b4:	0e 94 cd 00 	call	0x19a	; 0x19a <_ZN3SPI4initEh>
 1b8:	08 95       	ret

000001ba <_ZN3SPI8transferEPhS0_h>:
	
	void SPI::transfer (uint8_t * dataout, uint8_t * datain, uint8_t length)
	// Shift full array through target device
	{
		uint8_t i;
		for (i = 0; i < length; i++) {
 1ba:	22 23       	and	r18, r18
 1bc:	81 f0       	breq	.+32     	; 0x1de <_ZN3SPI8transferEPhS0_h+0x24>
 1be:	96 2f       	mov	r25, r22
 1c0:	a4 2f       	mov	r26, r20
 1c2:	b5 2f       	mov	r27, r21
 1c4:	e6 2f       	mov	r30, r22
 1c6:	f7 2f       	mov	r31, r23
			SPDR = dataout[i];
 1c8:	81 91       	ld	r24, Z+
 1ca:	8e bd       	out	0x2e, r24	; 46
			while((SPSR & (1<<SPIF))==0);
 1cc:	0d b4       	in	r0, 0x2d	; 45
 1ce:	07 fe       	sbrs	r0, 7
 1d0:	fd cf       	rjmp	.-6      	; 0x1cc <_ZN3SPI8transferEPhS0_h+0x12>
			datain[i] = SPDR;
 1d2:	8e b5       	in	r24, 0x2e	; 46
 1d4:	8d 93       	st	X+, r24
 1d6:	8e 2f       	mov	r24, r30
 1d8:	89 1b       	sub	r24, r25
	
	void SPI::transfer (uint8_t * dataout, uint8_t * datain, uint8_t length)
	// Shift full array through target device
	{
		uint8_t i;
		for (i = 0; i < length; i++) {
 1da:	82 17       	cp	r24, r18
 1dc:	a8 f3       	brcs	.-22     	; 0x1c8 <_ZN3SPI8transferEPhS0_h+0xe>
 1de:	08 95       	ret

000001e0 <_ZN3SPI13transfer1byteEh>:
	}
	
	uint8_t SPI::transfer1byte (uint8_t dataout)
	// Clocks only one byte to target device and returns the received one
	{
		SPDR = dataout;
 1e0:	6e bd       	out	0x2e, r22	; 46
		while((SPSR & (1<<SPIF))==0);
 1e2:	0d b4       	in	r0, 0x2d	; 45
 1e4:	07 fe       	sbrs	r0, 7
 1e6:	fd cf       	rjmp	.-6      	; 0x1e2 <_ZN3SPI13transfer1byteEh+0x2>
		return SPDR;
 1e8:	8e b5       	in	r24, 0x2e	; 46
	}
 1ea:	08 95       	ret

000001ec <_ZN3NRF14isInitializingEv>:
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 1ec:	fc 01       	movw	r30, r24
 1ee:	ef 58       	subi	r30, 0x8F	; 143
 1f0:	ff 4f       	sbci	r31, 0xFF	; 255
 1f2:	81 e0       	ldi	r24, 0x01	; 1
 1f4:	90 81       	ld	r25, Z
 1f6:	92 30       	cpi	r25, 0x02	; 2
 1f8:	09 f0       	breq	.+2      	; 0x1fc <_ZN3NRF14isInitializingEv+0x10>
 1fa:	80 e0       	ldi	r24, 0x00	; 0
}
 1fc:	08 95       	ret

000001fe <_ZN3NRF13hasDataToSendEv>:
uint8_t NRF::hasDataToSend(void){
	return ((status & (1<<NRF_TX_READY))?TRUE:FALSE);
 1fe:	fc 01       	movw	r30, r24
 200:	82 8d       	ldd	r24, Z+26	; 0x1a
}
 202:	86 fb       	bst	r24, 6
 204:	88 27       	eor	r24, r24
 206:	80 f9       	bld	r24, 0
 208:	08 95       	ret

0000020a <_ZN3NRF18waitingForResponseEv>:
uint8_t NRF::isReadyToReceiveData(){
	return ((status & (1<<NRF_RX_READY))?TRUE:FALSE);
}
uint8_t NRF::waitingForResponse(void){
	return ((status & (1<<NRF_WAIT_FOR_RESPONSE))?TRUE:FALSE);
 20a:	fc 01       	movw	r30, r24
 20c:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
 20e:	82 95       	swap	r24
 210:	81 70       	andi	r24, 0x01	; 1
 212:	08 95       	ret

00000214 <_ZN3NRF11isConnectedEv>:
uint8_t NRF::isConnected(void){
	return ((status & (1<<NRF_CONNECTED))?TRUE:FALSE);
 214:	fc 01       	movw	r30, r24
 216:	82 8d       	ldd	r24, Z+26	; 0x1a
}	
 218:	83 fb       	bst	r24, 3
 21a:	88 27       	eor	r24, r24
 21c:	80 f9       	bld	r24, 0
 21e:	08 95       	ret

00000220 <_ZN3NRF16hasDataToProcessEv>:
uint8_t NRF::isBonded(void){
	return ((status & (1<<NRF_BONDED))?TRUE:FALSE);	
}
uint8_t NRF::hasDataToProcess(void){
	return ((status & (1<<NRF_DATA_TO_PROCESS))?TRUE:FALSE);
 220:	fc 01       	movw	r30, r24
 222:	82 8d       	ldd	r24, Z+26	; 0x1a
}
 224:	85 fb       	bst	r24, 5
 226:	88 27       	eor	r24, r24
 228:	80 f9       	bld	r24, 0
 22a:	08 95       	ret

0000022c <_ZN3NRF20dataHasBeenProcessedEv>:
void	NRF::dataHasBeenProcessed(void){
	status &= ~(1<<NRF_DATA_TO_PROCESS);
 22c:	fc 01       	movw	r30, r24
 22e:	22 8d       	ldd	r18, Z+26	; 0x1a
 230:	2f 7d       	andi	r18, 0xDF	; 223
 232:	22 8f       	std	Z+26, r18	; 0x1a
 234:	08 95       	ret

00000236 <_ZN3NRF10isSleepingEv>:
}
uint8_t NRF::isSleeping(void){
	return ((status & (1<<NRF_SLEEPING))?TRUE:FALSE);
 236:	fc 01       	movw	r30, r24
 238:	82 8d       	ldd	r24, Z+26	; 0x1a
}
 23a:	86 95       	lsr	r24
 23c:	81 70       	andi	r24, 0x01	; 1
 23e:	08 95       	ret

00000240 <_ZN3NRF15isSystemCommandEh>:
uint8_t	NRF::isSystemCommand(uint8_t command){
	return ((	command == NRF_CMD_SET_LOCAL_DATA	||
		command == NRF_CMD_SEND_DATA		||
		command == NRF_CMD_SEND_DATA_ACK	||
		command == NRF_CMD_REQUEST_DATA		||
		command == NRF_CMD_SEND_DATA_NACK	 )	? FALSE: TRUE);
 240:	6d 30       	cpi	r22, 0x0D	; 13
 242:	31 f0       	breq	.+12     	; 0x250 <_ZN3NRF15isSystemCommandEh+0x10>
}

#pragma endregion Status Functions

uint8_t	NRF::isSystemCommand(uint8_t command){
	return ((	command == NRF_CMD_SET_LOCAL_DATA	||
 244:	65 51       	subi	r22, 0x15	; 21
 246:	81 e0       	ldi	r24, 0x01	; 1
 248:	64 30       	cpi	r22, 0x04	; 4
 24a:	18 f4       	brcc	.+6      	; 0x252 <_ZN3NRF15isSystemCommandEh+0x12>
 24c:	80 e0       	ldi	r24, 0x00	; 0
 24e:	08 95       	ret
		command == NRF_CMD_SEND_DATA		||
		command == NRF_CMD_SEND_DATA_ACK	||
		command == NRF_CMD_REQUEST_DATA		||
		command == NRF_CMD_SEND_DATA_NACK	 )	? FALSE: TRUE);
 250:	80 e0       	ldi	r24, 0x00	; 0
}
 252:	08 95       	ret

00000254 <_ZN3NRF4initEv>:
}


void NRF::init(){
	//ACT and RDYN set as inputs	
	ACT_DDR &= ~(1<<ACT_PIN);	
 254:	20 98       	cbi	0x04, 0	; 4
	RDYN_DDR &= ~(1<<RDYN_PIN);
 256:	22 98       	cbi	0x04, 2	; 4
	
	//REQN set as output
	REQN_DDR |= (1<<REQN_PIN);
 258:	21 9a       	sbi	0x04, 1	; 4
	//////DON'T KNOW WHY THIS IS CAUSING A PROBLEM********************************************************
	//set pullup on RDYN
	//RDYN_PORT |= (1<<RDYN_PIN);
	
	//REQN is active low, so initialize it HIGH
	SetREQN();
 25a:	29 9a       	sbi	0x05, 1	; 5
 25c:	08 95       	ret

0000025e <_ZN3NRFC1Ev>:
SPI spi(SPI_SETTING);

static uint8_t initCount = 0;


NRF::NRF(){
 25e:	cf 93       	push	r28
 260:	df 93       	push	r29
 262:	ec 01       	movw	r28, r24
	
	init();
 264:	0e 94 2a 01 	call	0x254	; 0x254 <_ZN3NRF4initEv>
	RxCount = 0x00;
 268:	1d 8a       	std	Y+21, r1	; 0x15
	temperature = 0x00;
 26a:	1f 8a       	std	Y+23, r1	; 0x17
 26c:	1e 8a       	std	Y+22, r1	; 0x16
	
	//set to INIT_MODE and RX_READY
	//we are waiting for a NRF_EVT_DEVICE_STARTED in NRF_MODE_SETUP
	//status |= (1<<NRF_RX_READY | 1<<NRF_INIT_MODE | 1<<NRF_WAIT_FOR_RESPONSE);
	status |= (1<<NRF_RX_READY | 1<<NRF_WAIT_FOR_RESPONSE);
 26e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 270:	80 69       	ori	r24, 0x90	; 144
 272:	8a 8f       	std	Y+26, r24	; 0x1a
}
 274:	df 91       	pop	r29
 276:	cf 91       	pop	r28
 278:	08 95       	ret

0000027a <_ZN3NRF11clearTxDataEv>:
		}
		
	}//else if(RDYN == 0)	
	
}//transferACI()
void NRF::clearTxData(){
 27a:	fc 01       	movw	r30, r24
 27c:	fb 96       	adiw	r30, 0x3b	; 59
	for(int i = 0; i<32; i++) 
 27e:	20 e0       	ldi	r18, 0x00	; 0
 280:	30 e0       	ldi	r19, 0x00	; 0
		TxData[i] = 0x00;		
 282:	11 92       	st	Z+, r1
		
	}//else if(RDYN == 0)	
	
}//transferACI()
void NRF::clearTxData(){
	for(int i = 0; i<32; i++) 
 284:	2f 5f       	subi	r18, 0xFF	; 255
 286:	3f 4f       	sbci	r19, 0xFF	; 255
 288:	20 32       	cpi	r18, 0x20	; 32
 28a:	31 05       	cpc	r19, r1
 28c:	d1 f7       	brne	.-12     	; 0x282 <_ZN3NRF11clearTxDataEv+0x8>
		TxData[i] = 0x00;		
}
 28e:	08 95       	ret

00000290 <_ZN3NRF13PrepareTxDataEhPhh>:
///@brief Send data from uC to nRF8001
///@param command
///@param data
///@param length Length of data
///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::PrepareTxData(uint8_t command, uint8_t *data, uint8_t length){
 290:	ef 92       	push	r14
 292:	ff 92       	push	r15
 294:	0f 93       	push	r16
 296:	1f 93       	push	r17
 298:	cf 93       	push	r28
 29a:	df 93       	push	r29
 29c:	ec 01       	movw	r28, r24
 29e:	16 2f       	mov	r17, r22
 2a0:	e4 2e       	mov	r14, r20
 2a2:	f5 2e       	mov	r15, r21
 2a4:	02 2f       	mov	r16, r18
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 2a6:	fc 01       	movw	r30, r24
 2a8:	ef 58       	subi	r30, 0x8F	; 143
 2aa:	ff 4f       	sbci	r31, 0xFF	; 255
///@param length Length of data
///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::PrepareTxData(uint8_t command, uint8_t *data, uint8_t length){
	//TODO: write this function
	int i;
	if (isInitializing())
 2ac:	80 81       	ld	r24, Z
 2ae:	82 30       	cpi	r24, 0x02	; 2
 2b0:	e1 f0       	breq	.+56     	; 0x2ea <_ZN3NRF13PrepareTxDataEhPhh+0x5a>
		return 0x01;
	if (hasDataToSend())
 2b2:	ce 01       	movw	r24, r28
 2b4:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN3NRF13hasDataToSendEv>
 2b8:	81 11       	cpse	r24, r1
 2ba:	19 c0       	rjmp	.+50     	; 0x2ee <_ZN3NRF13PrepareTxDataEhPhh+0x5e>
		return 0x02;
	if (waitingForResponse() && isSystemCommand(command))
 2bc:	ce 01       	movw	r24, r28
 2be:	0e 94 05 01 	call	0x20a	; 0x20a <_ZN3NRF18waitingForResponseEv>
 2c2:	88 23       	and	r24, r24
 2c4:	c1 f0       	breq	.+48     	; 0x2f6 <_ZN3NRF13PrepareTxDataEhPhh+0x66>
 2c6:	61 2f       	mov	r22, r17
 2c8:	ce 01       	movw	r24, r28
 2ca:	0e 94 20 01 	call	0x240	; 0x240 <_ZN3NRF15isSystemCommandEh>
 2ce:	81 11       	cpse	r24, r1
 2d0:	10 c0       	rjmp	.+32     	; 0x2f2 <_ZN3NRF13PrepareTxDataEhPhh+0x62>
 2d2:	11 c0       	rjmp	.+34     	; 0x2f6 <_ZN3NRF13PrepareTxDataEhPhh+0x66>
	
	//populate TxData with length and data
	TxData[0] = length + 1;
	TxData[1] = command;
	for(i = 0; i < length; i++)
		TxData[i+2] = data[i];	
 2d4:	41 91       	ld	r20, Z+
 2d6:	4d 93       	st	X+, r20
	clearTxData();
	
	//populate TxData with length and data
	TxData[0] = length + 1;
	TxData[1] = command;
	for(i = 0; i < length; i++)
 2d8:	01 96       	adiw	r24, 0x01	; 1
 2da:	82 17       	cp	r24, r18
 2dc:	93 07       	cpc	r25, r19
 2de:	d4 f3       	brlt	.-12     	; 0x2d4 <_ZN3NRF13PrepareTxDataEhPhh+0x44>
		TxData[i+2] = data[i];	
		
	//data to send flag
	status |= (1<<NRF_TX_READY);
 2e0:	8a 8d       	ldd	r24, Y+26	; 0x1a
 2e2:	80 64       	ori	r24, 0x40	; 64
 2e4:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;	//success
 2e6:	80 e0       	ldi	r24, 0x00	; 0
 2e8:	1d c0       	rjmp	.+58     	; 0x324 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::PrepareTxData(uint8_t command, uint8_t *data, uint8_t length){
	//TODO: write this function
	int i;
	if (isInitializing())
		return 0x01;
 2ea:	81 e0       	ldi	r24, 0x01	; 1
 2ec:	1b c0       	rjmp	.+54     	; 0x324 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
	if (hasDataToSend())
		return 0x02;
 2ee:	82 e0       	ldi	r24, 0x02	; 2
 2f0:	19 c0       	rjmp	.+50     	; 0x324 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
	if (waitingForResponse() && isSystemCommand(command))
		return 0x03;
 2f2:	83 e0       	ldi	r24, 0x03	; 3
 2f4:	17 c0       	rjmp	.+46     	; 0x324 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
	
	lastCommand = command;
 2f6:	fe 01       	movw	r30, r28
 2f8:	ed 58       	subi	r30, 0x8D	; 141
 2fa:	ff 4f       	sbci	r31, 0xFF	; 255
 2fc:	10 83       	st	Z, r17
	
	clearTxData();
 2fe:	ce 01       	movw	r24, r28
 300:	0e 94 3d 01 	call	0x27a	; 0x27a <_ZN3NRF11clearTxDataEv>
	
	//populate TxData with length and data
	TxData[0] = length + 1;
 304:	81 e0       	ldi	r24, 0x01	; 1
 306:	80 0f       	add	r24, r16
 308:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = command;
 30a:	1c af       	std	Y+60, r17	; 0x3c
	for(i = 0; i < length; i++)
 30c:	20 2f       	mov	r18, r16
 30e:	30 e0       	ldi	r19, 0x00	; 0
 310:	12 16       	cp	r1, r18
 312:	13 06       	cpc	r1, r19
 314:	2c f7       	brge	.-54     	; 0x2e0 <_ZN3NRF13PrepareTxDataEhPhh+0x50>
 316:	ee 2d       	mov	r30, r14
 318:	ff 2d       	mov	r31, r15
 31a:	de 01       	movw	r26, r28
 31c:	dd 96       	adiw	r26, 0x3d	; 61
 31e:	80 e0       	ldi	r24, 0x00	; 0
 320:	90 e0       	ldi	r25, 0x00	; 0
 322:	d8 cf       	rjmp	.-80     	; 0x2d4 <_ZN3NRF13PrepareTxDataEhPhh+0x44>
		TxData[i+2] = data[i];	
		
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData
 324:	df 91       	pop	r29
 326:	cf 91       	pop	r28
 328:	1f 91       	pop	r17
 32a:	0f 91       	pop	r16
 32c:	ff 90       	pop	r15
 32e:	ef 90       	pop	r14
 330:	08 95       	ret

00000332 <_ZN3NRF10disconnectEh>:
	localData[2] = (advInterval&0x00FF);	//LSB
	localData[3] = (advInterval&0xFF00)>>8; //MSB
	return (PrepareTxData(NRF_CMD_BOND, localData, 4));
}//

uint8_t NRF::disconnect(uint8_t reason){
 332:	cf 93       	push	r28
 334:	df 93       	push	r29
 336:	1f 92       	push	r1
 338:	cd b7       	in	r28, 0x3d	; 61
 33a:	de b7       	in	r29, 0x3e	; 62
 33c:	69 83       	std	Y+1, r22	; 0x01
	return (PrepareTxData(NRF_CMD_DISCONNECT, &reason, 1));
 33e:	21 e0       	ldi	r18, 0x01	; 1
 340:	ae 01       	movw	r20, r28
 342:	4f 5f       	subi	r20, 0xFF	; 255
 344:	5f 4f       	sbci	r21, 0xFF	; 255
 346:	61 e1       	ldi	r22, 0x11	; 17
 348:	0e 94 48 01 	call	0x290	; 0x290 <_ZN3NRF13PrepareTxDataEhPhh>
}//
 34c:	0f 90       	pop	r0
 34e:	df 91       	pop	r29
 350:	cf 91       	pop	r28
 352:	08 95       	ret

00000354 <_ZN3NRF11requestDataEh>:
	if (retVal == 0x00)
		dataCredit-=1;
	return (retVal);
}//

uint8_t NRF::requestData(uint8_t servicePipeNumber){
 354:	0f 93       	push	r16
 356:	1f 93       	push	r17
 358:	cf 93       	push	r28
 35a:	df 93       	push	r29
 35c:	1f 92       	push	r1
 35e:	cd b7       	in	r28, 0x3d	; 61
 360:	de b7       	in	r29, 0x3e	; 62
 362:	8c 01       	movw	r16, r24
 364:	69 83       	std	Y+1, r22	; 0x01
	uint8_t retVal = PrepareTxData(NRF_CMD_REQUEST_DATA, &servicePipeNumber, 1);
 366:	21 e0       	ldi	r18, 0x01	; 1
 368:	ae 01       	movw	r20, r28
 36a:	4f 5f       	subi	r20, 0xFF	; 255
 36c:	5f 4f       	sbci	r21, 0xFF	; 255
 36e:	67 e1       	ldi	r22, 0x17	; 23
 370:	0e 94 48 01 	call	0x290	; 0x290 <_ZN3NRF13PrepareTxDataEhPhh>
	if (retVal == 0x00)
 374:	81 11       	cpse	r24, r1
 376:	06 c0       	rjmp	.+12     	; 0x384 <_ZN3NRF11requestDataEh+0x30>
		dataCredit-=1;
 378:	f8 01       	movw	r30, r16
 37a:	ee 58       	subi	r30, 0x8E	; 142
 37c:	ff 4f       	sbci	r31, 0xFF	; 255
 37e:	90 81       	ld	r25, Z
 380:	91 50       	subi	r25, 0x01	; 1
 382:	90 83       	st	Z, r25
	return (retVal);
}//
 384:	0f 90       	pop	r0
 386:	df 91       	pop	r29
 388:	cf 91       	pop	r28
 38a:	1f 91       	pop	r17
 38c:	0f 91       	pop	r16
 38e:	08 95       	ret

00000390 <_ZN3NRF13PrepareTxDataEhhPhh>:
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command, uint8_t content, uint8_t *data, uint8_t length){
 390:	df 92       	push	r13
 392:	ef 92       	push	r14
 394:	ff 92       	push	r15
 396:	0f 93       	push	r16
 398:	1f 93       	push	r17
 39a:	cf 93       	push	r28
 39c:	df 93       	push	r29
 39e:	ec 01       	movw	r28, r24
 3a0:	16 2f       	mov	r17, r22
 3a2:	f4 2e       	mov	r15, r20
 3a4:	d2 2e       	mov	r13, r18
 3a6:	e3 2e       	mov	r14, r19
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 3a8:	fc 01       	movw	r30, r24
 3aa:	ef 58       	subi	r30, 0x8F	; 143
 3ac:	ff 4f       	sbci	r31, 0xFF	; 255
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command, uint8_t content, uint8_t *data, uint8_t length){
	
	int i;
	if (isInitializing())
 3ae:	80 81       	ld	r24, Z
 3b0:	82 30       	cpi	r24, 0x02	; 2
 3b2:	e1 f0       	breq	.+56     	; 0x3ec <_ZN3NRF13PrepareTxDataEhhPhh+0x5c>
		return 0x01;
	if (hasDataToSend())
 3b4:	ce 01       	movw	r24, r28
 3b6:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN3NRF13hasDataToSendEv>
 3ba:	81 11       	cpse	r24, r1
 3bc:	19 c0       	rjmp	.+50     	; 0x3f0 <_ZN3NRF13PrepareTxDataEhhPhh+0x60>
		return 0x02;
	if (waitingForResponse() && isSystemCommand(command))
 3be:	ce 01       	movw	r24, r28
 3c0:	0e 94 05 01 	call	0x20a	; 0x20a <_ZN3NRF18waitingForResponseEv>
 3c4:	88 23       	and	r24, r24
 3c6:	c1 f0       	breq	.+48     	; 0x3f8 <_ZN3NRF13PrepareTxDataEhhPhh+0x68>
 3c8:	61 2f       	mov	r22, r17
 3ca:	ce 01       	movw	r24, r28
 3cc:	0e 94 20 01 	call	0x240	; 0x240 <_ZN3NRF15isSystemCommandEh>
 3d0:	81 11       	cpse	r24, r1
 3d2:	10 c0       	rjmp	.+32     	; 0x3f4 <_ZN3NRF13PrepareTxDataEhhPhh+0x64>
 3d4:	11 c0       	rjmp	.+34     	; 0x3f8 <_ZN3NRF13PrepareTxDataEhhPhh+0x68>
	//populate TxData with length and data
	TxData[0] = length + 2;
	TxData[1] = command;
	TxData[2] = content;
	for(i = 0; i < length; i++)
		TxData[i+3] = data[i];
 3d6:	21 91       	ld	r18, Z+
 3d8:	2d 93       	st	X+, r18
	clearTxData();
	//populate TxData with length and data
	TxData[0] = length + 2;
	TxData[1] = command;
	TxData[2] = content;
	for(i = 0; i < length; i++)
 3da:	01 96       	adiw	r24, 0x01	; 1
 3dc:	80 17       	cp	r24, r16
 3de:	91 07       	cpc	r25, r17
 3e0:	d4 f3       	brlt	.-12     	; 0x3d6 <_ZN3NRF13PrepareTxDataEhhPhh+0x46>
		TxData[i+3] = data[i];
	
	//data to send flag
	status |= (1<<NRF_TX_READY);
 3e2:	8a 8d       	ldd	r24, Y+26	; 0x1a
 3e4:	80 64       	ori	r24, 0x40	; 64
 3e6:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;	//success
 3e8:	80 e0       	ldi	r24, 0x00	; 0
 3ea:	1d c0       	rjmp	.+58     	; 0x426 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>

uint8_t NRF::PrepareTxData(uint8_t command, uint8_t content, uint8_t *data, uint8_t length){
	
	int i;
	if (isInitializing())
		return 0x01;
 3ec:	81 e0       	ldi	r24, 0x01	; 1
 3ee:	1b c0       	rjmp	.+54     	; 0x426 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>
	if (hasDataToSend())
		return 0x02;
 3f0:	82 e0       	ldi	r24, 0x02	; 2
 3f2:	19 c0       	rjmp	.+50     	; 0x426 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>
	if (waitingForResponse() && isSystemCommand(command))
		return 0x03;
 3f4:	83 e0       	ldi	r24, 0x03	; 3
 3f6:	17 c0       	rjmp	.+46     	; 0x426 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>
	
	lastCommand = command;
 3f8:	fe 01       	movw	r30, r28
 3fa:	ed 58       	subi	r30, 0x8D	; 141
 3fc:	ff 4f       	sbci	r31, 0xFF	; 255
 3fe:	10 83       	st	Z, r17
	
	clearTxData();
 400:	ce 01       	movw	r24, r28
 402:	0e 94 3d 01 	call	0x27a	; 0x27a <_ZN3NRF11clearTxDataEv>
	//populate TxData with length and data
	TxData[0] = length + 2;
 406:	82 e0       	ldi	r24, 0x02	; 2
 408:	80 0f       	add	r24, r16
 40a:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = command;
 40c:	1c af       	std	Y+60, r17	; 0x3c
	TxData[2] = content;
 40e:	fd ae       	std	Y+61, r15	; 0x3d
	for(i = 0; i < length; i++)
 410:	10 e0       	ldi	r17, 0x00	; 0
 412:	10 16       	cp	r1, r16
 414:	11 06       	cpc	r1, r17
 416:	2c f7       	brge	.-54     	; 0x3e2 <_ZN3NRF13PrepareTxDataEhhPhh+0x52>
 418:	ed 2d       	mov	r30, r13
 41a:	fe 2d       	mov	r31, r14
 41c:	de 01       	movw	r26, r28
 41e:	de 96       	adiw	r26, 0x3e	; 62
 420:	80 e0       	ldi	r24, 0x00	; 0
 422:	90 e0       	ldi	r25, 0x00	; 0
 424:	d8 cf       	rjmp	.-80     	; 0x3d6 <_ZN3NRF13PrepareTxDataEhhPhh+0x46>
		TxData[i+3] = data[i];
	
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData
 426:	df 91       	pop	r29
 428:	cf 91       	pop	r28
 42a:	1f 91       	pop	r17
 42c:	0f 91       	pop	r16
 42e:	ff 90       	pop	r15
 430:	ef 90       	pop	r14
 432:	df 90       	pop	r13
 434:	08 95       	ret

00000436 <_ZN3NRF12setLocalDataEhPhh>:
return (PrepareTxData(NRF_CMD_CLOSE_REMOTE_PIPE, &servicePipeNumber, 1));
}//
#pragma endregion System Command Functions

#pragma region Data Command Functions
uint8_t NRF::setLocalData(uint8_t servicePipeNumber, uint8_t *data, uint8_t length){	
 436:	0f 93       	push	r16
	return (PrepareTxData(NRF_CMD_SET_LOCAL_DATA, servicePipeNumber, data, length));
 438:	02 2f       	mov	r16, r18
 43a:	9a 01       	movw	r18, r20
 43c:	46 2f       	mov	r20, r22
 43e:	6d e0       	ldi	r22, 0x0D	; 13
 440:	0e 94 c8 01 	call	0x390	; 0x390 <_ZN3NRF13PrepareTxDataEhhPhh>
}//
 444:	0f 91       	pop	r16
 446:	08 95       	ret

00000448 <_ZN3NRF13PrepareTxDataEh>:
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command){
 448:	1f 93       	push	r17
 44a:	cf 93       	push	r28
 44c:	df 93       	push	r29
 44e:	ec 01       	movw	r28, r24
 450:	16 2f       	mov	r17, r22
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 452:	fc 01       	movw	r30, r24
 454:	ef 58       	subi	r30, 0x8F	; 143
 456:	ff 4f       	sbci	r31, 0xFF	; 255
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command){
	if (isInitializing())
 458:	80 81       	ld	r24, Z
 45a:	82 30       	cpi	r24, 0x02	; 2
 45c:	91 f0       	breq	.+36     	; 0x482 <_ZN3NRF13PrepareTxDataEh+0x3a>
		return 0x01;
	if (hasDataToSend())
 45e:	ce 01       	movw	r24, r28
 460:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN3NRF13hasDataToSendEv>
 464:	81 11       	cpse	r24, r1
 466:	0f c0       	rjmp	.+30     	; 0x486 <_ZN3NRF13PrepareTxDataEh+0x3e>
		return 0x02;
	if (waitingForResponse() && isSystemCommand(command))
 468:	ce 01       	movw	r24, r28
 46a:	0e 94 05 01 	call	0x20a	; 0x20a <_ZN3NRF18waitingForResponseEv>
 46e:	88 23       	and	r24, r24
 470:	61 f0       	breq	.+24     	; 0x48a <_ZN3NRF13PrepareTxDataEh+0x42>
 472:	61 2f       	mov	r22, r17
 474:	ce 01       	movw	r24, r28
 476:	0e 94 20 01 	call	0x240	; 0x240 <_ZN3NRF15isSystemCommandEh>
 47a:	88 23       	and	r24, r24
 47c:	31 f0       	breq	.+12     	; 0x48a <_ZN3NRF13PrepareTxDataEh+0x42>
		return 0x03;
 47e:	83 e0       	ldi	r24, 0x03	; 3
 480:	12 c0       	rjmp	.+36     	; 0x4a6 <_ZN3NRF13PrepareTxDataEh+0x5e>
	return 0x00;	//success
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command){
	if (isInitializing())
		return 0x01;
 482:	81 e0       	ldi	r24, 0x01	; 1
 484:	10 c0       	rjmp	.+32     	; 0x4a6 <_ZN3NRF13PrepareTxDataEh+0x5e>
	if (hasDataToSend())
		return 0x02;
 486:	82 e0       	ldi	r24, 0x02	; 2
 488:	0e c0       	rjmp	.+28     	; 0x4a6 <_ZN3NRF13PrepareTxDataEh+0x5e>
	if (waitingForResponse() && isSystemCommand(command))
		return 0x03;
	
	lastCommand = command;
 48a:	fe 01       	movw	r30, r28
 48c:	ed 58       	subi	r30, 0x8D	; 141
 48e:	ff 4f       	sbci	r31, 0xFF	; 255
 490:	10 83       	st	Z, r17
	
	clearTxData();
 492:	ce 01       	movw	r24, r28
 494:	0e 94 3d 01 	call	0x27a	; 0x27a <_ZN3NRF11clearTxDataEv>
	TxData[0] = 0x01;
 498:	81 e0       	ldi	r24, 0x01	; 1
 49a:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = command;
 49c:	1c af       	std	Y+60, r17	; 0x3c
	status |= (1<<NRF_TX_READY);
 49e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 4a0:	80 64       	ori	r24, 0x40	; 64
 4a2:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;
 4a4:	80 e0       	ldi	r24, 0x00	; 0
}
 4a6:	df 91       	pop	r29
 4a8:	cf 91       	pop	r28
 4aa:	1f 91       	pop	r17
 4ac:	08 95       	ret

000004ae <_ZN3NRF5sleepEv>:
	localData[1] = command&0x00FF;		//LSB
	return (PrepareTxData(NRF_CMD_DTM_COMMAND, localData, 2));
}//DTMcommand

uint8_t NRF::sleep(){
	status |= (1<<NRF_SLEEPING);
 4ae:	fc 01       	movw	r30, r24
 4b0:	22 8d       	ldd	r18, Z+26	; 0x1a
 4b2:	22 60       	ori	r18, 0x02	; 2
 4b4:	22 8f       	std	Z+26, r18	; 0x1a
	return (PrepareTxData(NRF_CMD_SLEEP));
 4b6:	64 e0       	ldi	r22, 0x04	; 4
 4b8:	0e 94 24 02 	call	0x448	; 0x448 <_ZN3NRF13PrepareTxDataEh>
}//sleep
 4bc:	08 95       	ret

000004be <_ZN3NRF6wakeupEv>:

///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::wakeup(void){	
	return (PrepareTxData(NRF_CMD_WAKEUP));
 4be:	65 e0       	ldi	r22, 0x05	; 5
 4c0:	0e 94 24 02 	call	0x448	; 0x448 <_ZN3NRF13PrepareTxDataEh>
}
 4c4:	08 95       	ret

000004c6 <_ZN3NRF7connectEjj>:

uint8_t NRF::radioReset(){
	return (PrepareTxData(NRF_CMD_RADIO_RESET));
}//

uint8_t NRF::connect(uint16_t timeout, uint16_t advInterval){	
 4c6:	ef 92       	push	r14
 4c8:	ff 92       	push	r15
 4ca:	0f 93       	push	r16
 4cc:	1f 93       	push	r17
 4ce:	cf 93       	push	r28
 4d0:	df 93       	push	r29
 4d2:	ec 01       	movw	r28, r24
 4d4:	e6 2e       	mov	r14, r22
 4d6:	f7 2e       	mov	r15, r23
 4d8:	04 2f       	mov	r16, r20
 4da:	15 2f       	mov	r17, r21
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 4dc:	fc 01       	movw	r30, r24
 4de:	ef 58       	subi	r30, 0x8F	; 143
 4e0:	ff 4f       	sbci	r31, 0xFF	; 255
	//localData[1] = (timeout&0xFF00)>>8; //MSB
	//localData[2] = (advInterval&0x00FF);	//LSB
	//localData[3] = (advInterval&0xFF00)>>8; //MSB
	//return (PrepareTxData(NRF_CMD_CONNECT, localData, 4));
	
	if (isInitializing())
 4e2:	80 81       	ld	r24, Z
 4e4:	82 30       	cpi	r24, 0x02	; 2
 4e6:	11 f1       	breq	.+68     	; 0x52c <_ZN3NRF7connectEjj+0x66>
	return 0x01;
	if (hasDataToSend())
 4e8:	ce 01       	movw	r24, r28
 4ea:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN3NRF13hasDataToSendEv>
 4ee:	81 11       	cpse	r24, r1
 4f0:	1f c0       	rjmp	.+62     	; 0x530 <_ZN3NRF7connectEjj+0x6a>
	return 0x02;
	if (waitingForResponse())
 4f2:	ce 01       	movw	r24, r28
 4f4:	0e 94 05 01 	call	0x20a	; 0x20a <_ZN3NRF18waitingForResponseEv>
 4f8:	81 11       	cpse	r24, r1
 4fa:	1c c0       	rjmp	.+56     	; 0x534 <_ZN3NRF7connectEjj+0x6e>
	return 0x03;
	
	lastCommand = TxData[1];
 4fc:	fe 01       	movw	r30, r28
 4fe:	ed 58       	subi	r30, 0x8D	; 141
 500:	ff 4f       	sbci	r31, 0xFF	; 255
 502:	8c ad       	ldd	r24, Y+60	; 0x3c
 504:	80 83       	st	Z, r24
	
	clearTxData();
 506:	ce 01       	movw	r24, r28
 508:	0e 94 3d 01 	call	0x27a	; 0x27a <_ZN3NRF11clearTxDataEv>
	TxData[0] = 0x05;	//length
 50c:	85 e0       	ldi	r24, 0x05	; 5
 50e:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = NRF_CMD_CONNECT;
 510:	8f e0       	ldi	r24, 0x0F	; 15
 512:	8c af       	std	Y+60, r24	; 0x3c
	TxData[2] = (timeout&0x00FF);	//LSB
 514:	ed ae       	std	Y+61, r14	; 0x3d
	TxData[3] = (timeout&0xFF00)>>8; //MSB
 516:	fe ae       	std	Y+62, r15	; 0x3e
	TxData[4] = (advInterval&0x00FF);	//LSB
 518:	0f af       	std	Y+63, r16	; 0x3f
	TxData[5] = (advInterval&0xFF00)>>8; //MSB
 51a:	fe 01       	movw	r30, r28
 51c:	e0 5c       	subi	r30, 0xC0	; 192
 51e:	ff 4f       	sbci	r31, 0xFF	; 255
 520:	10 83       	st	Z, r17
	status |= (1<<NRF_TX_READY);
 522:	8a 8d       	ldd	r24, Y+26	; 0x1a
 524:	80 64       	ori	r24, 0x40	; 64
 526:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;
 528:	80 e0       	ldi	r24, 0x00	; 0
 52a:	05 c0       	rjmp	.+10     	; 0x536 <_ZN3NRF7connectEjj+0x70>
	//localData[2] = (advInterval&0x00FF);	//LSB
	//localData[3] = (advInterval&0xFF00)>>8; //MSB
	//return (PrepareTxData(NRF_CMD_CONNECT, localData, 4));
	
	if (isInitializing())
	return 0x01;
 52c:	81 e0       	ldi	r24, 0x01	; 1
 52e:	03 c0       	rjmp	.+6      	; 0x536 <_ZN3NRF7connectEjj+0x70>
	if (hasDataToSend())
	return 0x02;
 530:	82 e0       	ldi	r24, 0x02	; 2
 532:	01 c0       	rjmp	.+2      	; 0x536 <_ZN3NRF7connectEjj+0x70>
	if (waitingForResponse())
	return 0x03;
 534:	83 e0       	ldi	r24, 0x03	; 3
	TxData[3] = (timeout&0xFF00)>>8; //MSB
	TxData[4] = (advInterval&0x00FF);	//LSB
	TxData[5] = (advInterval&0xFF00)>>8; //MSB
	status |= (1<<NRF_TX_READY);
	return 0x00;
}//
 536:	df 91       	pop	r29
 538:	cf 91       	pop	r28
 53a:	1f 91       	pop	r17
 53c:	0f 91       	pop	r16
 53e:	ff 90       	pop	r15
 540:	ef 90       	pop	r14
 542:	08 95       	ret

00000544 <_ZN3NRF11transferACIEv>:
nRF8001 is capable of receiving an ACI command simultaneously as it sends an ACI event to the
application controller.
The application controller shall always read the length byte from nRF8001 and check if the length is
greater than 0. If the length is greater than 0 the data on the MISO line shall be read
*/
void NRF::transferACI(void){
 544:	1f 93       	push	r17
 546:	cf 93       	push	r28
 548:	df 93       	push	r29
 54a:	ec 01       	movw	r28, r24
	uint8_t length; 
	
	//transmit and receive
	if (hasDataToSend() && (TxData[0] > 0)){			
 54c:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN3NRF13hasDataToSendEv>
 550:	88 23       	and	r24, r24
 552:	09 f4       	brne	.+2      	; 0x556 <_ZN3NRF11transferACIEv+0x12>
 554:	40 c0       	rjmp	.+128    	; 0x5d6 <_ZN3NRF11transferACIEv+0x92>
 556:	8b ad       	ldd	r24, Y+59	; 0x3b
 558:	81 11       	cpse	r24, r1
 55a:	40 c0       	rjmp	.+128    	; 0x5dc <_ZN3NRF11transferACIEv+0x98>
 55c:	3c c0       	rjmp	.+120    	; 0x5d6 <_ZN3NRF11transferACIEv+0x92>
		SetREQN();
		
		//when data is received, clear the ready to receive flag until
		//the received data is handled by the process function
		if (RxData[0] != 0x00){
			status &= ~(1<<NRF_RX_READY);
 55e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 560:	8f 77       	andi	r24, 0x7F	; 127
 562:	8a 8f       	std	Y+26, r24	; 0x1a
		}
		
		
		lastCommand = TxData[1];
 564:	6c ad       	ldd	r22, Y+60	; 0x3c
 566:	fe 01       	movw	r30, r28
 568:	ed 58       	subi	r30, 0x8D	; 141
 56a:	ff 4f       	sbci	r31, 0xFF	; 255
 56c:	60 83       	st	Z, r22
		
		//clear the NRF_TX_READY flag in the status register
		status &= ~(1<<NRF_TX_READY);
 56e:	1a 8d       	ldd	r17, Y+26	; 0x1a
 570:	1f 7b       	andi	r17, 0xBF	; 191
		
		if (isSystemCommand(TxData[1]))
 572:	ce 01       	movw	r24, r28
 574:	0e 94 20 01 	call	0x240	; 0x240 <_ZN3NRF15isSystemCommandEh>
 578:	81 11       	cpse	r24, r1
 57a:	02 c0       	rjmp	.+4      	; 0x580 <_ZN3NRF11transferACIEv+0x3c>
		
		
		lastCommand = TxData[1];
		
		//clear the NRF_TX_READY flag in the status register
		status &= ~(1<<NRF_TX_READY);
 57c:	1a 8f       	std	Y+26, r17	; 0x1a
 57e:	58 c0       	rjmp	.+176    	; 0x630 <_ZN3NRF11transferACIEv+0xec>
		
		if (isSystemCommand(TxData[1]))
			status |= (1<<NRF_WAIT_FOR_RESPONSE);
 580:	10 61       	ori	r17, 0x10	; 16
 582:	1a 8f       	std	Y+26, r17	; 0x1a
 584:	55 c0       	rjmp	.+170    	; 0x630 <_ZN3NRF11transferACIEv+0xec>
	}//if hasDataToSend
	
	//receive only
	else if(RDYN == 0)
	{
		clearTxData();
 586:	ce 01       	movw	r24, r28
 588:	0e 94 3d 01 	call	0x27a	; 0x27a <_ZN3NRF11clearTxDataEv>
		//Request communication with nRF8001
		ClearREQN();
 58c:	29 98       	cbi	0x05, 1	; 5
		
		//transmit the DUMMY BYTE and receive the Rx DEBUG BYTE
		//the LENGTH BYTE is not counted as part of the length
		RxData[0] = spi.transfer1byte(0x00);
 58e:	60 e0       	ldi	r22, 0x00	; 0
 590:	85 e7       	ldi	r24, 0x75	; 117
 592:	93 e0       	ldi	r25, 0x03	; 3
 594:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <_ZN3SPI13transfer1byteEh>
 598:	8b 8f       	std	Y+27, r24	; 0x1b
		
		//Transmit a DUMMY BYTE and receive the LENGTH BYTE
		RxData[0] = spi.transfer1byte(0x00);
 59a:	60 e0       	ldi	r22, 0x00	; 0
 59c:	85 e7       	ldi	r24, 0x75	; 117
 59e:	93 e0       	ldi	r25, 0x03	; 3
 5a0:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <_ZN3SPI13transfer1byteEh>
 5a4:	8b 8f       	std	Y+27, r24	; 0x1b
 5a6:	28 2f       	mov	r18, r24
 5a8:	80 32       	cpi	r24, 0x20	; 32
 5aa:	08 f0       	brcs	.+2      	; 0x5ae <_ZN3NRF11transferACIEv+0x6a>
 5ac:	2f e1       	ldi	r18, 0x1F	; 31
		
		length = RxData[0];
		if (length>HAL_ACI_MAX_LENGTH)
			length = HAL_ACI_MAX_LENGTH;
		if (length>0)
 5ae:	22 23       	and	r18, r18
 5b0:	51 f0       	breq	.+20     	; 0x5c6 <_ZN3NRF11transferACIEv+0x82>
		{
			
			spi.transfer(&TxData[2],&RxData[1],length);
 5b2:	ae 01       	movw	r20, r28
 5b4:	44 5e       	subi	r20, 0xE4	; 228
 5b6:	5f 4f       	sbci	r21, 0xFF	; 255
 5b8:	be 01       	movw	r22, r28
 5ba:	63 5c       	subi	r22, 0xC3	; 195
 5bc:	7f 4f       	sbci	r23, 0xFF	; 255
 5be:	85 e7       	ldi	r24, 0x75	; 117
 5c0:	93 e0       	ldi	r25, 0x03	; 3
 5c2:	0e 94 dd 00 	call	0x1ba	; 0x1ba <_ZN3SPI8transferEPhS0_h>
		}//if length>0
		
		//Set REQN high to terminate the transfer
		SetREQN();
 5c6:	29 9a       	sbi	0x05, 1	; 5
		
		//when data is received, clear the ready to receive flag until
		//the received data is handled by the process function
		if (RxData[0] != 0x00){
 5c8:	8b 8d       	ldd	r24, Y+27	; 0x1b
 5ca:	88 23       	and	r24, r24
 5cc:	89 f1       	breq	.+98     	; 0x630 <_ZN3NRF11transferACIEv+0xec>
			status &= ~(1<<NRF_RX_READY);
 5ce:	8a 8d       	ldd	r24, Y+26	; 0x1a
 5d0:	8f 77       	andi	r24, 0x7F	; 127
 5d2:	8a 8f       	std	Y+26, r24	; 0x1a
 5d4:	2d c0       	rjmp	.+90     	; 0x630 <_ZN3NRF11transferACIEv+0xec>
			status |= (1<<NRF_WAIT_FOR_RESPONSE);
				
	}//if hasDataToSend
	
	//receive only
	else if(RDYN == 0)
 5d6:	2a 99       	sbic	0x05, 2	; 5
 5d8:	2b c0       	rjmp	.+86     	; 0x630 <_ZN3NRF11transferACIEv+0xec>
 5da:	d5 cf       	rjmp	.-86     	; 0x586 <_ZN3NRF11transferACIEv+0x42>
	//transmit and receive
	if (hasDataToSend() && (TxData[0] > 0)){			
		length = TxData[0];
	
		//Request communication with nRF8001
		ClearREQN();
 5dc:	29 98       	cbi	0x05, 1	; 5
	
		//Wait for nRF8001 to clear RDYN pin indicating it is ready to receive
		while (RDYN == 1);
 5de:	85 b1       	in	r24, 0x05	; 5
	
		//transmit the Tx LENGTH BYTE and receive the Rx DEBUG BYTE
		//the LENGTH BYTE is not counted as part of the length
		RxData[0] = spi.transfer1byte(TxData[0]);
 5e0:	6b ad       	ldd	r22, Y+59	; 0x3b
 5e2:	85 e7       	ldi	r24, 0x75	; 117
 5e4:	93 e0       	ldi	r25, 0x03	; 3
 5e6:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <_ZN3SPI13transfer1byteEh>
 5ea:	8b 8f       	std	Y+27, r24	; 0x1b
	
	
		//transmit the first byte of data while receiving the length byte
		//we are discarding the Rx DEBUG BYTE
		RxData[0] = spi.transfer1byte(TxData[1]);
 5ec:	6c ad       	ldd	r22, Y+60	; 0x3c
 5ee:	85 e7       	ldi	r24, 0x75	; 117
 5f0:	93 e0       	ldi	r25, 0x03	; 3
 5f2:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <_ZN3SPI13transfer1byteEh>
 5f6:	8b 8f       	std	Y+27, r24	; 0x1b
	
		////set length to the greater of TxData less the byte we already sent or 
		////RxData length
		length = (RxData[0]>(TxData[0] -1))?RxData[0]:(TxData[0]-1);
 5f8:	4b ad       	ldd	r20, Y+59	; 0x3b
 5fa:	50 e0       	ldi	r21, 0x00	; 0
 5fc:	41 50       	subi	r20, 0x01	; 1
 5fe:	51 09       	sbc	r21, r1
 600:	28 2f       	mov	r18, r24
 602:	30 e0       	ldi	r19, 0x00	; 0
 604:	24 17       	cp	r18, r20
 606:	35 07       	cpc	r19, r21
 608:	0c f4       	brge	.+2      	; 0x60c <_ZN3NRF11transferACIEv+0xc8>
 60a:	9a 01       	movw	r18, r20
 60c:	20 32       	cpi	r18, 0x20	; 32
 60e:	08 f0       	brcs	.+2      	; 0x612 <_ZN3NRF11transferACIEv+0xce>
 610:	2f e1       	ldi	r18, 0x1F	; 31
		if (length>HAL_ACI_MAX_LENGTH) 
			length = HAL_ACI_MAX_LENGTH;
			
		//if (length>0)
		spi.transfer(&TxData[2],&RxData[1],length);
 612:	ae 01       	movw	r20, r28
 614:	44 5e       	subi	r20, 0xE4	; 228
 616:	5f 4f       	sbci	r21, 0xFF	; 255
 618:	be 01       	movw	r22, r28
 61a:	63 5c       	subi	r22, 0xC3	; 195
 61c:	7f 4f       	sbci	r23, 0xFF	; 255
 61e:	85 e7       	ldi	r24, 0x75	; 117
 620:	93 e0       	ldi	r25, 0x03	; 3
 622:	0e 94 dd 00 	call	0x1ba	; 0x1ba <_ZN3SPI8transferEPhS0_h>
		//for (uint8_t i = 0; i< length; i++){
			//RxData[i+1] = spi.transfer1byte(TxData[i+2]); 
		//}
	
		//Set REQN high to terminate the transfer
		SetREQN();
 626:	29 9a       	sbi	0x05, 1	; 5
		
		//when data is received, clear the ready to receive flag until
		//the received data is handled by the process function
		if (RxData[0] != 0x00){
 628:	8b 8d       	ldd	r24, Y+27	; 0x1b
 62a:	81 11       	cpse	r24, r1
 62c:	98 cf       	rjmp	.-208    	; 0x55e <_ZN3NRF11transferACIEv+0x1a>
 62e:	9a cf       	rjmp	.-204    	; 0x564 <_ZN3NRF11transferACIEv+0x20>
			status &= ~(1<<NRF_RX_READY);
		}
		
	}//else if(RDYN == 0)	
	
}//transferACI()
 630:	df 91       	pop	r29
 632:	cf 91       	pop	r28
 634:	1f 91       	pop	r17
 636:	08 95       	ret

00000638 <_ZN3NRF11clearRxDataEv>:
void NRF::clearTxData(){
	for(int i = 0; i<32; i++) 
		TxData[i] = 0x00;		
}
void NRF::clearRxData(){
 638:	fc 01       	movw	r30, r24
 63a:	7b 96       	adiw	r30, 0x1b	; 27
	for(int i = 0; i<32; i++)
 63c:	20 e0       	ldi	r18, 0x00	; 0
 63e:	30 e0       	ldi	r19, 0x00	; 0
		RxData[i] = 0x00;
 640:	11 92       	st	Z+, r1
void NRF::clearTxData(){
	for(int i = 0; i<32; i++) 
		TxData[i] = 0x00;		
}
void NRF::clearRxData(){
	for(int i = 0; i<32; i++)
 642:	2f 5f       	subi	r18, 0xFF	; 255
 644:	3f 4f       	sbci	r19, 0xFF	; 255
 646:	20 32       	cpi	r18, 0x20	; 32
 648:	31 05       	cpc	r19, r1
 64a:	d1 f7       	brne	.-12     	; 0x640 <_ZN3NRF11clearRxDataEv+0x8>
		RxData[i] = 0x00;
}
 64c:	08 95       	ret

0000064e <_ZN3NRF22processCommandResponseEv>:
			
		}
	}//else RxData
}//process

void NRF::processCommandResponse(){
 64e:	cf 93       	push	r28
 650:	df 93       	push	r29
 652:	ec 01       	movw	r28, r24
	//	2		CommandOpCode (see switch statement below)
	//	3		Status of command execution
	//	4..31	Command specific data
	
	
	switch (RxData[2]){	//CommandOpCode
 654:	4d 8d       	ldd	r20, Y+29	; 0x1d
 656:	50 e0       	ldi	r21, 0x00	; 0
 658:	fa 01       	movw	r30, r20
 65a:	31 97       	sbiw	r30, 0x01	; 1
 65c:	ee 31       	cpi	r30, 0x1E	; 30
 65e:	f1 05       	cpc	r31, r1
 660:	08 f0       	brcs	.+2      	; 0x664 <_ZN3NRF22processCommandResponseEv+0x16>
 662:	6c c0       	rjmp	.+216    	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
 664:	ec 5c       	subi	r30, 0xCC	; 204
 666:	ff 4f       	sbci	r31, 0xFF	; 255
 668:	0c 94 b2 06 	jmp	0xd64	; 0xd64 <__tablejump2__>
			//RxData[3]	:	Status
			//					ACI_STATUS_ERROR_DEVICE_STATE_INVALID when used in incorrect mode
			//						can only be used in NRF_MODE_TEST, NRF_MODE_SETUP, NRF_MODE_STANDBY
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 66c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 66e:	8f 7e       	andi	r24, 0xEF	; 239
 670:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 672:	64 c0       	rjmp	.+200    	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[3]	:	Status
			//					ACI_STATUS_ERROR_DEVICE_STATE_INVALID when used in incorrect mode
			//						can only be used in NRF_MODE_TEST
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 674:	8a 8d       	ldd	r24, Y+26	; 0x1a
 676:	8f 7e       	andi	r24, 0xEF	; 239
 678:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 67a:	60 c0       	rjmp	.+192    	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[4-5]	:	DTM Event (2 bytes MSB/LSB)
			//Refer to Bluetooth Core specification v4.0, Volume 6, Part F, Direct Test Mode,
			//Sect.3.4, ‘Events’, for description of DTM event format and content
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 67c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 67e:	8f 7e       	andi	r24, 0xEF	; 239
 680:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 682:	5c c0       	rjmp	.+184    	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[3]	:	Status
			//					ACI_STATUS_ERROR_DEVICE_STATE_INVALID when used in incorrect mode
			//						can only be used in NRF_MODE_STANDBY
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 684:	8a 8d       	ldd	r24, Y+26	; 0x1a
 686:	8f 7e       	andi	r24, 0xEF	; 239
 688:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 68a:	58 c0       	rjmp	.+176    	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[4]		: none
			
			status &= ~(1<<NRF_SLEEPING);
			
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 68c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 68e:	8d 7e       	andi	r24, 0xED	; 237
 690:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 692:	54 c0       	rjmp	.+168    	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
			
				
			//on the last run of CMD_SETUP
			//do NOT clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			//the NRF_CMD_SETUP will be followed by NRF_EVT_DEVICE_STARTED			
			if (RxData[3] == ACI_STATUS_TRANSACTION_CONTINUE){
 694:	8e 8d       	ldd	r24, Y+30	; 0x1e
 696:	81 30       	cpi	r24, 0x01	; 1
 698:	19 f4       	brne	.+6      	; 0x6a0 <_ZN3NRF22processCommandResponseEv+0x52>
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 69a:	8a 8d       	ldd	r24, Y+26	; 0x1a
 69c:	8f 7e       	andi	r24, 0xEF	; 239
 69e:	8a 8f       	std	Y+26, r24	; 0x1a
			}
			
			//set the NRF_RX_READY bit in the status register
			status |= (1<<NRF_RX_READY);
 6a0:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6a2:	80 68       	ori	r24, 0x80	; 128
 6a4:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6a6:	4a c0       	rjmp	.+148    	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_READ_DYNAMIC_DATA:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6a8:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6aa:	8f 7e       	andi	r24, 0xEF	; 239
 6ac:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6ae:	46 c0       	rjmp	.+140    	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_WRITE_DYNAMIC_DATA:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6b0:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6b2:	8f 7e       	andi	r24, 0xEF	; 239
 6b4:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6b6:	42 c0       	rjmp	.+132    	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[4-5]	:	Config ID - (LSB/MSB)
			//RxData[6]		:	ACI Protocol version
			//
		
			//TODO: finish this
			version = RxData[6];
 6b8:	89 a1       	ldd	r24, Y+33	; 0x21
 6ba:	90 e0       	ldi	r25, 0x00	; 0
 6bc:	99 8f       	std	Y+25, r25	; 0x19
 6be:	88 8f       	std	Y+24, r24	; 0x18
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6c0:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6c2:	8f 7e       	andi	r24, 0xEF	; 239
 6c4:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6c6:	3a c0       	rjmp	.+116    	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_GET_DEVICE_ADDRESS:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6c8:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6ca:	8f 7e       	andi	r24, 0xEF	; 239
 6cc:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6ce:	36 c0       	rjmp	.+108    	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_GET_BATTERY_LEVEL:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6d0:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6d2:	8f 7e       	andi	r24, 0xEF	; 239
 6d4:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6d6:	32 c0       	rjmp	.+100    	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
			// RxData[5] : temperature MSB
		
			//data[0] = NRF_CMD_GET_TEMPERATURE;
			//data[1] = RxData[4];
			//data[2] = RxData[3];
			if (RxData[3] == ACI_STATUS_SUCCESS)
 6d8:	8e 8d       	ldd	r24, Y+30	; 0x1e
 6da:	81 11       	cpse	r24, r1
 6dc:	09 c0       	rjmp	.+18     	; 0x6f0 <_ZN3NRF22processCommandResponseEv+0xa2>
			temperature = (RxData[5]<<4 | RxData[4]);
 6de:	88 a1       	ldd	r24, Y+32	; 0x20
 6e0:	20 e1       	ldi	r18, 0x10	; 16
 6e2:	82 9f       	mul	r24, r18
 6e4:	c0 01       	movw	r24, r0
 6e6:	11 24       	eor	r1, r1
 6e8:	2f 8d       	ldd	r18, Y+31	; 0x1f
 6ea:	82 2b       	or	r24, r18
 6ec:	9f 8b       	std	Y+23, r25	; 0x17
 6ee:	8e 8b       	std	Y+22, r24	; 0x16
			clearRxData();
 6f0:	ce 01       	movw	r24, r28
 6f2:	0e 94 1c 03 	call	0x638	; 0x638 <_ZN3NRF11clearRxDataEv>
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6f6:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6f8:	8f 7e       	andi	r24, 0xEF	; 239
 6fa:	8a 8f       	std	Y+26, r24	; 0x1a
		break;
 6fc:	1f c0       	rjmp	.+62     	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
			case NRF_CMD_RADIO_RESET:
			//will initialization have to be redone upon reset?
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6fe:	8a 8d       	ldd	r24, Y+26	; 0x1a
 700:	8f 7e       	andi	r24, 0xEF	; 239
 702:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 704:	1b c0       	rjmp	.+54     	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
			//status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
			break;
		case NRF_CMD_SET_TX_POWER:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 706:	8a 8d       	ldd	r24, Y+26	; 0x1a
 708:	8f 7e       	andi	r24, 0xEF	; 239
 70a:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 70c:	17 c0       	rjmp	.+46     	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
			//or by NRF_EVT_PIPE_ERROR(failure)
			break;
		case NRF_CMD_SET_APP_LATENCY:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 70e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 710:	8f 7e       	andi	r24, 0xEF	; 239
 712:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 714:	13 c0       	rjmp	.+38     	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_SET_KEY:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 716:	8a 8d       	ldd	r24, Y+26	; 0x1a
 718:	8f 7e       	andi	r24, 0xEF	; 239
 71a:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 71c:	0f c0       	rjmp	.+30     	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_OPEN_ADV_PIPE:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 71e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 720:	8f 7e       	andi	r24, 0xEF	; 239
 722:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 724:	0b c0       	rjmp	.+22     	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_BROADCAST:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 726:	8a 8d       	ldd	r24, Y+26	; 0x1a
 728:	8f 7e       	andi	r24, 0xEF	; 239
 72a:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 72c:	07 c0       	rjmp	.+14     	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_BOND_SEC_REQUEST:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 72e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 730:	8f 7e       	andi	r24, 0xEF	; 239
 732:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 734:	03 c0       	rjmp	.+6      	; 0x73c <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_DIRECT_CONNECT:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 736:	8a 8d       	ldd	r24, Y+26	; 0x1a
 738:	8f 7e       	andi	r24, 0xEF	; 239
 73a:	8a 8f       	std	Y+26, r24	; 0x1a
		default:
			break;
		
	}//end switch RxData[2]
	
}//processCommandResponse()
 73c:	df 91       	pop	r29
 73e:	cf 91       	pop	r28
 740:	08 95       	ret

00000742 <_ZN3NRF7processEv>:
	//set to INIT_MODE and RX_READY
	//we are waiting for a NRF_EVT_DEVICE_STARTED in NRF_MODE_SETUP
	//status |= (1<<NRF_RX_READY | 1<<NRF_INIT_MODE | 1<<NRF_WAIT_FOR_RESPONSE);
	status |= (1<<NRF_RX_READY | 1<<NRF_WAIT_FOR_RESPONSE);
}
void NRF::process(void){	
 742:	1f 93       	push	r17
 744:	cf 93       	push	r28
 746:	df 93       	push	r29
 748:	ec 01       	movw	r28, r24
	uint8_t i;
	if (isReadyToReceiveData()){
 74a:	8a 8d       	ldd	r24, Y+26	; 0x1a
 74c:	88 23       	and	r24, r24
 74e:	1c f4       	brge	.+6      	; 0x756 <_ZN3NRF7processEv+0x14>
		clearRxData();
 750:	ce 01       	movw	r24, r28
 752:	0e 94 1c 03 	call	0x638	; 0x638 <_ZN3NRF11clearRxDataEv>
	}
		
	
	//setup message from services.h file loaded onto nRF8001
	if( (mode == NRF_MODE_SETUP)  && !hasDataToSend() && !waitingForResponse() ) {
 756:	fe 01       	movw	r30, r28
 758:	ef 58       	subi	r30, 0x8F	; 143
 75a:	ff 4f       	sbci	r31, 0xFF	; 255
 75c:	80 81       	ld	r24, Z
 75e:	82 30       	cpi	r24, 0x02	; 2
 760:	31 f5       	brne	.+76     	; 0x7ae <_ZN3NRF7processEv+0x6c>
 762:	ce 01       	movw	r24, r28
 764:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN3NRF13hasDataToSendEv>
 768:	81 11       	cpse	r24, r1
 76a:	21 c0       	rjmp	.+66     	; 0x7ae <_ZN3NRF7processEv+0x6c>
 76c:	ce 01       	movw	r24, r28
 76e:	0e 94 05 01 	call	0x20a	; 0x20a <_ZN3NRF18waitingForResponseEv>
 772:	88 23       	and	r24, r24
 774:	09 f4       	brne	.+2      	; 0x778 <_ZN3NRF7processEv+0x36>
 776:	ca c0       	rjmp	.+404    	; 0x90c <__stack+0xd>
 778:	1a c0       	rjmp	.+52     	; 0x7ae <_ZN3NRF7processEv+0x6c>
		//load current line of setup msg into TX buffer
		for(int i = 0; i <= setup_msgs[initCount].buffer[0]; i++){
#ifdef PROGRAMSPACE			
			TxData[i] = pgm_read_byte(&setup_msgs[initCount].buffer[i]);
#else
			TxData[i] = setup_msgs[initCount].buffer[i];
 77a:	dc 01       	movw	r26, r24
 77c:	a2 0f       	add	r26, r18
 77e:	b3 1f       	adc	r27, r19
 780:	11 96       	adiw	r26, 0x01	; 1
 782:	6c 91       	ld	r22, X
 784:	61 93       	st	Z+, r22
		
	
	//setup message from services.h file loaded onto nRF8001
	if( (mode == NRF_MODE_SETUP)  && !hasDataToSend() && !waitingForResponse() ) {
		//load current line of setup msg into TX buffer
		for(int i = 0; i <= setup_msgs[initCount].buffer[0]; i++){
 786:	2f 5f       	subi	r18, 0xFF	; 255
 788:	3f 4f       	sbci	r19, 0xFF	; 255
 78a:	42 17       	cp	r20, r18
 78c:	53 07       	cpc	r21, r19
 78e:	ac f7       	brge	.-22     	; 0x77a <_ZN3NRF7processEv+0x38>
			TxData[i] = setup_msgs[initCount].buffer[i];
#endif
		}
		
		//set transmit ready and wait for response flags in status register
		status |= ((1<<NRF_TX_READY));
 790:	9a 8d       	ldd	r25, Y+26	; 0x1a
 792:	90 64       	ori	r25, 0x40	; 64
 794:	9a 8f       	std	Y+26, r25	; 0x1a
		
		initCount++;
 796:	81 e0       	ldi	r24, 0x01	; 1
 798:	87 0f       	add	r24, r23
		////after the last setup message
		if (initCount > NB_SETUP_MESSAGES) 
 79a:	84 31       	cpi	r24, 0x14	; 20
 79c:	18 f4       	brcc	.+6      	; 0x7a4 <_ZN3NRF7processEv+0x62>
		}
		
		//set transmit ready and wait for response flags in status register
		status |= ((1<<NRF_TX_READY));
		
		initCount++;
 79e:	80 93 74 03 	sts	0x0374, r24
 7a2:	05 c0       	rjmp	.+10     	; 0x7ae <_ZN3NRF7processEv+0x6c>
		////after the last setup message
		if (initCount > NB_SETUP_MESSAGES) 
		{
			initCount = 0;
 7a4:	10 92 74 03 	sts	0x0374, r1
			
			clearTxData();
 7a8:	ce 01       	movw	r24, r28
 7aa:	0e 94 3d 01 	call	0x27a	; 0x27a <_ZN3NRF11clearTxDataEv>
}
uint8_t NRF::hasDataToSend(void){
	return ((status & (1<<NRF_TX_READY))?TRUE:FALSE);
}
uint8_t NRF::isReadyToReceiveData(){
	return ((status & (1<<NRF_RX_READY))?TRUE:FALSE);
 7ae:	1a 8d       	ldd	r17, Y+26	; 0x1a
	}//setup message
	
	
	//handle messages received from nRF8001
	//else //testing**************************************************************************************
	if (!isReadyToReceiveData()){
 7b0:	11 23       	and	r17, r17
 7b2:	0c f4       	brge	.+2      	; 0x7b6 <_ZN3NRF7processEv+0x74>
 7b4:	a0 c0       	rjmp	.+320    	; 0x8f6 <_ZN3NRF7processEv+0x1b4>
		RxCount++;
 7b6:	8d 89       	ldd	r24, Y+21	; 0x15
 7b8:	91 e0       	ldi	r25, 0x01	; 1
 7ba:	98 0f       	add	r25, r24
 7bc:	9d 8b       	std	Y+21, r25	; 0x15
				
		switch (RxData[1]){
 7be:	4c 8d       	ldd	r20, Y+28	; 0x1c
 7c0:	50 e0       	ldi	r21, 0x00	; 0
 7c2:	fa 01       	movw	r30, r20
 7c4:	e1 58       	subi	r30, 0x81	; 129
 7c6:	f1 09       	sbc	r31, r1
 7c8:	ef 30       	cpi	r30, 0x0F	; 15
 7ca:	f1 05       	cpc	r31, r1
 7cc:	08 f0       	brcs	.+2      	; 0x7d0 <_ZN3NRF7processEv+0x8e>
 7ce:	8e c0       	rjmp	.+284    	; 0x8ec <_ZN3NRF7processEv+0x1aa>
 7d0:	ee 5a       	subi	r30, 0xAE	; 174
 7d2:	ff 4f       	sbci	r31, 0xFF	; 255
 7d4:	0c 94 b2 06 	jmp	0xd64	; 0xd64 <__tablejump2__>
				//RxData[2]		:	service pipe number
				//RxData[3..23]	:	Data
				
				// Fill data with RxData values
				
				for (i = 0; i< RxData[0] - 1;i++){
 7d8:	5b 8d       	ldd	r21, Y+27	; 0x1b
 7da:	25 2f       	mov	r18, r21
 7dc:	30 e0       	ldi	r19, 0x00	; 0
 7de:	21 50       	subi	r18, 0x01	; 1
 7e0:	31 09       	sbc	r19, r1
 7e2:	12 16       	cp	r1, r18
 7e4:	13 06       	cpc	r1, r19
 7e6:	0c f4       	brge	.+2      	; 0x7ea <_ZN3NRF7processEv+0xa8>
 7e8:	6b c0       	rjmp	.+214    	; 0x8c0 <_ZN3NRF7processEv+0x17e>
 7ea:	78 c0       	rjmp	.+240    	; 0x8dc <_ZN3NRF7processEv+0x19a>
				//					0x02	Setup
				//					0x03	Standby
				//RxData[3]	:	HWError 0x01 = error, 0x00 = no error
				//RxData[4]	:	DataCreditAvailable - Number of DataCommand buffers available
				
				if (RxData[2]>0)
 7ec:	8d 8d       	ldd	r24, Y+29	; 0x1d
 7ee:	88 23       	and	r24, r24
 7f0:	21 f0       	breq	.+8      	; 0x7fa <_ZN3NRF7processEv+0xb8>
					mode = RxData[2];
 7f2:	fe 01       	movw	r30, r28
 7f4:	ef 58       	subi	r30, 0x8F	; 143
 7f6:	ff 4f       	sbci	r31, 0xFF	; 255
 7f8:	80 83       	st	Z, r24
				
				status &= ~(1<<NRF_SLEEPING);
 7fa:	81 2f       	mov	r24, r17
 7fc:	8d 7f       	andi	r24, 0xFD	; 253
 7fe:	8a 8f       	std	Y+26, r24	; 0x1a
				
				//when NRF_CMD_WAKEUP has been called, the NRF_WAIT_FOR_RESPONSE bit in the status register should NOT be cleared
				//when finishing a NRF_CMD_SETUP, the NRF_WAIT_FOR_RESPONSE bit in the status register SHOULD be cleared
				if (mode == NRF_MODE_SETUP){
 800:	fe 01       	movw	r30, r28
 802:	ef 58       	subi	r30, 0x8F	; 143
 804:	ff 4f       	sbci	r31, 0xFF	; 255
 806:	80 81       	ld	r24, Z
 808:	82 30       	cpi	r24, 0x02	; 2
 80a:	19 f4       	brne	.+6      	; 0x812 <_ZN3NRF7processEv+0xd0>
				//if (isInitializing()){
					//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
					status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 80c:	1d 7e       	andi	r17, 0xED	; 237
 80e:	1a 8f       	std	Y+26, r17	; 0x1a
 810:	0a c0       	rjmp	.+20     	; 0x826 <_ZN3NRF7processEv+0xe4>
					
				}
				
				
				if (mode == NRF_MODE_STANDBY){
 812:	83 30       	cpi	r24, 0x03	; 3
 814:	41 f4       	brne	.+16     	; 0x826 <_ZN3NRF7processEv+0xe4>
					//clear the NRF_INIT_MODE bit in the status register when SETUP finishes
					//status &= ~(1<<NRF_INIT_MODE);
					dataCredit = RxData[4];
 816:	8f 8d       	ldd	r24, Y+31	; 0x1f
 818:	fe 01       	movw	r30, r28
 81a:	ee 58       	subi	r30, 0x8E	; 142
 81c:	ff 4f       	sbci	r31, 0xFF	; 255
 81e:	80 83       	st	Z, r24
					status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 820:	8a 8d       	ldd	r24, Y+26	; 0x1a
 822:	8f 7e       	andi	r24, 0xEF	; 239
 824:	8a 8f       	std	Y+26, r24	; 0x1a
				}
				
				
				
				//set the NRF_RX_READY bit in the status register
				status |= (1<<NRF_RX_READY);
 826:	8a 8d       	ldd	r24, Y+26	; 0x1a
 828:	80 68       	ori	r24, 0x80	; 128
 82a:	8a 8f       	std	Y+26, r24	; 0x1a
				
				//TODO: error handling
				break;
 82c:	60 c0       	rjmp	.+192    	; 0x8ee <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_ECHO:				//0x82
				//returns an identical copy of the PDU sent using the echo command in Test Mode
				//RxData[0]	:	length
				//RxData[1]	:	NRF_EVT_ECHO (0x82)
				//RxData[2..31]	:	Identical message to one sent with NRF_CMD_ECHO
				data[0] = RxData[0];
 82e:	8b 8d       	ldd	r24, Y+27	; 0x1b
 830:	88 83       	st	Y, r24
				data[1] = RxData[1];
 832:	82 e8       	ldi	r24, 0x82	; 130
 834:	89 83       	std	Y+1, r24	; 0x01
				data[2] = RxData[2];
 836:	8d 8d       	ldd	r24, Y+29	; 0x1d
 838:	8a 83       	std	Y+2, r24	; 0x02
				data[3] = RxData[3];
 83a:	8e 8d       	ldd	r24, Y+30	; 0x1e
 83c:	8b 83       	std	Y+3, r24	; 0x03
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 83e:	1f 7e       	andi	r17, 0xEF	; 239
 840:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 842:	55 c0       	rjmp	.+170    	; 0x8ee <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_HARDWARE_ERROR:	//0x83
				//provides debug information
				//in case of firmware failure, this event follows NRF_EVT_DEVICE_STARTED
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 844:	1f 7e       	andi	r17, 0xEF	; 239
 846:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 848:	52 c0       	rjmp	.+164    	; 0x8ee <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_COMMAND_RESPONSE:	//0x84
				//confirms reception or execution of an ACI command
				processCommandResponse();				
 84a:	ce 01       	movw	r24, r28
 84c:	0e 94 27 03 	call	0x64e	; 0x64e <_ZN3NRF22processCommandResponseEv>
				break;
 850:	4e c0       	rjmp	.+156    	; 0x8ee <_ZN3NRF7processEv+0x1ac>
				status |= (1<<NRF_CONNECTED);
				
							//do NOT clear the NRF_WAIT_FOR_RESPONSE bit of the status register here
							//there will be either a NRF_EVT_BOND_STATUS or a NRF_EVT_PIPE_STATUS following NRF_EVT_CONNECTED
				//actually it seems to need to be cleared here
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 852:	81 2f       	mov	r24, r17
 854:	8f 7e       	andi	r24, 0xEF	; 239
 856:	88 60       	ori	r24, 0x08	; 8
 858:	8a 8f       	std	Y+26, r24	; 0x1a
				
				break;
 85a:	49 c0       	rjmp	.+146    	; 0x8ee <_ZN3NRF7processEv+0x1ac>
				
				//TODO: can we be still connected if we get here through a failure to bond
				status &= ~(1<<NRF_CONNECTED | 1<<NRF_BONDED);
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 85c:	13 7e       	andi	r17, 0xE3	; 227
 85e:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 860:	46 c0       	rjmp	.+140    	; 0x8ee <_ZN3NRF7processEv+0x1ac>
				//					0x02		: generated by the remote peer.
				//	4		:	BondStatus-SecMode1 - LE Security Mode 1
				//	5		:	LE Security Mode 2
				//	6		:	Keys Exchanged (slave)
				//	7		:	Keys Exchanged (master)
				if (RxData[2] == 0x00){ // successful bond
 862:	8d 8d       	ldd	r24, Y+29	; 0x1d
 864:	81 11       	cpse	r24, r1
 866:	02 c0       	rjmp	.+4      	; 0x86c <_ZN3NRF7processEv+0x12a>
					status |= (1<<NRF_BONDED);
 868:	14 60       	ori	r17, 0x04	; 4
 86a:	1a 8f       	std	Y+26, r17	; 0x1a
				}
				
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 86c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 86e:	8f 7e       	andi	r24, 0xEF	; 239
 870:	8a 8f       	std	Y+26, r24	; 0x1a
				break;
 872:	3d c0       	rjmp	.+122    	; 0x8ee <_ZN3NRF7processEv+0x1ac>
 874:	fe 01       	movw	r30, r28
 876:	ed 59       	subi	r30, 0x9D	; 157
 878:	ff 4f       	sbci	r31, 0xFF	; 255
	//handle messages received from nRF8001
	//else //testing**************************************************************************************
	if (!isReadyToReceiveData()){
		RxCount++;
				
		switch (RxData[1]){
 87a:	80 e0       	ldi	r24, 0x00	; 0
 87c:	df 01       	movw	r26, r30
 87e:	a6 54       	subi	r26, 0x46	; 70
 880:	b1 09       	sbc	r27, r1
				//this event is sent when there is a change in service pipe availability
				//RxData[2..9]		: 64-bit PipesOpen bitmap
				//RxData[10..17]	: 64-bit PipesClosed bitmap
				//see pg 148 of datasheet for details
				for (i = 0 ; i<8; i++){
					pipesOpen[i] = RxData[i+2];
 882:	9c 91       	ld	r25, X
 884:	de 96       	adiw	r26, 0x3e	; 62
 886:	9c 93       	st	X, r25
 888:	d6 97       	sbiw	r26, 0x36	; 54
					pipesClosed[i] = RxData[i+10];
 88a:	9c 91       	ld	r25, X
 88c:	91 93       	st	Z+, r25
			case NRF_EVT_PIPE_STATUS:
				//this event is sent when there is a change in service pipe availability
				//RxData[2..9]		: 64-bit PipesOpen bitmap
				//RxData[10..17]	: 64-bit PipesClosed bitmap
				//see pg 148 of datasheet for details
				for (i = 0 ; i<8; i++){
 88e:	8f 5f       	subi	r24, 0xFF	; 255
 890:	88 30       	cpi	r24, 0x08	; 8
 892:	a1 f7       	brne	.-24     	; 0x87c <_ZN3NRF7processEv+0x13a>
					pipesOpen[i] = RxData[i+2];
					pipesClosed[i] = RxData[i+10];
				}
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 894:	1f 7e       	andi	r17, 0xEF	; 239
 896:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 898:	2a c0       	rjmp	.+84     	; 0x8ee <_ZN3NRF7processEv+0x1ac>
				//RxData[2-3]	: ConnectionInterval (MSB first)
				//RxData[4-5]	: SlaveLatency (LSB/MSB)
				//RxData[6-7]	: SupervisionTimeout (x10ms)
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 89a:	1f 7e       	andi	r17, 0xEF	; 239
 89c:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 89e:	27 c0       	rjmp	.+78     	; 0x8ee <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_DISPLAY_KEY:
				//RxData[2..7] A fixed 6-byte ASCII string representing the passkey
				//padded with zeros if shorter than 6 digits
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 8a0:	1f 7e       	andi	r17, 0xEF	; 239
 8a2:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 8a4:	24 c0       	rjmp	.+72     	; 0x8ee <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_KEY_REQUEST:
				//RxData[2] : key requested
				//must send the SetKey command within 30 seconds after receiving this command
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 8a6:	1f 7e       	andi	r17, 0xEF	; 239
 8a8:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 8aa:	21 c0       	rjmp	.+66     	; 0x8ee <_ZN3NRF7processEv+0x1ac>
			//Data Events:
			case NRF_EVT_DATA_CREDIT:		//0x8A
				//RxData[2]	:	number of data credits returned to the application controller
				dataCredit += RxData[2];	
 8ac:	fe 01       	movw	r30, r28
 8ae:	ee 58       	subi	r30, 0x8E	; 142
 8b0:	ff 4f       	sbci	r31, 0xFF	; 255
 8b2:	9d 8d       	ldd	r25, Y+29	; 0x1d
 8b4:	80 81       	ld	r24, Z
 8b6:	89 0f       	add	r24, r25
 8b8:	80 83       	st	Z, r24
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);			
 8ba:	1f 7e       	andi	r17, 0xEF	; 239
 8bc:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 8be:	17 c0       	rjmp	.+46     	; 0x8ee <_ZN3NRF7processEv+0x1ac>
				//RxData[2]		:	service pipe number
				//RxData[3..23]	:	Data
				
				// Fill data with RxData values
				
				for (i = 0; i< RxData[0] - 1;i++){
 8c0:	80 e0       	ldi	r24, 0x00	; 0
 8c2:	90 e0       	ldi	r25, 0x00	; 0
 8c4:	40 e0       	ldi	r20, 0x00	; 0
					data[i] = RxData[0] + 2;
 8c6:	5e 5f       	subi	r21, 0xFE	; 254
 8c8:	fe 01       	movw	r30, r28
 8ca:	e8 0f       	add	r30, r24
 8cc:	f9 1f       	adc	r31, r25
 8ce:	50 83       	st	Z, r21
				//RxData[2]		:	service pipe number
				//RxData[3..23]	:	Data
				
				// Fill data with RxData values
				
				for (i = 0; i< RxData[0] - 1;i++){
 8d0:	4f 5f       	subi	r20, 0xFF	; 255
 8d2:	84 2f       	mov	r24, r20
 8d4:	90 e0       	ldi	r25, 0x00	; 0
 8d6:	82 17       	cp	r24, r18
 8d8:	93 07       	cpc	r25, r19
 8da:	b4 f3       	brlt	.-20     	; 0x8c8 <_ZN3NRF7processEv+0x186>
				
				//set data flag in status
				status |= (1<<NRF_DATA_TO_PROCESS);
								
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 8dc:	81 2f       	mov	r24, r17
 8de:	8f 7e       	andi	r24, 0xEF	; 239
 8e0:	80 62       	ori	r24, 0x20	; 32
 8e2:	8a 8f       	std	Y+26, r24	; 0x1a
				break;
 8e4:	04 c0       	rjmp	.+8      	; 0x8ee <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_PIPE_ERROR:
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 8e6:	1f 7e       	andi	r17, 0xEF	; 239
 8e8:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 8ea:	01 c0       	rjmp	.+2      	; 0x8ee <_ZN3NRF7processEv+0x1ac>
			default:			
				RxCount--;
 8ec:	8d 8b       	std	Y+21, r24	; 0x15
				//RxData[0] = 0x00;					
				break;
		}//end switch		
		
		//set the NRF_RX_READY bit in the status register
		status |= (1<<NRF_RX_READY);
 8ee:	8a 8d       	ldd	r24, Y+26	; 0x1a
 8f0:	80 68       	ori	r24, 0x80	; 128
 8f2:	8a 8f       	std	Y+26, r24	; 0x1a
 8f4:	20 c0       	rjmp	.+64     	; 0x936 <__stack+0x37>
	else{
		//Receive Buffer doesn't contain useful data
		
		//if nRF8001 is requesting transfer, receive it
		//if we have data to send, send it
		if ((RDYN == 0) || (hasDataToSend())) {			
 8f6:	2a 9b       	sbis	0x05, 2	; 5
 8f8:	05 c0       	rjmp	.+10     	; 0x904 <__stack+0x5>
 8fa:	ce 01       	movw	r24, r28
 8fc:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN3NRF13hasDataToSendEv>
 900:	88 23       	and	r24, r24
 902:	c9 f0       	breq	.+50     	; 0x936 <__stack+0x37>
			transferACI();
 904:	ce 01       	movw	r24, r28
 906:	0e 94 a2 02 	call	0x544	; 0x544 <_ZN3NRF11transferACIEv>
 90a:	15 c0       	rjmp	.+42     	; 0x936 <__stack+0x37>
		
	
	//setup message from services.h file loaded onto nRF8001
	if( (mode == NRF_MODE_SETUP)  && !hasDataToSend() && !waitingForResponse() ) {
		//load current line of setup msg into TX buffer
		for(int i = 0; i <= setup_msgs[initCount].buffer[0]; i++){
 90c:	70 91 74 03 	lds	r23, 0x0374
 910:	61 e2       	ldi	r22, 0x21	; 33
 912:	76 9f       	mul	r23, r22
 914:	f0 01       	movw	r30, r0
 916:	11 24       	eor	r1, r1
 918:	e0 50       	subi	r30, 0x00	; 0
 91a:	ff 4f       	sbci	r31, 0xFF	; 255
 91c:	41 81       	ldd	r20, Z+1	; 0x01
 91e:	50 e0       	ldi	r21, 0x00	; 0
 920:	fe 01       	movw	r30, r28
 922:	fb 96       	adiw	r30, 0x3b	; 59
 924:	20 e0       	ldi	r18, 0x00	; 0
 926:	30 e0       	ldi	r19, 0x00	; 0
#ifdef PROGRAMSPACE			
			TxData[i] = pgm_read_byte(&setup_msgs[initCount].buffer[i]);
#else
			TxData[i] = setup_msgs[initCount].buffer[i];
 928:	61 e2       	ldi	r22, 0x21	; 33
 92a:	76 9f       	mul	r23, r22
 92c:	c0 01       	movw	r24, r0
 92e:	11 24       	eor	r1, r1
 930:	80 50       	subi	r24, 0x00	; 0
 932:	9f 4f       	sbci	r25, 0xFF	; 255
 934:	22 cf       	rjmp	.-444    	; 0x77a <_ZN3NRF7processEv+0x38>
		if ((RDYN == 0) || (hasDataToSend())) {			
			transferACI();
			
		}
	}//else RxData
}//process
 936:	df 91       	pop	r29
 938:	cf 91       	pop	r28
 93a:	1f 91       	pop	r17
 93c:	08 95       	ret

0000093e <_GLOBAL__sub_I_spi>:
	//(1<<MSTR)|             // Master/Slave select
	//(0<<SPR1)|(1<<SPR0)|   // SPI Clock Rate
	//(0<<CPOL)|             // Clock Polarity (0:SCK low / 1:SCK hi when idle)
	//(0<<CPHA))             // Clock Phase (0:leading / 1:trailing edge sampling)

SPI spi(SPI_SETTING);
 93e:	63 e7       	ldi	r22, 0x73	; 115
 940:	85 e7       	ldi	r24, 0x75	; 117
 942:	93 e0       	ldi	r25, 0x03	; 3
 944:	0e 94 da 00 	call	0x1b4	; 0x1b4 <_ZN3SPIC1Eh>
 948:	08 95       	ret

0000094a <_ZN6TIMER1C1Ehhj>:
TIMER1::TIMER1(){
	TIMER1(TIMER_DIV1, 0, 0);
}

///@brief initialize AD converter on Atmega168 for
TIMER1::TIMER1(uint8_t pscalar, uint8_t WGMmode, uint16_t rload){
 94a:	fc 01       	movw	r30, r24
	reload = rload;
 94c:	33 83       	std	Z+3, r19	; 0x03
 94e:	22 83       	std	Z+2, r18	; 0x02
	mode = WGMmode;
 950:	41 83       	std	Z+1, r20	; 0x01
	prescalar = pscalar;
 952:	60 83       	st	Z, r22
	
	// The PRTIM1 bit in the Power reduction register must be written to zero to enable Timer/Counter1 module.
	PRR &= ~(1<<PRTIM1);
 954:	a4 e6       	ldi	r26, 0x64	; 100
 956:	b0 e0       	ldi	r27, 0x00	; 0
 958:	8c 91       	ld	r24, X
 95a:	87 7f       	andi	r24, 0xF7	; 247
 95c:	8c 93       	st	X, r24
	
	//disable timer1
	TCCR1B = 0x00;
 95e:	10 92 81 00 	sts	0x0081, r1
	
	//clear counter	
	TCNT1 = 0;
 962:	10 92 85 00 	sts	0x0085, r1
 966:	10 92 84 00 	sts	0x0084, r1
	
	//set reload value
	if (mode == 4) OCR1A = reload;
 96a:	81 81       	ldd	r24, Z+1	; 0x01
 96c:	84 30       	cpi	r24, 0x04	; 4
 96e:	31 f4       	brne	.+12     	; 0x97c <_ZN6TIMER1C1Ehhj+0x32>
 970:	82 81       	ldd	r24, Z+2	; 0x02
 972:	93 81       	ldd	r25, Z+3	; 0x03
 974:	90 93 89 00 	sts	0x0089, r25
 978:	80 93 88 00 	sts	0x0088, r24
	if (mode == 12) ICR1 = reload;
 97c:	81 81       	ldd	r24, Z+1	; 0x01
 97e:	8c 30       	cpi	r24, 0x0C	; 12
 980:	31 f4       	brne	.+12     	; 0x98e <_ZN6TIMER1C1Ehhj+0x44>
 982:	82 81       	ldd	r24, Z+2	; 0x02
 984:	93 81       	ldd	r25, Z+3	; 0x03
 986:	90 93 87 00 	sts	0x0087, r25
 98a:	80 93 86 00 	sts	0x0086, r24
	if (mode == 0) TCNT1 = reload;
 98e:	81 81       	ldd	r24, Z+1	; 0x01
 990:	81 11       	cpse	r24, r1
 992:	06 c0       	rjmp	.+12     	; 0x9a0 <_ZN6TIMER1C1Ehhj+0x56>
 994:	82 81       	ldd	r24, Z+2	; 0x02
 996:	93 81       	ldd	r25, Z+3	; 0x03
 998:	90 93 85 00 	sts	0x0085, r25
 99c:	80 93 84 00 	sts	0x0084, r24
	
	//setup and enable timer
	TCCR1A = (mode & 0x03);		//normal timer operation, no PWM, etc
 9a0:	81 81       	ldd	r24, Z+1	; 0x01
 9a2:	83 70       	andi	r24, 0x03	; 3
 9a4:	80 93 80 00 	sts	0x0080, r24
	//TCCR1B = ((mode & 0x0C)<<WGM12) | (prescalar << CS10);
	TCCR1C = 0x00;		//force output compare off	
 9a8:	10 92 82 00 	sts	0x0082, r1
 9ac:	08 95       	ret

000009ae <_ZN6TIMER15startEv>:
	//sei();
}

void	TIMER1::start(void)
{
	TCCR1B = ((mode & 0x0C)<<WGM12) | (prescalar << CS10);
 9ae:	fc 01       	movw	r30, r24
 9b0:	21 81       	ldd	r18, Z+1	; 0x01
 9b2:	2c 70       	andi	r18, 0x0C	; 12
 9b4:	22 0f       	add	r18, r18
 9b6:	22 0f       	add	r18, r18
 9b8:	22 0f       	add	r18, r18
 9ba:	90 81       	ld	r25, Z
 9bc:	82 2f       	mov	r24, r18
 9be:	89 2b       	or	r24, r25
 9c0:	80 93 81 00 	sts	0x0081, r24
 9c4:	08 95       	ret

000009c6 <_ZN6TIMER117isCompareAFlagSetEv>:
	return ((TIFR1 & 1<<TOV1)? 1:0);
	//return ((EIFR & 1<< INTF0)?1:0);
}

uint8_t TIMER1::isCompareAFlagSet(){
	return ((TIFR1 & 1<<OCF1A)? 1:0);
 9c6:	86 b3       	in	r24, 0x16	; 22
	
}
 9c8:	86 95       	lsr	r24
 9ca:	81 70       	andi	r24, 0x01	; 1
 9cc:	08 95       	ret

000009ce <_ZN6TIMER117clearCompareAFlagEv>:
	
	//EIFR = (1<<INTF0);		//Reset flag
}

void	TIMER1::clearCompareAFlag(){
	TIFR1 |= (1<<OCF1A);
 9ce:	b1 9a       	sbi	0x16, 1	; 22
 9d0:	08 95       	ret

000009d2 <_ZN6TIMER18setCountEj>:
	
	//EIFR = (1<<INTF0);		//Reset flag
}

void	TIMER1::setCount(uint16_t count){
	TCNT1 = count;
 9d2:	70 93 85 00 	sts	0x0085, r23
 9d6:	60 93 84 00 	sts	0x0084, r22
 9da:	08 95       	ret

000009dc <main>:
//  3. SLEEP;
//	4. After waking, DisableSleep()

#pragma endregion sleep

int main(void){	
 9dc:	cf 93       	push	r28
 9de:	df 93       	push	r29
 9e0:	cd b7       	in	r28, 0x3d	; 61
 9e2:	de b7       	in	r29, 0x3e	; 62
 9e4:	2e 97       	sbiw	r28, 0x0e	; 14
 9e6:	0f b6       	in	r0, 0x3f	; 63
 9e8:	f8 94       	cli
 9ea:	de bf       	out	0x3e, r29	; 62
 9ec:	0f be       	out	0x3f, r0	; 63
 9ee:	cd bf       	out	0x3d, r28	; 61
	//timer
	// 8MHz/90Hz			= 88,888.8888 cycles to count
	// 88,888.888 / 8 (div8)	= 11,111 = 0x2B67	
	//prescalar, mode, reload
	TIMER1 timer(TIMER_DIV8, 4, 0x2B67);
 9f0:	27 e6       	ldi	r18, 0x67	; 103
 9f2:	3b e2       	ldi	r19, 0x2B	; 43
 9f4:	44 e0       	ldi	r20, 0x04	; 4
 9f6:	62 e0       	ldi	r22, 0x02	; 2
 9f8:	ce 01       	movw	r24, r28
 9fa:	08 96       	adiw	r24, 0x08	; 8
 9fc:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN6TIMER1C1Ehhj>
	
	//pin, prescalar
	ANALOG sensor(ADC_PIN, ADC_DIV64);
 a00:	46 e0       	ldi	r20, 0x06	; 6
 a02:	60 e0       	ldi	r22, 0x00	; 0
 a04:	ce 01       	movw	r24, r28
 a06:	0c 96       	adiw	r24, 0x0c	; 12
 a08:	0e 94 b2 00 	call	0x164	; 0x164 <_ZN6ANALOGC1Ehh>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 a0c:	2f ef       	ldi	r18, 0xFF	; 255
 a0e:	84 e3       	ldi	r24, 0x34	; 52
 a10:	9c e0       	ldi	r25, 0x0C	; 12
 a12:	21 50       	subi	r18, 0x01	; 1
 a14:	80 40       	sbci	r24, 0x00	; 0
 a16:	90 40       	sbci	r25, 0x00	; 0
 a18:	e1 f7       	brne	.-8      	; 0xa12 <main+0x36>
 a1a:	00 c0       	rjmp	.+0      	; 0xa1c <main+0x40>
 a1c:	00 00       	nop
	//////////////////////////////////////////////////////////////////////////
#endif
	
	_delay_ms(500);	
	//d6,d7 - LEDs
	DDRD = 0xE0;			//set PD7:6 to outputs for LEDs
 a1e:	80 ee       	ldi	r24, 0xE0	; 224
 a20:	8a b9       	out	0x0a, r24	; 10
	//PD2 as an input for switch
	RED_ON;					//Set PD7 high and PD6 low
 a22:	55 98       	cbi	0x0a, 5	; 10
 a24:	89 b1       	in	r24, 0x09	; 9
 a26:	8f 73       	andi	r24, 0x3F	; 63
 a28:	80 68       	ori	r24, 0x80	; 128
 a2a:	8b b9       	out	0x0b, r24	; 11
	//while (1);
	//Switch
	PORTD = (1<<PD2);		//set PD2 to high(pullup resistor) for switch
 a2c:	84 e0       	ldi	r24, 0x04	; 4
 a2e:	8b b9       	out	0x0b, r24	; 11
	
	//External Interrupt Mask Register
	EIMSK |= (1<<INT0);	//turn on interrupt 0 (PD2)
 a30:	e8 9a       	sbi	0x1d, 0	; 29
	
	////External Interrupt Control Register A
	//EICRA = 0x02;		//Interrupt on falling edge of INT0
	EICRA = 0x00;		//Interrupt on low level of INT0
 a32:	10 92 69 00 	sts	0x0069, r1
	
	//opamp is Powered Down when PD is low, initialize HIGH
	//250nS delay when powering up, 50nS delay when powering down (1/8MHz = 125nS)
	WakeOpAmp();
 a36:	41 9a       	sbi	0x08, 1	; 8
	sensor.clearFlag();
 a38:	ce 01       	movw	r24, r28
 a3a:	0c 96       	adiw	r24, 0x0c	; 12
 a3c:	0e 94 c7 00 	call	0x18e	; 0x18e <_ZN6ANALOG9clearFlagEv>
 a40:	ef ef       	ldi	r30, 0xFF	; 255
 a42:	f4 e3       	ldi	r31, 0x34	; 52
 a44:	2c e0       	ldi	r18, 0x0C	; 12
 a46:	e1 50       	subi	r30, 0x01	; 1
 a48:	f0 40       	sbci	r31, 0x00	; 0
 a4a:	20 40       	sbci	r18, 0x00	; 0
 a4c:	e1 f7       	brne	.-8      	; 0xa46 <main+0x6a>
 a4e:	00 c0       	rjmp	.+0      	; 0xa50 <main+0x74>
 a50:	00 00       	nop
		
	_delay_ms(500);
#ifdef TESTMODE	
	lcdClearDisplay();
#endif	
	RED_ON; //TESTING
 a52:	55 98       	cbi	0x0a, 5	; 10
 a54:	89 b1       	in	r24, 0x09	; 9
 a56:	8f 73       	andi	r24, 0x3F	; 63
 a58:	80 68       	ori	r24, 0x80	; 128
 a5a:	8b b9       	out	0x0b, r24	; 11
	state_t state = INIT;
	uint8_t oxygenSaturationData[PIPE_OXYGEN_SATURATION_O2_SET_MAX_SIZE];// = {0,1,2,3,4,5,6};
	uint8_t count = 0;
	uint8_t readCount = 0;	//keeps track of how many times the ADC is read before it is averaged
	uint16_t readSum = 0;	//sums up the ADC values
	uint8_t settings = 0x00;	//settings is updated from the Bluetooth, so the Android device can
 a5c:	b1 2c       	mov	r11, r1
	ANALOG sensor(ADC_PIN, ADC_DIV64);
	
	enum state_t {INIT = 0x00, CONNECT, CONNECTING, SEND, RECEIVE, IDLE, GO2SLEEP, WAKEUP, WAKING};
	enum lights_t {I,R,O} led_state = R;
		 
	state_t state = INIT;
 a5e:	a1 2c       	mov	r10, r1
	
	//pin, prescalar
	ANALOG sensor(ADC_PIN, ADC_DIV64);
	
	enum state_t {INIT = 0x00, CONNECT, CONNECTING, SEND, RECEIVE, IDLE, GO2SLEEP, WAKEUP, WAKING};
	enum lights_t {I,R,O} led_state = R;
 a60:	81 e0       	ldi	r24, 0x01	; 1
 a62:	8e 87       	std	Y+14, r24	; 0x0e
			if (nrf.data[0] == PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX){
				settings = nrf.data[1];				
			}
			nrf.dataHasBeenProcessed();
			if (settings == PULSEOX_GO_TO_SLEEP)
				state = GO2SLEEP;
 a64:	0f 2e       	mov	r0, r31
 a66:	f6 e0       	ldi	r31, 0x06	; 6
 a68:	9f 2e       	mov	r9, r31
 a6a:	f0 2d       	mov	r31, r0
	RED_ON; //TESTING
	
	while(1){		
		if (nrf.hasDataToProcess()){
			if (nrf.data[0] == PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX){
				settings = nrf.data[1];				
 a6c:	0f 2e       	mov	r0, r31
 a6e:	f8 e7       	ldi	r31, 0x78	; 120
 a70:	ef 2e       	mov	r14, r31
 a72:	f3 e0       	ldi	r31, 0x03	; 3
 a74:	ff 2e       	mov	r15, r31
 a76:	f0 2d       	mov	r31, r0
				state = GO2SLEEP;
		}
		
		//here we change the device's state to sleep or wakeup with a button press
		//the Bluetooth module's operational state is NRF_MODE_STANDBY
		if (nrf.mode == NRF_MODE_STANDBY){			
 a78:	08 ee       	ldi	r16, 0xE8	; 232
 a7a:	13 e0       	ldi	r17, 0x03	; 3
 a7c:	0f 2e       	mov	r0, r31
 a7e:	f7 e0       	ldi	r31, 0x07	; 7
 a80:	8f 2e       	mov	r8, r31
 a82:	f0 2d       	mov	r31, r0
						//nrf.wakeup();
					//}
					
					if (nrf.isSleeping()){
						//clear up any remnants from when we went to sleep
						nrf.status = (1<<NRF_RX_READY | 1<<NRF_SLEEPING);
 a84:	0f 2e       	mov	r0, r31
 a86:	f1 e9       	ldi	r31, 0x91	; 145
 a88:	cf 2e       	mov	r12, r31
 a8a:	f3 e0       	ldi	r31, 0x03	; 3
 a8c:	df 2e       	mov	r13, r31
 a8e:	f0 2d       	mov	r31, r0
 a90:	0f 2e       	mov	r0, r31
 a92:	f2 e8       	ldi	r31, 0x82	; 130
 a94:	6f 2e       	mov	r6, r31
 a96:	f0 2d       	mov	r31, r0
						nrf.wakeup();	
						state = WAKING;					
 a98:	68 94       	set
 a9a:	77 24       	eor	r7, r7
 a9c:	73 f8       	bld	r7, 3
#define SLEEP_MODE_STANDBY		0b110
#define EnableSleep() 			SMCR |= (1<<SE)
#define DisableSleep()			SMCR &= ~(1<<SE)
void SetSleepMode(uint8_t mode){
	if((mode == SLEEP_MODE_STANDBY) | (mode<=SLEEP_MODE_POWER_SAVE))
	SMCR = (mode<<SM0);
 a9e:	68 94       	set
 aa0:	55 24       	eor	r5, r5
 aa2:	52 f8       	bld	r5, 2
							sensor.start();
 						}//if
 					
 						if (sensor.isInterruptFlagSet()){
							sensor.clearFlag();
							readSum += ADC;
 aa4:	0f 2e       	mov	r0, r31
 aa6:	f8 e7       	ldi	r31, 0x78	; 120
 aa8:	2f 2e       	mov	r2, r31
 aaa:	31 2c       	mov	r3, r1
 aac:	f0 2d       	mov	r31, r0
										oxygenSaturationData[6*count+1] = readSum >> 8;
										IR_ON;
										led_state = I;
										if (++count == NUM_QUEUE){
											count = 0;
											state = SEND;
 aae:	0f 2e       	mov	r0, r31
 ab0:	f3 e0       	ldi	r31, 0x03	; 3
 ab2:	4f 2e       	mov	r4, r31
 ab4:	f0 2d       	mov	r31, r0
	lcdClearDisplay();
#endif	
	RED_ON; //TESTING
	
	while(1){		
		if (nrf.hasDataToProcess()){
 ab6:	87 e7       	ldi	r24, 0x77	; 119
 ab8:	93 e0       	ldi	r25, 0x03	; 3
 aba:	0e 94 10 01 	call	0x220	; 0x220 <_ZN3NRF16hasDataToProcessEv>
 abe:	88 23       	and	r24, r24
 ac0:	71 f0       	breq	.+28     	; 0xade <main+0x102>
			if (nrf.data[0] == PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX){
 ac2:	80 91 77 03 	lds	r24, 0x0377
 ac6:	82 30       	cpi	r24, 0x02	; 2
 ac8:	11 f4       	brne	.+4      	; 0xace <main+0xf2>
				settings = nrf.data[1];				
 aca:	f7 01       	movw	r30, r14
 acc:	b0 80       	ld	r11, Z
			}
			nrf.dataHasBeenProcessed();
 ace:	87 e7       	ldi	r24, 0x77	; 119
 ad0:	93 e0       	ldi	r25, 0x03	; 3
 ad2:	0e 94 16 01 	call	0x22c	; 0x22c <_ZN3NRF20dataHasBeenProcessedEv>
			if (settings == PULSEOX_GO_TO_SLEEP)
 ad6:	f1 e0       	ldi	r31, 0x01	; 1
 ad8:	bf 12       	cpse	r11, r31
 ada:	01 c0       	rjmp	.+2      	; 0xade <main+0x102>
				state = GO2SLEEP;
 adc:	a9 2c       	mov	r10, r9
		}
		
		//here we change the device's state to sleep or wakeup with a button press
		//the Bluetooth module's operational state is NRF_MODE_STANDBY
		if (nrf.mode == NRF_MODE_STANDBY){			
 ade:	f8 01       	movw	r30, r16
 ae0:	80 81       	ld	r24, Z
 ae2:	83 30       	cpi	r24, 0x03	; 3
 ae4:	09 f0       	breq	.+2      	; 0xae8 <main+0x10c>
 ae6:	11 c1       	rjmp	.+546    	; 0xd0a <main+0x32e>
			if(buttonWasPressed){
 ae8:	80 91 76 03 	lds	r24, 0x0376
 aec:	88 23       	and	r24, r24
 aee:	31 f0       	breq	.+12     	; 0xafc <main+0x120>
				buttonWasPressed = false;
 af0:	10 92 76 03 	sts	0x0376, r1
				//RED_ON; //testing
				if (state == GO2SLEEP){					
 af4:	f6 e0       	ldi	r31, 0x06	; 6
 af6:	af 12       	cpse	r10, r31
 af8:	a1 c0       	rjmp	.+322    	; 0xc3c <main+0x260>
 afa:	d3 c0       	rjmp	.+422    	; 0xca2 <main+0x2c6>
				}else{				
					state = GO2SLEEP;
				}
			}
			
			switch (state){
 afc:	8a 2d       	mov	r24, r10
 afe:	90 e0       	ldi	r25, 0x00	; 0
 b00:	89 30       	cpi	r24, 0x09	; 9
 b02:	91 05       	cpc	r25, r1
 b04:	08 f0       	brcs	.+2      	; 0xb08 <main+0x12c>
 b06:	01 c1       	rjmp	.+514    	; 0xd0a <main+0x32e>
 b08:	fc 01       	movw	r30, r24
 b0a:	ef 59       	subi	r30, 0x9F	; 159
 b0c:	ff 4f       	sbci	r31, 0xFF	; 255
 b0e:	0c 94 b2 06 	jmp	0xd64	; 0xd64 <__tablejump2__>
				//INIT state is entered into upon bootup,
				//this is where the Bluetooth initialization instructions are
				//sent to the module
				case INIT:	//initializing
					if (!nrf.isInitializing()){
 b12:	87 e7       	ldi	r24, 0x77	; 119
 b14:	93 e0       	ldi	r25, 0x03	; 3
 b16:	0e 94 f6 00 	call	0x1ec	; 0x1ec <_ZN3NRF14isInitializingEv>
 b1a:	81 11       	cpse	r24, r1
 b1c:	f6 c0       	rjmp	.+492    	; 0xd0a <main+0x32e>
						timer.start();
 b1e:	ce 01       	movw	r24, r28
 b20:	08 96       	adiw	r24, 0x08	; 8
 b22:	0e 94 d7 04 	call	0x9ae	; 0x9ae <_ZN6TIMER15startEv>
						sei();	
 b26:	78 94       	sei
						RED_ON;		
 b28:	55 98       	cbi	0x0a, 5	; 10
 b2a:	89 b1       	in	r24, 0x09	; 9
 b2c:	8f 73       	andi	r24, 0x3F	; 63
 b2e:	80 68       	ori	r24, 0x80	; 128
 b30:	8b b9       	out	0x0b, r24	; 11
						//this will put it to sleep the first time it boots up	
						//state = GO2SLEEP;		//FINAL PRODUCT	
						
						//this will go straight into connect mode upon boot			
						state = CONNECT;		//TESTING			
 b32:	aa 24       	eor	r10, r10
 b34:	a3 94       	inc	r10
 b36:	e9 c0       	rjmp	.+466    	; 0xd0a <main+0x32e>
					//_delay_ms(25);
#endif
					break;				
				//	CONNECT state is used to send the connect command to the BT Module
				case CONNECT:
				RED_ON;	
 b38:	55 98       	cbi	0x0a, 5	; 10
 b3a:	89 b1       	in	r24, 0x09	; 9
 b3c:	8f 73       	andi	r24, 0x3F	; 63
 b3e:	80 68       	ori	r24, 0x80	; 128
 b40:	8b b9       	out	0x0b, r24	; 11
					if (nrf.connect(180,0x0100) == 0x00)
 b42:	40 e0       	ldi	r20, 0x00	; 0
 b44:	51 e0       	ldi	r21, 0x01	; 1
 b46:	64 eb       	ldi	r22, 0xB4	; 180
 b48:	70 e0       	ldi	r23, 0x00	; 0
 b4a:	87 e7       	ldi	r24, 0x77	; 119
 b4c:	93 e0       	ldi	r25, 0x03	; 3
 b4e:	0e 94 63 02 	call	0x4c6	; 0x4c6 <_ZN3NRF7connectEjj>
 b52:	88 23       	and	r24, r24
 b54:	09 f4       	brne	.+2      	; 0xb58 <main+0x17c>
 b56:	c4 c0       	rjmp	.+392    	; 0xce0 <main+0x304>
 b58:	d8 c0       	rjmp	.+432    	; 0xd0a <main+0x32e>
						state = CONNECTING;
					break;				
				// CONNECTING state is used to wait until the BT module connects
				case CONNECTING:	
					if (nrf.isConnected())
 b5a:	87 e7       	ldi	r24, 0x77	; 119
 b5c:	93 e0       	ldi	r25, 0x03	; 3
 b5e:	0e 94 0a 01 	call	0x214	; 0x214 <_ZN3NRF11isConnectedEv>
 b62:	81 11       	cpse	r24, r1
 b64:	c1 c0       	rjmp	.+386    	; 0xce8 <main+0x30c>
 b66:	d1 c0       	rjmp	.+418    	; 0xd0a <main+0x32e>
						state = IDLE;
					break;
				
				// SEND state sends the ADC values to the BT module	
				case SEND:					
					if (0x00 == nrf.setLocalData(PIPE_OXYGEN_SATURATION_O2_SET, oxygenSaturationData, PIPE_OXYGEN_SATURATION_O2_SET_MAX_SIZE)){						
 b68:	28 2d       	mov	r18, r8
 b6a:	ae 01       	movw	r20, r28
 b6c:	4f 5f       	subi	r20, 0xFF	; 255
 b6e:	5f 4f       	sbci	r21, 0xFF	; 255
 b70:	61 e0       	ldi	r22, 0x01	; 1
 b72:	87 e7       	ldi	r24, 0x77	; 119
 b74:	93 e0       	ldi	r25, 0x03	; 3
 b76:	0e 94 1b 02 	call	0x436	; 0x436 <_ZN3NRF12setLocalDataEhPhh>
 b7a:	81 11       	cpse	r24, r1
 b7c:	c6 c0       	rjmp	.+396    	; 0xd0a <main+0x32e>
						oxygenSaturationData[0]++;									
 b7e:	89 81       	ldd	r24, Y+1	; 0x01
 b80:	8f 5f       	subi	r24, 0xFF	; 255
 b82:	89 83       	std	Y+1, r24	; 0x01
						state = IDLE;	
 b84:	0f 2e       	mov	r0, r31
 b86:	f5 e0       	ldi	r31, 0x05	; 5
 b88:	af 2e       	mov	r10, r31
 b8a:	f0 2d       	mov	r31, r0
 b8c:	be c0       	rjmp	.+380    	; 0xd0a <main+0x32e>
					}					
					break;
				
				//RECEIVE state is used to receive the settings back from the Android device
				case RECEIVE:
					nrf.requestData(PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX);   
 b8e:	62 e0       	ldi	r22, 0x02	; 2
 b90:	87 e7       	ldi	r24, 0x77	; 119
 b92:	93 e0       	ldi	r25, 0x03	; 3
 b94:	0e 94 aa 01 	call	0x354	; 0x354 <_ZN3NRF11requestDataEh>
					state = IDLE;
 b98:	0f 2e       	mov	r0, r31
 b9a:	f5 e0       	ldi	r31, 0x05	; 5
 b9c:	af 2e       	mov	r10, r31
 b9e:	f0 2d       	mov	r31, r0
					break;	
 ba0:	b4 c0       	rjmp	.+360    	; 0xd0a <main+0x32e>
								
				//IDLE is where the ADC is read and averaged												
				case IDLE:		//idle
					if(!nrf.isConnected()){
 ba2:	87 e7       	ldi	r24, 0x77	; 119
 ba4:	93 e0       	ldi	r25, 0x03	; 3
 ba6:	0e 94 0a 01 	call	0x214	; 0x214 <_ZN3NRF11isConnectedEv>
 baa:	88 23       	and	r24, r24
 bac:	09 f4       	brne	.+2      	; 0xbb0 <main+0x1d4>
 bae:	a1 c0       	rjmp	.+322    	; 0xcf2 <main+0x316>
						state = GO2SLEEP;
					}else {
						if (timer.isCompareAFlagSet()){
 bb0:	ce 01       	movw	r24, r28
 bb2:	08 96       	adiw	r24, 0x08	; 8
 bb4:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <_ZN6TIMER117isCompareAFlagSetEv>
 bb8:	88 23       	and	r24, r24
 bba:	71 f0       	breq	.+28     	; 0xbd8 <main+0x1fc>
							timer.clearCompareAFlag();
 bbc:	ce 01       	movw	r24, r28
 bbe:	08 96       	adiw	r24, 0x08	; 8
 bc0:	0e 94 e7 04 	call	0x9ce	; 0x9ce <_ZN6TIMER117clearCompareAFlagEv>
							timer.setCount(0);
 bc4:	60 e0       	ldi	r22, 0x00	; 0
 bc6:	70 e0       	ldi	r23, 0x00	; 0
 bc8:	ce 01       	movw	r24, r28
 bca:	08 96       	adiw	r24, 0x08	; 8
 bcc:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <_ZN6TIMER18setCountEj>
							sensor.start();
 bd0:	ce 01       	movw	r24, r28
 bd2:	0c 96       	adiw	r24, 0x0c	; 12
 bd4:	0e 94 b8 00 	call	0x170	; 0x170 <_ZN6ANALOG5startEv>
 						}//if
 					
 						if (sensor.isInterruptFlagSet()){
 bd8:	ce 01       	movw	r24, r28
 bda:	0c 96       	adiw	r24, 0x0c	; 12
 bdc:	0e 94 c3 00 	call	0x186	; 0x186 <_ZN6ANALOG18isInterruptFlagSetEv>
 be0:	88 23       	and	r24, r24
 be2:	09 f4       	brne	.+2      	; 0xbe6 <main+0x20a>
 be4:	92 c0       	rjmp	.+292    	; 0xd0a <main+0x32e>
							sensor.clearFlag();
 be6:	ce 01       	movw	r24, r28
 be8:	0c 96       	adiw	r24, 0x0c	; 12
 bea:	0e 94 c7 00 	call	0x18e	; 0x18e <_ZN6ANALOG9clearFlagEv>
							readSum += ADC;
 bee:	f1 01       	movw	r30, r2
 bf0:	80 81       	ld	r24, Z
 bf2:	91 81       	ldd	r25, Z+1	; 0x01
							if (++readCount == 1<<SAMPLE_ORDER){
								readSum>>=SAMPLE_ORDER;
								switch(led_state){
 bf4:	fe 85       	ldd	r31, Y+14	; 0x0e
 bf6:	f1 30       	cpi	r31, 0x01	; 1
 bf8:	b9 f0       	breq	.+46     	; 0xc28 <main+0x24c>
 bfa:	18 f0       	brcs	.+6      	; 0xc02 <main+0x226>
 bfc:	f2 30       	cpi	r31, 0x02	; 2
 bfe:	51 f0       	breq	.+20     	; 0xc14 <main+0x238>
 c00:	84 c0       	rjmp	.+264    	; 0xd0a <main+0x32e>
									case I:
										oxygenSaturationData[6*count+4] = readSum & 0xFF;
 c02:	8d 83       	std	Y+5, r24	; 0x05
										oxygenSaturationData[6*count+3] = readSum >> 8;
 c04:	9c 83       	std	Y+4, r25	; 0x04
										LEDS_OFF;
 c06:	55 98       	cbi	0x0a, 5	; 10
 c08:	89 b1       	in	r24, 0x09	; 9
 c0a:	8f 71       	andi	r24, 0x1F	; 31
 c0c:	8b b9       	out	0x0b, r24	; 11
										led_state = O;
 c0e:	22 e0       	ldi	r18, 0x02	; 2
 c10:	2e 87       	std	Y+14, r18	; 0x0e
										break;
 c12:	7b c0       	rjmp	.+246    	; 0xd0a <main+0x32e>
									case O:
										oxygenSaturationData[6*count+6] = readSum & 0xFF;
 c14:	8f 83       	std	Y+7, r24	; 0x07
										oxygenSaturationData[6*count+5] = readSum >> 8;
 c16:	9e 83       	std	Y+6, r25	; 0x06
										RED_ON;
 c18:	55 98       	cbi	0x0a, 5	; 10
 c1a:	89 b1       	in	r24, 0x09	; 9
 c1c:	8f 73       	andi	r24, 0x3F	; 63
 c1e:	80 68       	ori	r24, 0x80	; 128
 c20:	8b b9       	out	0x0b, r24	; 11
										led_state = R;
 c22:	81 e0       	ldi	r24, 0x01	; 1
 c24:	8e 87       	std	Y+14, r24	; 0x0e
										break;
 c26:	71 c0       	rjmp	.+226    	; 0xd0a <main+0x32e>
									case R:
										oxygenSaturationData[6*count+2] = readSum & 0xFF;
 c28:	8b 83       	std	Y+3, r24	; 0x03
										oxygenSaturationData[6*count+1] = readSum >> 8;
 c2a:	9a 83       	std	Y+2, r25	; 0x02
										IR_ON;
 c2c:	55 9a       	sbi	0x0a, 5	; 10
 c2e:	89 b1       	in	r24, 0x09	; 9
 c30:	8f 71       	andi	r24, 0x1F	; 31
 c32:	80 66       	ori	r24, 0x60	; 96
 c34:	8b b9       	out	0x0b, r24	; 11
										led_state = I;
										if (++count == NUM_QUEUE){
											count = 0;
											state = SEND;
 c36:	a4 2c       	mov	r10, r4
										break;
									case R:
										oxygenSaturationData[6*count+2] = readSum & 0xFF;
										oxygenSaturationData[6*count+1] = readSum >> 8;
										IR_ON;
										led_state = I;
 c38:	1e 86       	std	Y+14, r1	; 0x0e
 c3a:	67 c0       	rjmp	.+206    	; 0xd0a <main+0x32e>
					break;
					
				//Nighty night, little PulseOx don't let the bed bugs bite time to sip some current 
				//and save some battery. No more gulpin' down those milliamps.
				case GO2SLEEP:
					SleepOpAmp();
 c3c:	41 98       	cbi	0x08, 1	; 8
					//disconnect
					if (nrf.isConnected())
 c3e:	87 e7       	ldi	r24, 0x77	; 119
 c40:	93 e0       	ldi	r25, 0x03	; 3
 c42:	0e 94 0a 01 	call	0x214	; 0x214 <_ZN3NRF11isConnectedEv>
 c46:	88 23       	and	r24, r24
 c48:	29 f0       	breq	.+10     	; 0xc54 <main+0x278>
						nrf.disconnect(0x01);
 c4a:	61 e0       	ldi	r22, 0x01	; 1
 c4c:	87 e7       	ldi	r24, 0x77	; 119
 c4e:	93 e0       	ldi	r25, 0x03	; 3
 c50:	0e 94 99 01 	call	0x332	; 0x332 <_ZN3NRF10disconnectEh>
					
					if (!nrf.isConnected()){
 c54:	87 e7       	ldi	r24, 0x77	; 119
 c56:	93 e0       	ldi	r25, 0x03	; 3
 c58:	0e 94 0a 01 	call	0x214	; 0x214 <_ZN3NRF11isConnectedEv>
 c5c:	81 11       	cpse	r24, r1
 c5e:	4b c0       	rjmp	.+150    	; 0xcf6 <main+0x31a>
						//put nrf to sleep
						if (!nrf.isSleeping()){
 c60:	87 e7       	ldi	r24, 0x77	; 119
 c62:	93 e0       	ldi	r25, 0x03	; 3
 c64:	0e 94 1b 01 	call	0x236	; 0x236 <_ZN3NRF10isSleepingEv>
 c68:	81 11       	cpse	r24, r1
 c6a:	04 c0       	rjmp	.+8      	; 0xc74 <main+0x298>
							nrf.sleep();
 c6c:	87 e7       	ldi	r24, 0x77	; 119
 c6e:	93 e0       	ldi	r25, 0x03	; 3
 c70:	0e 94 57 02 	call	0x4ae	; 0x4ae <_ZN3NRF5sleepEv>
						}																
						
						if (nrf.isSleeping() && !nrf.hasDataToSend()){							
 c74:	87 e7       	ldi	r24, 0x77	; 119
 c76:	93 e0       	ldi	r25, 0x03	; 3
 c78:	0e 94 1b 01 	call	0x236	; 0x236 <_ZN3NRF10isSleepingEv>
 c7c:	88 23       	and	r24, r24
 c7e:	e9 f1       	breq	.+122    	; 0xcfa <main+0x31e>
 c80:	87 e7       	ldi	r24, 0x77	; 119
 c82:	93 e0       	ldi	r25, 0x03	; 3
 c84:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN3NRF13hasDataToSendEv>
 c88:	81 11       	cpse	r24, r1
 c8a:	39 c0       	rjmp	.+114    	; 0xcfe <main+0x322>
							LEDS_OFF;
 c8c:	55 98       	cbi	0x0a, 5	; 10
 c8e:	89 b1       	in	r24, 0x09	; 9
 c90:	8f 71       	andi	r24, 0x1F	; 31
 c92:	8b b9       	out	0x0b, r24	; 11
#define SLEEP_MODE_STANDBY		0b110
#define EnableSleep() 			SMCR |= (1<<SE)
#define DisableSleep()			SMCR &= ~(1<<SE)
void SetSleepMode(uint8_t mode){
	if((mode == SLEEP_MODE_STANDBY) | (mode<=SLEEP_MODE_POWER_SAVE))
	SMCR = (mode<<SM0);
 c94:	53 be       	out	0x33, r5	; 51
						
						if (nrf.isSleeping() && !nrf.hasDataToSend()){							
							LEDS_OFF;
							//put uC to sleep							
  							SetSleepMode(SLEEP_MODE_POWER_DOWN);
  							EnableSleep();
 c96:	83 b7       	in	r24, 0x33	; 51
 c98:	81 60       	ori	r24, 0x01	; 1
 c9a:	83 bf       	out	0x33, r24	; 51
  							__asm__ __volatile__ ("sleep" ::);
 c9c:	88 95       	sleep
 c9e:	a9 2c       	mov	r10, r9
 ca0:	34 c0       	rjmp	.+104    	; 0xd0a <main+0x32e>
					break;
					
				//good morning, Dear, did you sleep well?
				//fire the op amp and BT module back up
				case WAKEUP:
					DisableSleep();					
 ca2:	83 b7       	in	r24, 0x33	; 51
 ca4:	8e 7f       	andi	r24, 0xFE	; 254
 ca6:	83 bf       	out	0x33, r24	; 51
					
					//wakeup opamp
					WakeOpAmp();
 ca8:	41 9a       	sbi	0x08, 1	; 8
					//wakeup nrf
					//if (nrf.isSleeping() && !nrf.hasDataToSend()){
						//nrf.wakeup();
					//}
					
					if (nrf.isSleeping()){
 caa:	87 e7       	ldi	r24, 0x77	; 119
 cac:	93 e0       	ldi	r25, 0x03	; 3
 cae:	0e 94 1b 01 	call	0x236	; 0x236 <_ZN3NRF10isSleepingEv>
 cb2:	88 23       	and	r24, r24
 cb4:	31 f1       	breq	.+76     	; 0xd02 <main+0x326>
						//clear up any remnants from when we went to sleep
						nrf.status = (1<<NRF_RX_READY | 1<<NRF_SLEEPING);
 cb6:	f6 01       	movw	r30, r12
 cb8:	60 82       	st	Z, r6
						nrf.wakeup();	
 cba:	87 e7       	ldi	r24, 0x77	; 119
 cbc:	93 e0       	ldi	r25, 0x03	; 3
 cbe:	0e 94 5f 02 	call	0x4be	; 0x4be <_ZN3NRF6wakeupEv>
						state = WAKING;					
 cc2:	a7 2c       	mov	r10, r7
 cc4:	22 c0       	rjmp	.+68     	; 0xd0a <main+0x32e>
					}
					break;
				case WAKING:
					
					if (!nrf.isSleeping() && !nrf.hasDataToSend()){						
 cc6:	87 e7       	ldi	r24, 0x77	; 119
 cc8:	93 e0       	ldi	r25, 0x03	; 3
 cca:	0e 94 1b 01 	call	0x236	; 0x236 <_ZN3NRF10isSleepingEv>
 cce:	81 11       	cpse	r24, r1
 cd0:	1c c0       	rjmp	.+56     	; 0xd0a <main+0x32e>
 cd2:	87 e7       	ldi	r24, 0x77	; 119
 cd4:	93 e0       	ldi	r25, 0x03	; 3
 cd6:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_ZN3NRF13hasDataToSendEv>
 cda:	88 23       	and	r24, r24
 cdc:	a1 f0       	breq	.+40     	; 0xd06 <main+0x32a>
 cde:	15 c0       	rjmp	.+42     	; 0xd0a <main+0x32e>
					break;				
				//	CONNECT state is used to send the connect command to the BT Module
				case CONNECT:
				RED_ON;	
					if (nrf.connect(180,0x0100) == 0x00)
						state = CONNECTING;
 ce0:	68 94       	set
 ce2:	aa 24       	eor	r10, r10
 ce4:	a1 f8       	bld	r10, 1
 ce6:	11 c0       	rjmp	.+34     	; 0xd0a <main+0x32e>
					break;				
				// CONNECTING state is used to wait until the BT module connects
				case CONNECTING:	
					if (nrf.isConnected())
						state = IDLE;
 ce8:	0f 2e       	mov	r0, r31
 cea:	f5 e0       	ldi	r31, 0x05	; 5
 cec:	af 2e       	mov	r10, r31
 cee:	f0 2d       	mov	r31, r0
 cf0:	0c c0       	rjmp	.+24     	; 0xd0a <main+0x32e>
					break;	
								
				//IDLE is where the ADC is read and averaged												
				case IDLE:		//idle
					if(!nrf.isConnected()){
						state = GO2SLEEP;
 cf2:	a9 2c       	mov	r10, r9
 cf4:	0a c0       	rjmp	.+20     	; 0xd0a <main+0x32e>
 cf6:	a9 2c       	mov	r10, r9
 cf8:	08 c0       	rjmp	.+16     	; 0xd0a <main+0x32e>
 cfa:	a9 2c       	mov	r10, r9
 cfc:	06 c0       	rjmp	.+12     	; 0xd0a <main+0x32e>
 cfe:	a9 2c       	mov	r10, r9
 d00:	04 c0       	rjmp	.+8      	; 0xd0a <main+0x32e>
 d02:	a8 2c       	mov	r10, r8
 d04:	02 c0       	rjmp	.+4      	; 0xd0a <main+0x32e>
					}
					break;
				case WAKING:
					
					if (!nrf.isSleeping() && !nrf.hasDataToSend()){						
						state = CONNECT;
 d06:	aa 24       	eor	r10, r10
 d08:	a3 94       	inc	r10
		//display
		//sprintf(line1, " %02X%02X %02X %02X%02X ", nrf.RxCount, nrf.dataCredit, state, nrf.status, nrf.mode);
		sprintf(line2, "%02X%02X %02X %02X%02X ", nrf.RxCount, /*nrf.dataCredit,*/ state, nrf.status, nrf.mode, nrf.lastCommand);
		displayLCD();
#else
		if (nrf.mode == NRF_MODE_SETUP)
 d0a:	f8 01       	movw	r30, r16
 d0c:	80 81       	ld	r24, Z
 d0e:	82 30       	cpi	r24, 0x02	; 2
 d10:	31 f4       	brne	.+12     	; 0xd1e <main+0x342>
 d12:	8f e2       	ldi	r24, 0x2F	; 47
 d14:	95 e7       	ldi	r25, 0x75	; 117
 d16:	01 97       	sbiw	r24, 0x01	; 1
 d18:	f1 f7       	brne	.-4      	; 0xd16 <main+0x33a>
 d1a:	00 c0       	rjmp	.+0      	; 0xd1c <main+0x340>
 d1c:	00 00       	nop
			_delay_ms(15);
#endif			
		nrf.process();		
 d1e:	87 e7       	ldi	r24, 0x77	; 119
 d20:	93 e0       	ldi	r25, 0x03	; 3
 d22:	0e 94 a1 03 	call	0x742	; 0x742 <_ZN3NRF7processEv>
	}//while 1
 d26:	c7 ce       	rjmp	.-626    	; 0xab6 <main+0xda>

00000d28 <__vector_1>:
}//main


//interrupt on button press
ISR(INT0_vect){
 d28:	1f 92       	push	r1
 d2a:	0f 92       	push	r0
 d2c:	0f b6       	in	r0, 0x3f	; 63
 d2e:	0f 92       	push	r0
 d30:	11 24       	eor	r1, r1
 d32:	8f 93       	push	r24
 d34:	9f 93       	push	r25
 d36:	8f e0       	ldi	r24, 0x0F	; 15
 d38:	97 e2       	ldi	r25, 0x27	; 39
 d3a:	01 97       	sbiw	r24, 0x01	; 1
 d3c:	f1 f7       	brne	.-4      	; 0xd3a <__vector_1+0x12>
 d3e:	00 c0       	rjmp	.+0      	; 0xd40 <__vector_1+0x18>
 d40:	00 00       	nop
	//to debounce switch, wait 5ms, then check for low condition again
	_delay_ms(5);
	if (!(PIND & (1<<PD2)))
 d42:	4a 99       	sbic	0x09, 2	; 9
 d44:	03 c0       	rjmp	.+6      	; 0xd4c <__vector_1+0x24>
	buttonWasPressed = true;
 d46:	81 e0       	ldi	r24, 0x01	; 1
 d48:	80 93 76 03 	sts	0x0376, r24
	
}
 d4c:	9f 91       	pop	r25
 d4e:	8f 91       	pop	r24
 d50:	0f 90       	pop	r0
 d52:	0f be       	out	0x3f, r0	; 63
 d54:	0f 90       	pop	r0
 d56:	1f 90       	pop	r1
 d58:	18 95       	reti

00000d5a <_GLOBAL__sub_I_nrf>:

//size of pipe in settings.h sets size of queue, which is how many times we read
//the data before we send
#define NUM_QUEUE ((PIPE_OXYGEN_SATURATION_O2_SET_MAX_SIZE-1)/6)
#define SAMPLE_ORDER 0
NRF nrf;
 d5a:	87 e7       	ldi	r24, 0x77	; 119
 d5c:	93 e0       	ldi	r25, 0x03	; 3
 d5e:	0e 94 2f 01 	call	0x25e	; 0x25e <_ZN3NRFC1Ev>
 d62:	08 95       	ret

00000d64 <__tablejump2__>:
 d64:	ee 0f       	add	r30, r30
 d66:	ff 1f       	adc	r31, r31

00000d68 <__tablejump__>:
 d68:	05 90       	lpm	r0, Z+
 d6a:	f4 91       	lpm	r31, Z
 d6c:	e0 2d       	mov	r30, r0
 d6e:	09 94       	ijmp

00000d70 <_exit>:
 d70:	f8 94       	cli

00000d72 <__stop_program>:
 d72:	ff cf       	rjmp	.-2      	; 0xd72 <__stop_program>
