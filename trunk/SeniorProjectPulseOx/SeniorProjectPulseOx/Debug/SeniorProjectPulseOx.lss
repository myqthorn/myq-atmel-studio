
SeniorProjectPulseOx.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000274  00800100  00000d84  00000e18  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000d84  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000077  00800374  00800374  0000108c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000108c  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000328  00000000  00000000  000010bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00004291  00000000  00000000  000013e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000b4b  00000000  00000000  00005675  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000d1a  00000000  00000000  000061c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000007ec  00000000  00000000  00006edc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000013a0  00000000  00000000  000076c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000253f  00000000  00000000  00008a68  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000308  00000000  00000000  0000afa7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__ctors_end>
   4:	0c 94 9c 06 	jmp	0xd38	; 0xd38 <__vector_1>
   8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
   c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  14:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  18:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  1c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  2c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  30:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  34:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  44:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  54:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  64:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  68:	35 03       	mulsu	r19, r21
  6a:	39 03       	fmul	r19, r17
  6c:	3d 03       	fmul	r19, r21
  6e:	41 03       	mulsu	r20, r17
  70:	45 03       	mulsu	r20, r21
  72:	49 03       	fmul	r20, r17
  74:	53 03       	mulsu	r21, r19
  76:	57 03       	mulsu	r21, r23
  78:	5b 03       	fmul	r21, r19
  7a:	63 03       	mulsu	r22, r19
  7c:	67 03       	mulsu	r22, r23
  7e:	6b 03       	fmul	r22, r19
  80:	9d 03       	fmulsu	r17, r21
  82:	7e 03       	fmul	r23, r22
  84:	9d 03       	fmulsu	r17, r21
  86:	9d 03       	fmulsu	r17, r21
  88:	9d 03       	fmulsu	r17, r21
  8a:	82 03       	fmuls	r16, r18
  8c:	9d 03       	fmulsu	r17, r21
  8e:	9d 03       	fmulsu	r17, r21
  90:	9d 03       	fmulsu	r17, r21
  92:	9d 03       	fmulsu	r17, r21
  94:	9d 03       	fmulsu	r17, r21
  96:	9d 03       	fmulsu	r17, r21
  98:	86 03       	fmuls	r16, r22
  9a:	8a 03       	fmulsu	r16, r18
  9c:	8e 03       	fmulsu	r16, r22
  9e:	92 03       	fmuls	r17, r18
  a0:	96 03       	fmuls	r17, r22
  a2:	9a 03       	fmulsu	r17, r18
  a4:	f5 03       	fmuls	r23, r21
  a6:	16 04       	cpc	r1, r6
  a8:	21 04       	cpc	r2, r1
  aa:	24 04       	cpc	r2, r4
  ac:	28 04       	cpc	r2, r8
  ae:	2d 04       	cpc	r2, r13
  b0:	30 04       	cpc	r3, r0
  b2:	39 04       	cpc	r3, r9
  b4:	4c 04       	cpc	r4, r12
  b6:	55 04       	cpc	r5, r5
  b8:	76 04       	cpc	r7, r6
  ba:	eb 03       	fmulsu	r22, r19
  bc:	72 04       	cpc	r7, r2
  be:	4f 04       	cpc	r4, r15
  c0:	52 04       	cpc	r5, r2
  c2:	86 05       	cpc	r24, r6
  c4:	98 05       	cpc	r25, r8
  c6:	a4 05       	cpc	r26, r4
  c8:	ab 05       	cpc	r26, r11
  ca:	be 05       	cpc	r27, r14
  cc:	c8 05       	cpc	r28, r8
  ce:	23 06       	cpc	r2, r19
  d0:	57 06       	cpc	r5, r23

000000d2 <__ctors_start>:
  d2:	9e 04       	cpc	r9, r14
  d4:	b5 06       	cpc	r11, r21

000000d6 <__ctors_end>:
  d6:	11 24       	eor	r1, r1
  d8:	1f be       	out	0x3f, r1	; 63
  da:	cf ef       	ldi	r28, 0xFF	; 255
  dc:	d8 e0       	ldi	r29, 0x08	; 8
  de:	de bf       	out	0x3e, r29	; 62
  e0:	cd bf       	out	0x3d, r28	; 61

000000e2 <__do_copy_data>:
  e2:	13 e0       	ldi	r17, 0x03	; 3
  e4:	a0 e0       	ldi	r26, 0x00	; 0
  e6:	b1 e0       	ldi	r27, 0x01	; 1
  e8:	e4 e8       	ldi	r30, 0x84	; 132
  ea:	fd e0       	ldi	r31, 0x0D	; 13
  ec:	02 c0       	rjmp	.+4      	; 0xf2 <__do_copy_data+0x10>
  ee:	05 90       	lpm	r0, Z+
  f0:	0d 92       	st	X+, r0
  f2:	a4 37       	cpi	r26, 0x74	; 116
  f4:	b1 07       	cpc	r27, r17
  f6:	d9 f7       	brne	.-10     	; 0xee <__do_copy_data+0xc>

000000f8 <__do_clear_bss>:
  f8:	23 e0       	ldi	r18, 0x03	; 3
  fa:	a4 e7       	ldi	r26, 0x74	; 116
  fc:	b3 e0       	ldi	r27, 0x03	; 3
  fe:	01 c0       	rjmp	.+2      	; 0x102 <.do_clear_bss_start>

00000100 <.do_clear_bss_loop>:
 100:	1d 92       	st	X+, r1

00000102 <.do_clear_bss_start>:
 102:	ab 3e       	cpi	r26, 0xEB	; 235
 104:	b2 07       	cpc	r27, r18
 106:	e1 f7       	brne	.-8      	; 0x100 <.do_clear_bss_loop>

00000108 <__do_global_ctors>:
 108:	10 e0       	ldi	r17, 0x00	; 0
 10a:	c6 ed       	ldi	r28, 0xD6	; 214
 10c:	d0 e0       	ldi	r29, 0x00	; 0
 10e:	04 c0       	rjmp	.+8      	; 0x118 <__do_global_ctors+0x10>
 110:	22 97       	sbiw	r28, 0x02	; 2
 112:	fe 01       	movw	r30, r28
 114:	0e 94 bc 06 	call	0xd78	; 0xd78 <__tablejump__>
 118:	c2 3d       	cpi	r28, 0xD2	; 210
 11a:	d1 07       	cpc	r29, r17
 11c:	c9 f7       	brne	.-14     	; 0x110 <__do_global_ctors+0x8>
 11e:	0e 94 ed 04 	call	0x9da	; 0x9da <main>
 122:	0c 94 c0 06 	jmp	0xd80	; 0xd80 <_exit>

00000126 <__bad_interrupt>:
 126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <_ZN6ANALOG12reinitializeEv>:
	
}

void ANALOG::reinitialize(){
	//Power reduction ADC bit must be zero to enable ADC
	PRR &= ~(1<<PRADC);
 12a:	e4 e6       	ldi	r30, 0x64	; 100
 12c:	f0 e0       	ldi	r31, 0x00	; 0
 12e:	20 81       	ld	r18, Z
 130:	2e 7f       	andi	r18, 0xFE	; 254
 132:	20 83       	st	Z, r18
	
	
	//ADC clock needs to be between 50kHz and 200kHz
	//8MHz/64 = 125kHz
	ADCSRA = (1<<ADEN | prescalar<<ADPS0);
 134:	dc 01       	movw	r26, r24
 136:	11 96       	adiw	r26, 0x01	; 1
 138:	2c 91       	ld	r18, X
 13a:	11 97       	sbiw	r26, 0x01	; 1
 13c:	20 68       	ori	r18, 0x80	; 128
 13e:	20 93 7a 00 	sts	0x007A, r18
	
	//Disable the digital input for the ADC channel we will be using
	DIDR0 |= (1<<channel);
 142:	ee e7       	ldi	r30, 0x7E	; 126
 144:	f0 e0       	ldi	r31, 0x00	; 0
 146:	40 81       	ld	r20, Z
 148:	21 e0       	ldi	r18, 0x01	; 1
 14a:	30 e0       	ldi	r19, 0x00	; 0
 14c:	b9 01       	movw	r22, r18
 14e:	0c 90       	ld	r0, X
 150:	02 c0       	rjmp	.+4      	; 0x156 <_ZN6ANALOG12reinitializeEv+0x2c>
 152:	66 0f       	add	r22, r22
 154:	77 1f       	adc	r23, r23
 156:	0a 94       	dec	r0
 158:	e2 f7       	brpl	.-8      	; 0x152 <_ZN6ANALOG12reinitializeEv+0x28>
 15a:	cb 01       	movw	r24, r22
 15c:	84 2b       	or	r24, r20
 15e:	80 83       	st	Z, r24
 160:	08 95       	ret

00000162 <_ZN6ANALOGC1Ehh>:
	reinitialize();
}

//@brief initialize AD converter on Atmega168 for
ANALOG::ANALOG(uint8_t ch, uint8_t pscalar){
	channel = ch;
 162:	fc 01       	movw	r30, r24
 164:	60 83       	st	Z, r22
	prescalar = pscalar;
 166:	41 83       	std	Z+1, r20	; 0x01
	reinitialize();
 168:	0e 94 95 00 	call	0x12a	; 0x12a <_ZN6ANALOG12reinitializeEv>
 16c:	08 95       	ret

0000016e <_ZN6ANALOG5startEv>:
	return (ADC);
}

void ANALOG::start(){
	//set ADC channel
	ADMUX = (1<<REFS0) | channel;
 16e:	fc 01       	movw	r30, r24
 170:	80 81       	ld	r24, Z
 172:	80 64       	ori	r24, 0x40	; 64
 174:	80 93 7c 00 	sts	0x007C, r24
	
	//start conversion
	ADCSRA |= (1<<ADSC);
 178:	ea e7       	ldi	r30, 0x7A	; 122
 17a:	f0 e0       	ldi	r31, 0x00	; 0
 17c:	80 81       	ld	r24, Z
 17e:	80 64       	ori	r24, 0x40	; 64
 180:	80 83       	st	Z, r24
 182:	08 95       	ret

00000184 <_ZN6ANALOG18isInterruptFlagSetEv>:
uint8_t ANALOG::isReading(){
	return (ADCSRA & (1<<ADSC));	
}

uint8_t	ANALOG::isInterruptFlagSet(){
	return(ADCSRA & (1<<ADIF));
 184:	80 91 7a 00 	lds	r24, 0x007A
}
 188:	80 71       	andi	r24, 0x10	; 16
 18a:	08 95       	ret

0000018c <_ZN6ANALOG9clearFlagEv>:

void ANALOG::clearFlag(){
	//clear interrupt by setting ADIF to 1
	ADCSRA |= (1<<ADIF);
 18c:	ea e7       	ldi	r30, 0x7A	; 122
 18e:	f0 e0       	ldi	r31, 0x00	; 0
 190:	80 81       	ld	r24, Z
 192:	80 61       	ori	r24, 0x10	; 16
 194:	80 83       	st	Z, r24
 196:	08 95       	ret

00000198 <_ZN3SPI4initEh>:
		init(SPCRvalue);
	}
	void SPI::init(uint8_t SPCRvalue)
	// Initialize pins for spi communication
	{
		DDR_SPI &= ~((1<<DD_MOSI)|(1<<DD_MISO)|(1<<DD_SS)|(1<<DD_SCK));
 198:	84 b1       	in	r24, 0x04	; 4
 19a:	83 7c       	andi	r24, 0xC3	; 195
 19c:	84 b9       	out	0x04, r24	; 4
		// Define the following pins as output
		DDR_SPI |= ((1<<DD_MOSI)|(1<<DD_SS)|(1<<DD_SCK));
 19e:	84 b1       	in	r24, 0x04	; 4
 1a0:	8c 62       	ori	r24, 0x2C	; 44
 1a2:	84 b9       	out	0x04, r24	; 4

		if (SPCRvalue == 0x00){
 1a4:	61 11       	cpse	r22, r1
 1a6:	03 c0       	rjmp	.+6      	; 0x1ae <_ZN3SPI4initEh+0x16>
			(0<<SPIE)|              // SPI Interrupt Enable
			(0<<DORD)|              // Data Order (0:MSB first / 1:LSB first)
			(1<<MSTR)|              // Master/Slave select
			(0<<SPR1)|(1<<SPR0)|    // SPI Clock Rate
			(0<<CPOL)|              // Clock Polarity (0:SCK low / 1:SCK hi when idle)
			(0<<CPHA));             // Clock Phase (0:leading / 1:trailing edge sampling)
 1a8:	81 e5       	ldi	r24, 0x51	; 81
 1aa:	8c bd       	out	0x2c, r24	; 44
 1ac:	08 95       	ret
		}
		else SPCR = SPCRvalue;
 1ae:	6c bd       	out	0x2c, r22	; 44
 1b0:	08 95       	ret

000001b2 <_ZN3SPIC1Eh>:
	
	SPI::SPI(){
		init(0x00);
	}
	SPI::SPI(uint8_t SPCRvalue){
		init(SPCRvalue);
 1b2:	0e 94 cc 00 	call	0x198	; 0x198 <_ZN3SPI4initEh>
 1b6:	08 95       	ret

000001b8 <_ZN3SPI8transferEPhS0_h>:
	
	void SPI::transfer (uint8_t * dataout, uint8_t * datain, uint8_t length)
	// Shift full array through target device
	{
		uint8_t i;
		for (i = 0; i < length; i++) {
 1b8:	22 23       	and	r18, r18
 1ba:	81 f0       	breq	.+32     	; 0x1dc <_ZN3SPI8transferEPhS0_h+0x24>
 1bc:	96 2f       	mov	r25, r22
 1be:	a4 2f       	mov	r26, r20
 1c0:	b5 2f       	mov	r27, r21
 1c2:	e6 2f       	mov	r30, r22
 1c4:	f7 2f       	mov	r31, r23
			SPDR = dataout[i];
 1c6:	81 91       	ld	r24, Z+
 1c8:	8e bd       	out	0x2e, r24	; 46
			while((SPSR & (1<<SPIF))==0);
 1ca:	0d b4       	in	r0, 0x2d	; 45
 1cc:	07 fe       	sbrs	r0, 7
 1ce:	fd cf       	rjmp	.-6      	; 0x1ca <_ZN3SPI8transferEPhS0_h+0x12>
			datain[i] = SPDR;
 1d0:	8e b5       	in	r24, 0x2e	; 46
 1d2:	8d 93       	st	X+, r24
 1d4:	8e 2f       	mov	r24, r30
 1d6:	89 1b       	sub	r24, r25
	
	void SPI::transfer (uint8_t * dataout, uint8_t * datain, uint8_t length)
	// Shift full array through target device
	{
		uint8_t i;
		for (i = 0; i < length; i++) {
 1d8:	82 17       	cp	r24, r18
 1da:	a8 f3       	brcs	.-22     	; 0x1c6 <_ZN3SPI8transferEPhS0_h+0xe>
 1dc:	08 95       	ret

000001de <_ZN3SPI13transfer1byteEh>:
	}
	
	uint8_t SPI::transfer1byte (uint8_t dataout)
	// Clocks only one byte to target device and returns the received one
	{
		SPDR = dataout;
 1de:	6e bd       	out	0x2e, r22	; 46
		while((SPSR & (1<<SPIF))==0);
 1e0:	0d b4       	in	r0, 0x2d	; 45
 1e2:	07 fe       	sbrs	r0, 7
 1e4:	fd cf       	rjmp	.-6      	; 0x1e0 <_ZN3SPI13transfer1byteEh+0x2>
		return SPDR;
 1e6:	8e b5       	in	r24, 0x2e	; 46
	}
 1e8:	08 95       	ret

000001ea <_ZN3NRF14isInitializingEv>:
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 1ea:	fc 01       	movw	r30, r24
 1ec:	ef 58       	subi	r30, 0x8F	; 143
 1ee:	ff 4f       	sbci	r31, 0xFF	; 255
 1f0:	81 e0       	ldi	r24, 0x01	; 1
 1f2:	90 81       	ld	r25, Z
 1f4:	92 30       	cpi	r25, 0x02	; 2
 1f6:	09 f0       	breq	.+2      	; 0x1fa <_ZN3NRF14isInitializingEv+0x10>
 1f8:	80 e0       	ldi	r24, 0x00	; 0
}
 1fa:	08 95       	ret

000001fc <_ZN3NRF13hasDataToSendEv>:
uint8_t NRF::hasDataToSend(void){
	return ((status & (1<<NRF_TX_READY))?TRUE:FALSE);
 1fc:	fc 01       	movw	r30, r24
 1fe:	82 8d       	ldd	r24, Z+26	; 0x1a
}
 200:	86 fb       	bst	r24, 6
 202:	88 27       	eor	r24, r24
 204:	80 f9       	bld	r24, 0
 206:	08 95       	ret

00000208 <_ZN3NRF18waitingForResponseEv>:
uint8_t NRF::isReadyToReceiveData(){
	return ((status & (1<<NRF_RX_READY))?TRUE:FALSE);
}
uint8_t NRF::waitingForResponse(void){
	return ((status & (1<<NRF_WAIT_FOR_RESPONSE))?TRUE:FALSE);
 208:	fc 01       	movw	r30, r24
 20a:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
 20c:	82 95       	swap	r24
 20e:	81 70       	andi	r24, 0x01	; 1
 210:	08 95       	ret

00000212 <_ZN3NRF11isConnectedEv>:
uint8_t NRF::isConnected(void){
	return ((status & (1<<NRF_CONNECTED))?TRUE:FALSE);
 212:	fc 01       	movw	r30, r24
 214:	82 8d       	ldd	r24, Z+26	; 0x1a
}	
 216:	83 fb       	bst	r24, 3
 218:	88 27       	eor	r24, r24
 21a:	80 f9       	bld	r24, 0
 21c:	08 95       	ret

0000021e <_ZN3NRF16hasDataToProcessEv>:
uint8_t NRF::isBonded(void){
	return ((status & (1<<NRF_BONDED))?TRUE:FALSE);	
}
uint8_t NRF::hasDataToProcess(void){
	return ((status & (1<<NRF_DATA_TO_PROCESS))?TRUE:FALSE);
 21e:	fc 01       	movw	r30, r24
 220:	82 8d       	ldd	r24, Z+26	; 0x1a
}
 222:	85 fb       	bst	r24, 5
 224:	88 27       	eor	r24, r24
 226:	80 f9       	bld	r24, 0
 228:	08 95       	ret

0000022a <_ZN3NRF20dataHasBeenProcessedEv>:
void	NRF::dataHasBeenProcessed(void){
	status &= ~(1<<NRF_DATA_TO_PROCESS);
 22a:	fc 01       	movw	r30, r24
 22c:	22 8d       	ldd	r18, Z+26	; 0x1a
 22e:	2f 7d       	andi	r18, 0xDF	; 223
 230:	22 8f       	std	Z+26, r18	; 0x1a
 232:	08 95       	ret

00000234 <_ZN3NRF10isSleepingEv>:
}
uint8_t NRF::isSleeping(void){
	return ((status & (1<<NRF_SLEEPING))?TRUE:FALSE);
 234:	fc 01       	movw	r30, r24
 236:	82 8d       	ldd	r24, Z+26	; 0x1a
}
 238:	86 95       	lsr	r24
 23a:	81 70       	andi	r24, 0x01	; 1
 23c:	08 95       	ret

0000023e <_ZN3NRF15isSystemCommandEh>:
uint8_t	NRF::isSystemCommand(uint8_t command){
	return ((	command == NRF_CMD_SET_LOCAL_DATA	||
		command == NRF_CMD_SEND_DATA		||
		command == NRF_CMD_SEND_DATA_ACK	||
		command == NRF_CMD_REQUEST_DATA		||
		command == NRF_CMD_SEND_DATA_NACK	 )	? FALSE: TRUE);
 23e:	6d 30       	cpi	r22, 0x0D	; 13
 240:	31 f0       	breq	.+12     	; 0x24e <_ZN3NRF15isSystemCommandEh+0x10>
	return ((status & (1<<NRF_SLEEPING))?TRUE:FALSE);
}
#pragma endregion Status Functions

uint8_t	NRF::isSystemCommand(uint8_t command){
	return ((	command == NRF_CMD_SET_LOCAL_DATA	||
 242:	65 51       	subi	r22, 0x15	; 21
 244:	81 e0       	ldi	r24, 0x01	; 1
 246:	64 30       	cpi	r22, 0x04	; 4
 248:	18 f4       	brcc	.+6      	; 0x250 <_ZN3NRF15isSystemCommandEh+0x12>
 24a:	80 e0       	ldi	r24, 0x00	; 0
 24c:	08 95       	ret
		command == NRF_CMD_SEND_DATA		||
		command == NRF_CMD_SEND_DATA_ACK	||
		command == NRF_CMD_REQUEST_DATA		||
		command == NRF_CMD_SEND_DATA_NACK	 )	? FALSE: TRUE);
 24e:	80 e0       	ldi	r24, 0x00	; 0
}
 250:	08 95       	ret

00000252 <_ZN3NRF4initEv>:
}


void NRF::init(){
	//ACT and RDYN set as inputs	
	ACT_DDR &= ~(1<<ACT_PIN);	
 252:	20 98       	cbi	0x04, 0	; 4
	RDYN_DDR &= ~(1<<RDYN_PIN);
 254:	22 98       	cbi	0x04, 2	; 4
	
	//REQN set as output
	REQN_DDR |= (1<<REQN_PIN);
 256:	21 9a       	sbi	0x04, 1	; 4
	//////DON'T KNOW WHY THIS IS CAUSING A PROBLEM********************************************************
	//set pullup on RDYN
	//RDYN_PORT |= (1<<RDYN_PIN);
	
	//REQN is active low, so initialize it HIGH
	SetREQN();
 258:	29 9a       	sbi	0x05, 1	; 5
 25a:	08 95       	ret

0000025c <_ZN3NRFC1Ev>:

//uint8_t initCodes[12][32];
static uint8_t initCount = 0;

//NRF::NRF(hal_aci_data_t *message){
NRF::NRF(){
 25c:	cf 93       	push	r28
 25e:	df 93       	push	r29
 260:	ec 01       	movw	r28, r24
	//msg = message;
	
	init();
 262:	0e 94 29 01 	call	0x252	; 0x252 <_ZN3NRF4initEv>
	RxCount = 0x00;
 266:	1d 8a       	std	Y+21, r1	; 0x15
	temperature = 0x00;
 268:	1f 8a       	std	Y+23, r1	; 0x17
 26a:	1e 8a       	std	Y+22, r1	; 0x16
	//mode = 0x00;
	//set to INIT_MODE and RX_READY
	//we are waiting for a NRF_EVT_DEVICE_STARTED in NRF_MODE_SETUP
	//status |= (1<<NRF_RX_READY | 1<<NRF_INIT_MODE | 1<<NRF_WAIT_FOR_RESPONSE);
	status |= (1<<NRF_RX_READY | 1<<NRF_WAIT_FOR_RESPONSE);
 26c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 26e:	80 69       	ori	r24, 0x90	; 144
 270:	8a 8f       	std	Y+26, r24	; 0x1a
}
 272:	df 91       	pop	r29
 274:	cf 91       	pop	r28
 276:	08 95       	ret

00000278 <_ZN3NRF11clearTxDataEv>:
		}
		
	}//else if(RDYN == 0)	
	
}//transferACI()
void NRF::clearTxData(){
 278:	fc 01       	movw	r30, r24
 27a:	fb 96       	adiw	r30, 0x3b	; 59
	for(int i = 0; i<32; i++) 
 27c:	20 e0       	ldi	r18, 0x00	; 0
 27e:	30 e0       	ldi	r19, 0x00	; 0
		TxData[i] = 0x00;		
 280:	11 92       	st	Z+, r1
		
	}//else if(RDYN == 0)	
	
}//transferACI()
void NRF::clearTxData(){
	for(int i = 0; i<32; i++) 
 282:	2f 5f       	subi	r18, 0xFF	; 255
 284:	3f 4f       	sbci	r19, 0xFF	; 255
 286:	20 32       	cpi	r18, 0x20	; 32
 288:	31 05       	cpc	r19, r1
 28a:	d1 f7       	brne	.-12     	; 0x280 <_ZN3NRF11clearTxDataEv+0x8>
		TxData[i] = 0x00;		
}
 28c:	08 95       	ret

0000028e <_ZN3NRF13PrepareTxDataEhPhh>:
///@brief Send data from uC to nRF8001
///@param command
///@param data
///@param length Length of data
///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::PrepareTxData(uint8_t command, uint8_t *data, uint8_t length){
 28e:	ef 92       	push	r14
 290:	ff 92       	push	r15
 292:	0f 93       	push	r16
 294:	1f 93       	push	r17
 296:	cf 93       	push	r28
 298:	df 93       	push	r29
 29a:	ec 01       	movw	r28, r24
 29c:	16 2f       	mov	r17, r22
 29e:	e4 2e       	mov	r14, r20
 2a0:	f5 2e       	mov	r15, r21
 2a2:	02 2f       	mov	r16, r18
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 2a4:	fc 01       	movw	r30, r24
 2a6:	ef 58       	subi	r30, 0x8F	; 143
 2a8:	ff 4f       	sbci	r31, 0xFF	; 255
///@param length Length of data
///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::PrepareTxData(uint8_t command, uint8_t *data, uint8_t length){
	//TODO: write this function
	int i;
	if (isInitializing())
 2aa:	80 81       	ld	r24, Z
 2ac:	82 30       	cpi	r24, 0x02	; 2
 2ae:	e1 f0       	breq	.+56     	; 0x2e8 <_ZN3NRF13PrepareTxDataEhPhh+0x5a>
		return 0x01;
	if (hasDataToSend())
 2b0:	ce 01       	movw	r24, r28
 2b2:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 2b6:	81 11       	cpse	r24, r1
 2b8:	19 c0       	rjmp	.+50     	; 0x2ec <_ZN3NRF13PrepareTxDataEhPhh+0x5e>
		return 0x02;
	if (waitingForResponse() && isSystemCommand(command))
 2ba:	ce 01       	movw	r24, r28
 2bc:	0e 94 04 01 	call	0x208	; 0x208 <_ZN3NRF18waitingForResponseEv>
 2c0:	88 23       	and	r24, r24
 2c2:	c1 f0       	breq	.+48     	; 0x2f4 <_ZN3NRF13PrepareTxDataEhPhh+0x66>
 2c4:	61 2f       	mov	r22, r17
 2c6:	ce 01       	movw	r24, r28
 2c8:	0e 94 1f 01 	call	0x23e	; 0x23e <_ZN3NRF15isSystemCommandEh>
 2cc:	81 11       	cpse	r24, r1
 2ce:	10 c0       	rjmp	.+32     	; 0x2f0 <_ZN3NRF13PrepareTxDataEhPhh+0x62>
 2d0:	11 c0       	rjmp	.+34     	; 0x2f4 <_ZN3NRF13PrepareTxDataEhPhh+0x66>
	
	//populate TxData with length and data
	TxData[0] = length + 1;
	TxData[1] = command;
	for(i = 0; i < length; i++)
		TxData[i+2] = data[i];	
 2d2:	41 91       	ld	r20, Z+
 2d4:	4d 93       	st	X+, r20
	clearTxData();
	
	//populate TxData with length and data
	TxData[0] = length + 1;
	TxData[1] = command;
	for(i = 0; i < length; i++)
 2d6:	01 96       	adiw	r24, 0x01	; 1
 2d8:	82 17       	cp	r24, r18
 2da:	93 07       	cpc	r25, r19
 2dc:	d4 f3       	brlt	.-12     	; 0x2d2 <_ZN3NRF13PrepareTxDataEhPhh+0x44>
		TxData[i+2] = data[i];	
		
	//data to send flag
	status |= (1<<NRF_TX_READY);
 2de:	8a 8d       	ldd	r24, Y+26	; 0x1a
 2e0:	80 64       	ori	r24, 0x40	; 64
 2e2:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;	//success
 2e4:	80 e0       	ldi	r24, 0x00	; 0
 2e6:	1d c0       	rjmp	.+58     	; 0x322 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::PrepareTxData(uint8_t command, uint8_t *data, uint8_t length){
	//TODO: write this function
	int i;
	if (isInitializing())
		return 0x01;
 2e8:	81 e0       	ldi	r24, 0x01	; 1
 2ea:	1b c0       	rjmp	.+54     	; 0x322 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
	if (hasDataToSend())
		return 0x02;
 2ec:	82 e0       	ldi	r24, 0x02	; 2
 2ee:	19 c0       	rjmp	.+50     	; 0x322 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
	if (waitingForResponse() && isSystemCommand(command))
		return 0x03;
 2f0:	83 e0       	ldi	r24, 0x03	; 3
 2f2:	17 c0       	rjmp	.+46     	; 0x322 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
	
	lastCommand = command;
 2f4:	fe 01       	movw	r30, r28
 2f6:	ed 58       	subi	r30, 0x8D	; 141
 2f8:	ff 4f       	sbci	r31, 0xFF	; 255
 2fa:	10 83       	st	Z, r17
	
	clearTxData();
 2fc:	ce 01       	movw	r24, r28
 2fe:	0e 94 3c 01 	call	0x278	; 0x278 <_ZN3NRF11clearTxDataEv>
	
	//populate TxData with length and data
	TxData[0] = length + 1;
 302:	81 e0       	ldi	r24, 0x01	; 1
 304:	80 0f       	add	r24, r16
 306:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = command;
 308:	1c af       	std	Y+60, r17	; 0x3c
	for(i = 0; i < length; i++)
 30a:	20 2f       	mov	r18, r16
 30c:	30 e0       	ldi	r19, 0x00	; 0
 30e:	12 16       	cp	r1, r18
 310:	13 06       	cpc	r1, r19
 312:	2c f7       	brge	.-54     	; 0x2de <_ZN3NRF13PrepareTxDataEhPhh+0x50>
 314:	ee 2d       	mov	r30, r14
 316:	ff 2d       	mov	r31, r15
 318:	de 01       	movw	r26, r28
 31a:	dd 96       	adiw	r26, 0x3d	; 61
 31c:	80 e0       	ldi	r24, 0x00	; 0
 31e:	90 e0       	ldi	r25, 0x00	; 0
 320:	d8 cf       	rjmp	.-80     	; 0x2d2 <_ZN3NRF13PrepareTxDataEhPhh+0x44>
		TxData[i+2] = data[i];	
		
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData
 322:	df 91       	pop	r29
 324:	cf 91       	pop	r28
 326:	1f 91       	pop	r17
 328:	0f 91       	pop	r16
 32a:	ff 90       	pop	r15
 32c:	ef 90       	pop	r14
 32e:	08 95       	ret

00000330 <_ZN3NRF10disconnectEh>:
	localData[2] = (advInterval&0x00FF);	//LSB
	localData[3] = (advInterval&0xFF00)>>8; //MSB
	return (PrepareTxData(NRF_CMD_BOND, localData, 4));
}//

uint8_t NRF::disconnect(uint8_t reason){
 330:	cf 93       	push	r28
 332:	df 93       	push	r29
 334:	1f 92       	push	r1
 336:	cd b7       	in	r28, 0x3d	; 61
 338:	de b7       	in	r29, 0x3e	; 62
 33a:	69 83       	std	Y+1, r22	; 0x01
	return (PrepareTxData(NRF_CMD_DISCONNECT, &reason, 1));
 33c:	21 e0       	ldi	r18, 0x01	; 1
 33e:	ae 01       	movw	r20, r28
 340:	4f 5f       	subi	r20, 0xFF	; 255
 342:	5f 4f       	sbci	r21, 0xFF	; 255
 344:	61 e1       	ldi	r22, 0x11	; 17
 346:	0e 94 47 01 	call	0x28e	; 0x28e <_ZN3NRF13PrepareTxDataEhPhh>
}//
 34a:	0f 90       	pop	r0
 34c:	df 91       	pop	r29
 34e:	cf 91       	pop	r28
 350:	08 95       	ret

00000352 <_ZN3NRF11requestDataEh>:
	if (retVal == 0x00)
		dataCredit-=1;
	return (retVal);
}//

uint8_t NRF::requestData(uint8_t servicePipeNumber){
 352:	0f 93       	push	r16
 354:	1f 93       	push	r17
 356:	cf 93       	push	r28
 358:	df 93       	push	r29
 35a:	1f 92       	push	r1
 35c:	cd b7       	in	r28, 0x3d	; 61
 35e:	de b7       	in	r29, 0x3e	; 62
 360:	8c 01       	movw	r16, r24
 362:	69 83       	std	Y+1, r22	; 0x01
	uint8_t retVal = PrepareTxData(NRF_CMD_REQUEST_DATA, &servicePipeNumber, 1);
 364:	21 e0       	ldi	r18, 0x01	; 1
 366:	ae 01       	movw	r20, r28
 368:	4f 5f       	subi	r20, 0xFF	; 255
 36a:	5f 4f       	sbci	r21, 0xFF	; 255
 36c:	67 e1       	ldi	r22, 0x17	; 23
 36e:	0e 94 47 01 	call	0x28e	; 0x28e <_ZN3NRF13PrepareTxDataEhPhh>
	if (retVal == 0x00)
 372:	81 11       	cpse	r24, r1
 374:	06 c0       	rjmp	.+12     	; 0x382 <_ZN3NRF11requestDataEh+0x30>
		dataCredit-=1;
 376:	f8 01       	movw	r30, r16
 378:	ee 58       	subi	r30, 0x8E	; 142
 37a:	ff 4f       	sbci	r31, 0xFF	; 255
 37c:	90 81       	ld	r25, Z
 37e:	91 50       	subi	r25, 0x01	; 1
 380:	90 83       	st	Z, r25
	return (retVal);
}//
 382:	0f 90       	pop	r0
 384:	df 91       	pop	r29
 386:	cf 91       	pop	r28
 388:	1f 91       	pop	r17
 38a:	0f 91       	pop	r16
 38c:	08 95       	ret

0000038e <_ZN3NRF13PrepareTxDataEhhPhh>:
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command, uint8_t content, uint8_t *data, uint8_t length){
 38e:	df 92       	push	r13
 390:	ef 92       	push	r14
 392:	ff 92       	push	r15
 394:	0f 93       	push	r16
 396:	1f 93       	push	r17
 398:	cf 93       	push	r28
 39a:	df 93       	push	r29
 39c:	ec 01       	movw	r28, r24
 39e:	16 2f       	mov	r17, r22
 3a0:	f4 2e       	mov	r15, r20
 3a2:	d2 2e       	mov	r13, r18
 3a4:	e3 2e       	mov	r14, r19
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 3a6:	fc 01       	movw	r30, r24
 3a8:	ef 58       	subi	r30, 0x8F	; 143
 3aa:	ff 4f       	sbci	r31, 0xFF	; 255
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command, uint8_t content, uint8_t *data, uint8_t length){
	
	int i;
	if (isInitializing())
 3ac:	80 81       	ld	r24, Z
 3ae:	82 30       	cpi	r24, 0x02	; 2
 3b0:	e1 f0       	breq	.+56     	; 0x3ea <_ZN3NRF13PrepareTxDataEhhPhh+0x5c>
		return 0x01;
	if (hasDataToSend())
 3b2:	ce 01       	movw	r24, r28
 3b4:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 3b8:	81 11       	cpse	r24, r1
 3ba:	19 c0       	rjmp	.+50     	; 0x3ee <_ZN3NRF13PrepareTxDataEhhPhh+0x60>
		return 0x02;
	if (waitingForResponse() && isSystemCommand(command))
 3bc:	ce 01       	movw	r24, r28
 3be:	0e 94 04 01 	call	0x208	; 0x208 <_ZN3NRF18waitingForResponseEv>
 3c2:	88 23       	and	r24, r24
 3c4:	c1 f0       	breq	.+48     	; 0x3f6 <_ZN3NRF13PrepareTxDataEhhPhh+0x68>
 3c6:	61 2f       	mov	r22, r17
 3c8:	ce 01       	movw	r24, r28
 3ca:	0e 94 1f 01 	call	0x23e	; 0x23e <_ZN3NRF15isSystemCommandEh>
 3ce:	81 11       	cpse	r24, r1
 3d0:	10 c0       	rjmp	.+32     	; 0x3f2 <_ZN3NRF13PrepareTxDataEhhPhh+0x64>
 3d2:	11 c0       	rjmp	.+34     	; 0x3f6 <_ZN3NRF13PrepareTxDataEhhPhh+0x68>
	//populate TxData with length and data
	TxData[0] = length + 2;
	TxData[1] = command;
	TxData[2] = content;
	for(i = 0; i < length; i++)
		TxData[i+3] = data[i];
 3d4:	21 91       	ld	r18, Z+
 3d6:	2d 93       	st	X+, r18
	clearTxData();
	//populate TxData with length and data
	TxData[0] = length + 2;
	TxData[1] = command;
	TxData[2] = content;
	for(i = 0; i < length; i++)
 3d8:	01 96       	adiw	r24, 0x01	; 1
 3da:	80 17       	cp	r24, r16
 3dc:	91 07       	cpc	r25, r17
 3de:	d4 f3       	brlt	.-12     	; 0x3d4 <_ZN3NRF13PrepareTxDataEhhPhh+0x46>
		TxData[i+3] = data[i];
	
	//data to send flag
	status |= (1<<NRF_TX_READY);
 3e0:	8a 8d       	ldd	r24, Y+26	; 0x1a
 3e2:	80 64       	ori	r24, 0x40	; 64
 3e4:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;	//success
 3e6:	80 e0       	ldi	r24, 0x00	; 0
 3e8:	1d c0       	rjmp	.+58     	; 0x424 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>

uint8_t NRF::PrepareTxData(uint8_t command, uint8_t content, uint8_t *data, uint8_t length){
	
	int i;
	if (isInitializing())
		return 0x01;
 3ea:	81 e0       	ldi	r24, 0x01	; 1
 3ec:	1b c0       	rjmp	.+54     	; 0x424 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>
	if (hasDataToSend())
		return 0x02;
 3ee:	82 e0       	ldi	r24, 0x02	; 2
 3f0:	19 c0       	rjmp	.+50     	; 0x424 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>
	if (waitingForResponse() && isSystemCommand(command))
		return 0x03;
 3f2:	83 e0       	ldi	r24, 0x03	; 3
 3f4:	17 c0       	rjmp	.+46     	; 0x424 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>
	
	lastCommand = command;
 3f6:	fe 01       	movw	r30, r28
 3f8:	ed 58       	subi	r30, 0x8D	; 141
 3fa:	ff 4f       	sbci	r31, 0xFF	; 255
 3fc:	10 83       	st	Z, r17
	
	clearTxData();
 3fe:	ce 01       	movw	r24, r28
 400:	0e 94 3c 01 	call	0x278	; 0x278 <_ZN3NRF11clearTxDataEv>
	//populate TxData with length and data
	TxData[0] = length + 2;
 404:	82 e0       	ldi	r24, 0x02	; 2
 406:	80 0f       	add	r24, r16
 408:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = command;
 40a:	1c af       	std	Y+60, r17	; 0x3c
	TxData[2] = content;
 40c:	fd ae       	std	Y+61, r15	; 0x3d
	for(i = 0; i < length; i++)
 40e:	10 e0       	ldi	r17, 0x00	; 0
 410:	10 16       	cp	r1, r16
 412:	11 06       	cpc	r1, r17
 414:	2c f7       	brge	.-54     	; 0x3e0 <_ZN3NRF13PrepareTxDataEhhPhh+0x52>
 416:	ed 2d       	mov	r30, r13
 418:	fe 2d       	mov	r31, r14
 41a:	de 01       	movw	r26, r28
 41c:	de 96       	adiw	r26, 0x3e	; 62
 41e:	80 e0       	ldi	r24, 0x00	; 0
 420:	90 e0       	ldi	r25, 0x00	; 0
 422:	d8 cf       	rjmp	.-80     	; 0x3d4 <_ZN3NRF13PrepareTxDataEhhPhh+0x46>
		TxData[i+3] = data[i];
	
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData
 424:	df 91       	pop	r29
 426:	cf 91       	pop	r28
 428:	1f 91       	pop	r17
 42a:	0f 91       	pop	r16
 42c:	ff 90       	pop	r15
 42e:	ef 90       	pop	r14
 430:	df 90       	pop	r13
 432:	08 95       	ret

00000434 <_ZN3NRF12setLocalDataEhPhh>:
return (PrepareTxData(NRF_CMD_CLOSE_REMOTE_PIPE, &servicePipeNumber, 1));
}//
#pragma endregion System Command Functions

#pragma region Data Command Functions
uint8_t NRF::setLocalData(uint8_t servicePipeNumber, uint8_t *data, uint8_t length){	
 434:	0f 93       	push	r16
	return (PrepareTxData(NRF_CMD_SET_LOCAL_DATA, servicePipeNumber, data, length));
 436:	02 2f       	mov	r16, r18
 438:	9a 01       	movw	r18, r20
 43a:	46 2f       	mov	r20, r22
 43c:	6d e0       	ldi	r22, 0x0D	; 13
 43e:	0e 94 c7 01 	call	0x38e	; 0x38e <_ZN3NRF13PrepareTxDataEhhPhh>
}//
 442:	0f 91       	pop	r16
 444:	08 95       	ret

00000446 <_ZN3NRF13PrepareTxDataEh>:
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command){
 446:	1f 93       	push	r17
 448:	cf 93       	push	r28
 44a:	df 93       	push	r29
 44c:	ec 01       	movw	r28, r24
 44e:	16 2f       	mov	r17, r22
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 450:	fc 01       	movw	r30, r24
 452:	ef 58       	subi	r30, 0x8F	; 143
 454:	ff 4f       	sbci	r31, 0xFF	; 255
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command){
	if (isInitializing())
 456:	80 81       	ld	r24, Z
 458:	82 30       	cpi	r24, 0x02	; 2
 45a:	91 f0       	breq	.+36     	; 0x480 <_ZN3NRF13PrepareTxDataEh+0x3a>
		return 0x01;
	if (hasDataToSend())
 45c:	ce 01       	movw	r24, r28
 45e:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 462:	81 11       	cpse	r24, r1
 464:	0f c0       	rjmp	.+30     	; 0x484 <_ZN3NRF13PrepareTxDataEh+0x3e>
		return 0x02;
	if (waitingForResponse() && isSystemCommand(command))
 466:	ce 01       	movw	r24, r28
 468:	0e 94 04 01 	call	0x208	; 0x208 <_ZN3NRF18waitingForResponseEv>
 46c:	88 23       	and	r24, r24
 46e:	61 f0       	breq	.+24     	; 0x488 <_ZN3NRF13PrepareTxDataEh+0x42>
 470:	61 2f       	mov	r22, r17
 472:	ce 01       	movw	r24, r28
 474:	0e 94 1f 01 	call	0x23e	; 0x23e <_ZN3NRF15isSystemCommandEh>
 478:	88 23       	and	r24, r24
 47a:	31 f0       	breq	.+12     	; 0x488 <_ZN3NRF13PrepareTxDataEh+0x42>
		return 0x03;
 47c:	83 e0       	ldi	r24, 0x03	; 3
 47e:	12 c0       	rjmp	.+36     	; 0x4a4 <_ZN3NRF13PrepareTxDataEh+0x5e>
	return 0x00;	//success
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command){
	if (isInitializing())
		return 0x01;
 480:	81 e0       	ldi	r24, 0x01	; 1
 482:	10 c0       	rjmp	.+32     	; 0x4a4 <_ZN3NRF13PrepareTxDataEh+0x5e>
	if (hasDataToSend())
		return 0x02;
 484:	82 e0       	ldi	r24, 0x02	; 2
 486:	0e c0       	rjmp	.+28     	; 0x4a4 <_ZN3NRF13PrepareTxDataEh+0x5e>
	if (waitingForResponse() && isSystemCommand(command))
		return 0x03;
	
	lastCommand = command;
 488:	fe 01       	movw	r30, r28
 48a:	ed 58       	subi	r30, 0x8D	; 141
 48c:	ff 4f       	sbci	r31, 0xFF	; 255
 48e:	10 83       	st	Z, r17
	
	clearTxData();
 490:	ce 01       	movw	r24, r28
 492:	0e 94 3c 01 	call	0x278	; 0x278 <_ZN3NRF11clearTxDataEv>
	TxData[0] = 0x01;
 496:	81 e0       	ldi	r24, 0x01	; 1
 498:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = command;
 49a:	1c af       	std	Y+60, r17	; 0x3c
	status |= (1<<NRF_TX_READY);
 49c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 49e:	80 64       	ori	r24, 0x40	; 64
 4a0:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;
 4a2:	80 e0       	ldi	r24, 0x00	; 0
}
 4a4:	df 91       	pop	r29
 4a6:	cf 91       	pop	r28
 4a8:	1f 91       	pop	r17
 4aa:	08 95       	ret

000004ac <_ZN3NRF5sleepEv>:
	localData[1] = command&0x00FF;		//LSB
	return (PrepareTxData(NRF_CMD_DTM_COMMAND, localData, 2));
}//DTMcommand

uint8_t NRF::sleep(){
	status |= (1<<NRF_SLEEPING);
 4ac:	fc 01       	movw	r30, r24
 4ae:	22 8d       	ldd	r18, Z+26	; 0x1a
 4b0:	22 60       	ori	r18, 0x02	; 2
 4b2:	22 8f       	std	Z+26, r18	; 0x1a
	return (PrepareTxData(NRF_CMD_SLEEP));
 4b4:	64 e0       	ldi	r22, 0x04	; 4
 4b6:	0e 94 23 02 	call	0x446	; 0x446 <_ZN3NRF13PrepareTxDataEh>
}//sleep
 4ba:	08 95       	ret

000004bc <_ZN3NRF6wakeupEv>:

///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::wakeup(void){	
	return (PrepareTxData(NRF_CMD_WAKEUP));
 4bc:	65 e0       	ldi	r22, 0x05	; 5
 4be:	0e 94 23 02 	call	0x446	; 0x446 <_ZN3NRF13PrepareTxDataEh>
}
 4c2:	08 95       	ret

000004c4 <_ZN3NRF7connectEjj>:

uint8_t NRF::radioReset(){
	return (PrepareTxData(NRF_CMD_RADIO_RESET));
}//

uint8_t NRF::connect(uint16_t timeout, uint16_t advInterval){	
 4c4:	ef 92       	push	r14
 4c6:	ff 92       	push	r15
 4c8:	0f 93       	push	r16
 4ca:	1f 93       	push	r17
 4cc:	cf 93       	push	r28
 4ce:	df 93       	push	r29
 4d0:	ec 01       	movw	r28, r24
 4d2:	e6 2e       	mov	r14, r22
 4d4:	f7 2e       	mov	r15, r23
 4d6:	04 2f       	mov	r16, r20
 4d8:	15 2f       	mov	r17, r21
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 4da:	fc 01       	movw	r30, r24
 4dc:	ef 58       	subi	r30, 0x8F	; 143
 4de:	ff 4f       	sbci	r31, 0xFF	; 255
	//localData[1] = (timeout&0xFF00)>>8; //MSB
	//localData[2] = (advInterval&0x00FF);	//LSB
	//localData[3] = (advInterval&0xFF00)>>8; //MSB
	//return (PrepareTxData(NRF_CMD_CONNECT, localData, 4));
	
	if (isInitializing())
 4e0:	80 81       	ld	r24, Z
 4e2:	82 30       	cpi	r24, 0x02	; 2
 4e4:	11 f1       	breq	.+68     	; 0x52a <_ZN3NRF7connectEjj+0x66>
	return 0x01;
	if (hasDataToSend())
 4e6:	ce 01       	movw	r24, r28
 4e8:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 4ec:	81 11       	cpse	r24, r1
 4ee:	1f c0       	rjmp	.+62     	; 0x52e <_ZN3NRF7connectEjj+0x6a>
	return 0x02;
	if (waitingForResponse())
 4f0:	ce 01       	movw	r24, r28
 4f2:	0e 94 04 01 	call	0x208	; 0x208 <_ZN3NRF18waitingForResponseEv>
 4f6:	81 11       	cpse	r24, r1
 4f8:	1c c0       	rjmp	.+56     	; 0x532 <_ZN3NRF7connectEjj+0x6e>
	return 0x03;
	
	lastCommand = TxData[1];
 4fa:	fe 01       	movw	r30, r28
 4fc:	ed 58       	subi	r30, 0x8D	; 141
 4fe:	ff 4f       	sbci	r31, 0xFF	; 255
 500:	8c ad       	ldd	r24, Y+60	; 0x3c
 502:	80 83       	st	Z, r24
	
	clearTxData();
 504:	ce 01       	movw	r24, r28
 506:	0e 94 3c 01 	call	0x278	; 0x278 <_ZN3NRF11clearTxDataEv>
	TxData[0] = 0x05;	//length
 50a:	85 e0       	ldi	r24, 0x05	; 5
 50c:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = NRF_CMD_CONNECT;
 50e:	8f e0       	ldi	r24, 0x0F	; 15
 510:	8c af       	std	Y+60, r24	; 0x3c
	TxData[2] = (timeout&0x00FF);	//LSB
 512:	ed ae       	std	Y+61, r14	; 0x3d
	TxData[3] = (timeout&0xFF00)>>8; //MSB
 514:	fe ae       	std	Y+62, r15	; 0x3e
	TxData[4] = (advInterval&0x00FF);	//LSB
 516:	0f af       	std	Y+63, r16	; 0x3f
	TxData[5] = (advInterval&0xFF00)>>8; //MSB
 518:	fe 01       	movw	r30, r28
 51a:	e0 5c       	subi	r30, 0xC0	; 192
 51c:	ff 4f       	sbci	r31, 0xFF	; 255
 51e:	10 83       	st	Z, r17
	status |= (1<<NRF_TX_READY);
 520:	8a 8d       	ldd	r24, Y+26	; 0x1a
 522:	80 64       	ori	r24, 0x40	; 64
 524:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;
 526:	80 e0       	ldi	r24, 0x00	; 0
 528:	05 c0       	rjmp	.+10     	; 0x534 <_ZN3NRF7connectEjj+0x70>
	//localData[2] = (advInterval&0x00FF);	//LSB
	//localData[3] = (advInterval&0xFF00)>>8; //MSB
	//return (PrepareTxData(NRF_CMD_CONNECT, localData, 4));
	
	if (isInitializing())
	return 0x01;
 52a:	81 e0       	ldi	r24, 0x01	; 1
 52c:	03 c0       	rjmp	.+6      	; 0x534 <_ZN3NRF7connectEjj+0x70>
	if (hasDataToSend())
	return 0x02;
 52e:	82 e0       	ldi	r24, 0x02	; 2
 530:	01 c0       	rjmp	.+2      	; 0x534 <_ZN3NRF7connectEjj+0x70>
	if (waitingForResponse())
	return 0x03;
 532:	83 e0       	ldi	r24, 0x03	; 3
	TxData[3] = (timeout&0xFF00)>>8; //MSB
	TxData[4] = (advInterval&0x00FF);	//LSB
	TxData[5] = (advInterval&0xFF00)>>8; //MSB
	status |= (1<<NRF_TX_READY);
	return 0x00;
}//
 534:	df 91       	pop	r29
 536:	cf 91       	pop	r28
 538:	1f 91       	pop	r17
 53a:	0f 91       	pop	r16
 53c:	ff 90       	pop	r15
 53e:	ef 90       	pop	r14
 540:	08 95       	ret

00000542 <_ZN3NRF11transferACIEv>:
nRF8001 is capable of receiving an ACI command simultaneously as it sends an ACI event to the
application controller.
The application controller shall always read the length byte from nRF8001 and check if the length is
greater than 0. If the length is greater than 0 the data on the MISO line shall be read
*/
void NRF::transferACI(void){
 542:	1f 93       	push	r17
 544:	cf 93       	push	r28
 546:	df 93       	push	r29
 548:	ec 01       	movw	r28, r24
	uint8_t length; 
	
	//transmit and receive
	if (hasDataToSend() && (TxData[0] > 0)){			
 54a:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 54e:	88 23       	and	r24, r24
 550:	09 f4       	brne	.+2      	; 0x554 <_ZN3NRF11transferACIEv+0x12>
 552:	40 c0       	rjmp	.+128    	; 0x5d4 <_ZN3NRF11transferACIEv+0x92>
 554:	8b ad       	ldd	r24, Y+59	; 0x3b
 556:	81 11       	cpse	r24, r1
 558:	40 c0       	rjmp	.+128    	; 0x5da <_ZN3NRF11transferACIEv+0x98>
 55a:	3c c0       	rjmp	.+120    	; 0x5d4 <_ZN3NRF11transferACIEv+0x92>
		SetREQN();
		
		//when data is received, clear the ready to receive flag until
		//the received data is handled by the process function
		if (RxData[0] != 0x00){
			status &= ~(1<<NRF_RX_READY);
 55c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 55e:	8f 77       	andi	r24, 0x7F	; 127
 560:	8a 8f       	std	Y+26, r24	; 0x1a
		}
		
		
		lastCommand = TxData[1];
 562:	6c ad       	ldd	r22, Y+60	; 0x3c
 564:	fe 01       	movw	r30, r28
 566:	ed 58       	subi	r30, 0x8D	; 141
 568:	ff 4f       	sbci	r31, 0xFF	; 255
 56a:	60 83       	st	Z, r22
		
		//clear the NRF_TX_READY flag in the status register
		status &= ~(1<<NRF_TX_READY);
 56c:	1a 8d       	ldd	r17, Y+26	; 0x1a
 56e:	1f 7b       	andi	r17, 0xBF	; 191
		
		if (isSystemCommand(TxData[1]))
 570:	ce 01       	movw	r24, r28
 572:	0e 94 1f 01 	call	0x23e	; 0x23e <_ZN3NRF15isSystemCommandEh>
 576:	81 11       	cpse	r24, r1
 578:	02 c0       	rjmp	.+4      	; 0x57e <_ZN3NRF11transferACIEv+0x3c>
		
		
		lastCommand = TxData[1];
		
		//clear the NRF_TX_READY flag in the status register
		status &= ~(1<<NRF_TX_READY);
 57a:	1a 8f       	std	Y+26, r17	; 0x1a
 57c:	58 c0       	rjmp	.+176    	; 0x62e <_ZN3NRF11transferACIEv+0xec>
		
		if (isSystemCommand(TxData[1]))
			status |= (1<<NRF_WAIT_FOR_RESPONSE);
 57e:	10 61       	ori	r17, 0x10	; 16
 580:	1a 8f       	std	Y+26, r17	; 0x1a
 582:	55 c0       	rjmp	.+170    	; 0x62e <_ZN3NRF11transferACIEv+0xec>
	}//if hasDataToSend
	
	//receive only
	else if(RDYN == 0)
	{
		clearTxData();
 584:	ce 01       	movw	r24, r28
 586:	0e 94 3c 01 	call	0x278	; 0x278 <_ZN3NRF11clearTxDataEv>
		//Request communication with nRF8001
		ClearREQN();
 58a:	29 98       	cbi	0x05, 1	; 5
		
		//transmit the DUMMY BYTE and receive the Rx DEBUG BYTE
		//the LENGTH BYTE is not counted as part of the length
		RxData[0] = spi.transfer1byte(0x00);
 58c:	60 e0       	ldi	r22, 0x00	; 0
 58e:	85 e7       	ldi	r24, 0x75	; 117
 590:	93 e0       	ldi	r25, 0x03	; 3
 592:	0e 94 ef 00 	call	0x1de	; 0x1de <_ZN3SPI13transfer1byteEh>
 596:	8b 8f       	std	Y+27, r24	; 0x1b
		
		//Transmit a DUMMY BYTE and receive the LENGTH BYTE
		RxData[0] = spi.transfer1byte(0x00);
 598:	60 e0       	ldi	r22, 0x00	; 0
 59a:	85 e7       	ldi	r24, 0x75	; 117
 59c:	93 e0       	ldi	r25, 0x03	; 3
 59e:	0e 94 ef 00 	call	0x1de	; 0x1de <_ZN3SPI13transfer1byteEh>
 5a2:	8b 8f       	std	Y+27, r24	; 0x1b
 5a4:	28 2f       	mov	r18, r24
 5a6:	80 32       	cpi	r24, 0x20	; 32
 5a8:	08 f0       	brcs	.+2      	; 0x5ac <_ZN3NRF11transferACIEv+0x6a>
 5aa:	2f e1       	ldi	r18, 0x1F	; 31
		
		length = RxData[0];
		if (length>HAL_ACI_MAX_LENGTH)
			length = HAL_ACI_MAX_LENGTH;
		if (length>0)
 5ac:	22 23       	and	r18, r18
 5ae:	51 f0       	breq	.+20     	; 0x5c4 <_ZN3NRF11transferACIEv+0x82>
		{
			
			spi.transfer(&TxData[2],&RxData[1],length);
 5b0:	ae 01       	movw	r20, r28
 5b2:	44 5e       	subi	r20, 0xE4	; 228
 5b4:	5f 4f       	sbci	r21, 0xFF	; 255
 5b6:	be 01       	movw	r22, r28
 5b8:	63 5c       	subi	r22, 0xC3	; 195
 5ba:	7f 4f       	sbci	r23, 0xFF	; 255
 5bc:	85 e7       	ldi	r24, 0x75	; 117
 5be:	93 e0       	ldi	r25, 0x03	; 3
 5c0:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN3SPI8transferEPhS0_h>
		}//if length>0
		
		//Set REQN high to terminate the transfer
		SetREQN();
 5c4:	29 9a       	sbi	0x05, 1	; 5
		
		//when data is received, clear the ready to receive flag until
		//the received data is handled by the process function
		if (RxData[0] != 0x00){
 5c6:	8b 8d       	ldd	r24, Y+27	; 0x1b
 5c8:	88 23       	and	r24, r24
 5ca:	89 f1       	breq	.+98     	; 0x62e <_ZN3NRF11transferACIEv+0xec>
			status &= ~(1<<NRF_RX_READY);
 5cc:	8a 8d       	ldd	r24, Y+26	; 0x1a
 5ce:	8f 77       	andi	r24, 0x7F	; 127
 5d0:	8a 8f       	std	Y+26, r24	; 0x1a
 5d2:	2d c0       	rjmp	.+90     	; 0x62e <_ZN3NRF11transferACIEv+0xec>
			status |= (1<<NRF_WAIT_FOR_RESPONSE);
				
	}//if hasDataToSend
	
	//receive only
	else if(RDYN == 0)
 5d4:	2a 99       	sbic	0x05, 2	; 5
 5d6:	2b c0       	rjmp	.+86     	; 0x62e <_ZN3NRF11transferACIEv+0xec>
 5d8:	d5 cf       	rjmp	.-86     	; 0x584 <_ZN3NRF11transferACIEv+0x42>
	//transmit and receive
	if (hasDataToSend() && (TxData[0] > 0)){			
		length = TxData[0];
	
		//Request communication with nRF8001
		ClearREQN();
 5da:	29 98       	cbi	0x05, 1	; 5
	
		//Wait for nRF8001 to clear RDYN pin indicating it is ready to receive
		while (RDYN == 1);
 5dc:	85 b1       	in	r24, 0x05	; 5
	
		//transmit the Tx LENGTH BYTE and receive the Rx DEBUG BYTE
		//the LENGTH BYTE is not counted as part of the length
		RxData[0] = spi.transfer1byte(TxData[0]);
 5de:	6b ad       	ldd	r22, Y+59	; 0x3b
 5e0:	85 e7       	ldi	r24, 0x75	; 117
 5e2:	93 e0       	ldi	r25, 0x03	; 3
 5e4:	0e 94 ef 00 	call	0x1de	; 0x1de <_ZN3SPI13transfer1byteEh>
 5e8:	8b 8f       	std	Y+27, r24	; 0x1b
	
	
		//transmit the first byte of data while receiving the length byte
		//we are discarding the Rx DEBUG BYTE
		RxData[0] = spi.transfer1byte(TxData[1]);
 5ea:	6c ad       	ldd	r22, Y+60	; 0x3c
 5ec:	85 e7       	ldi	r24, 0x75	; 117
 5ee:	93 e0       	ldi	r25, 0x03	; 3
 5f0:	0e 94 ef 00 	call	0x1de	; 0x1de <_ZN3SPI13transfer1byteEh>
 5f4:	8b 8f       	std	Y+27, r24	; 0x1b
	
		////set length to the greater of TxData less the byte we already sent or 
		////RxData length
		length = (RxData[0]>(TxData[0] -1))?RxData[0]:(TxData[0]-1);
 5f6:	4b ad       	ldd	r20, Y+59	; 0x3b
 5f8:	50 e0       	ldi	r21, 0x00	; 0
 5fa:	41 50       	subi	r20, 0x01	; 1
 5fc:	51 09       	sbc	r21, r1
 5fe:	28 2f       	mov	r18, r24
 600:	30 e0       	ldi	r19, 0x00	; 0
 602:	24 17       	cp	r18, r20
 604:	35 07       	cpc	r19, r21
 606:	0c f4       	brge	.+2      	; 0x60a <_ZN3NRF11transferACIEv+0xc8>
 608:	9a 01       	movw	r18, r20
 60a:	20 32       	cpi	r18, 0x20	; 32
 60c:	08 f0       	brcs	.+2      	; 0x610 <_ZN3NRF11transferACIEv+0xce>
 60e:	2f e1       	ldi	r18, 0x1F	; 31
		if (length>HAL_ACI_MAX_LENGTH) 
			length = HAL_ACI_MAX_LENGTH;
			
		//if (length>0)
		spi.transfer(&TxData[2],&RxData[1],length);
 610:	ae 01       	movw	r20, r28
 612:	44 5e       	subi	r20, 0xE4	; 228
 614:	5f 4f       	sbci	r21, 0xFF	; 255
 616:	be 01       	movw	r22, r28
 618:	63 5c       	subi	r22, 0xC3	; 195
 61a:	7f 4f       	sbci	r23, 0xFF	; 255
 61c:	85 e7       	ldi	r24, 0x75	; 117
 61e:	93 e0       	ldi	r25, 0x03	; 3
 620:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN3SPI8transferEPhS0_h>
		//for (uint8_t i = 0; i< length; i++){
			//RxData[i+1] = spi.transfer1byte(TxData[i+2]); 
		//}
	
		//Set REQN high to terminate the transfer
		SetREQN();
 624:	29 9a       	sbi	0x05, 1	; 5
		
		//when data is received, clear the ready to receive flag until
		//the received data is handled by the process function
		if (RxData[0] != 0x00){
 626:	8b 8d       	ldd	r24, Y+27	; 0x1b
 628:	81 11       	cpse	r24, r1
 62a:	98 cf       	rjmp	.-208    	; 0x55c <_ZN3NRF11transferACIEv+0x1a>
 62c:	9a cf       	rjmp	.-204    	; 0x562 <_ZN3NRF11transferACIEv+0x20>
			status &= ~(1<<NRF_RX_READY);
		}
		
	}//else if(RDYN == 0)	
	
}//transferACI()
 62e:	df 91       	pop	r29
 630:	cf 91       	pop	r28
 632:	1f 91       	pop	r17
 634:	08 95       	ret

00000636 <_ZN3NRF11clearRxDataEv>:
void NRF::clearTxData(){
	for(int i = 0; i<32; i++) 
		TxData[i] = 0x00;		
}
void NRF::clearRxData(){
 636:	fc 01       	movw	r30, r24
 638:	7b 96       	adiw	r30, 0x1b	; 27
	for(int i = 0; i<32; i++)
 63a:	20 e0       	ldi	r18, 0x00	; 0
 63c:	30 e0       	ldi	r19, 0x00	; 0
		RxData[i] = 0x00;
 63e:	11 92       	st	Z+, r1
void NRF::clearTxData(){
	for(int i = 0; i<32; i++) 
		TxData[i] = 0x00;		
}
void NRF::clearRxData(){
	for(int i = 0; i<32; i++)
 640:	2f 5f       	subi	r18, 0xFF	; 255
 642:	3f 4f       	sbci	r19, 0xFF	; 255
 644:	20 32       	cpi	r18, 0x20	; 32
 646:	31 05       	cpc	r19, r1
 648:	d1 f7       	brne	.-12     	; 0x63e <_ZN3NRF11clearRxDataEv+0x8>
		RxData[i] = 0x00;
}
 64a:	08 95       	ret

0000064c <_ZN3NRF22processCommandResponseEv>:
			
		}
	}//else RxData
}//process

void NRF::processCommandResponse(){
 64c:	cf 93       	push	r28
 64e:	df 93       	push	r29
 650:	ec 01       	movw	r28, r24
	//	2		CommandOpCode (see switch statement below)
	//	3		Status of command execution
	//	4..31	Command specific data
	
	
	switch (RxData[2]){	//CommandOpCode
 652:	4d 8d       	ldd	r20, Y+29	; 0x1d
 654:	50 e0       	ldi	r21, 0x00	; 0
 656:	fa 01       	movw	r30, r20
 658:	31 97       	sbiw	r30, 0x01	; 1
 65a:	ee 31       	cpi	r30, 0x1E	; 30
 65c:	f1 05       	cpc	r31, r1
 65e:	08 f0       	brcs	.+2      	; 0x662 <_ZN3NRF22processCommandResponseEv+0x16>
 660:	6c c0       	rjmp	.+216    	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
 662:	ec 5c       	subi	r30, 0xCC	; 204
 664:	ff 4f       	sbci	r31, 0xFF	; 255
 666:	0c 94 ba 06 	jmp	0xd74	; 0xd74 <__tablejump2__>
			//RxData[3]	:	Status
			//					ACI_STATUS_ERROR_DEVICE_STATE_INVALID when used in incorrect mode
			//						can only be used in NRF_MODE_TEST, NRF_MODE_SETUP, NRF_MODE_STANDBY
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 66a:	8a 8d       	ldd	r24, Y+26	; 0x1a
 66c:	8f 7e       	andi	r24, 0xEF	; 239
 66e:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 670:	64 c0       	rjmp	.+200    	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[3]	:	Status
			//					ACI_STATUS_ERROR_DEVICE_STATE_INVALID when used in incorrect mode
			//						can only be used in NRF_MODE_TEST
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 672:	8a 8d       	ldd	r24, Y+26	; 0x1a
 674:	8f 7e       	andi	r24, 0xEF	; 239
 676:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 678:	60 c0       	rjmp	.+192    	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[4-5]	:	DTM Event (2 bytes MSB/LSB)
			//Refer to Bluetooth Core specification v4.0, Volume 6, Part F, Direct Test Mode,
			//Sect.3.4, Events, for description of DTM event format and content
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 67a:	8a 8d       	ldd	r24, Y+26	; 0x1a
 67c:	8f 7e       	andi	r24, 0xEF	; 239
 67e:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 680:	5c c0       	rjmp	.+184    	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[3]	:	Status
			//					ACI_STATUS_ERROR_DEVICE_STATE_INVALID when used in incorrect mode
			//						can only be used in NRF_MODE_STANDBY
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 682:	8a 8d       	ldd	r24, Y+26	; 0x1a
 684:	8f 7e       	andi	r24, 0xEF	; 239
 686:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 688:	58 c0       	rjmp	.+176    	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[4]		: none
			
			status &= ~(1<<NRF_SLEEPING);
			
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 68a:	8a 8d       	ldd	r24, Y+26	; 0x1a
 68c:	8d 7e       	andi	r24, 0xED	; 237
 68e:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 690:	54 c0       	rjmp	.+168    	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
			
				
			//on the last run of CMD_SETUP
			//do NOT clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			//the NRF_CMD_SETUP will be followed by NRF_EVT_DEVICE_STARTED			
			if (RxData[3] == ACI_STATUS_TRANSACTION_CONTINUE){
 692:	8e 8d       	ldd	r24, Y+30	; 0x1e
 694:	81 30       	cpi	r24, 0x01	; 1
 696:	19 f4       	brne	.+6      	; 0x69e <_ZN3NRF22processCommandResponseEv+0x52>
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 698:	8a 8d       	ldd	r24, Y+26	; 0x1a
 69a:	8f 7e       	andi	r24, 0xEF	; 239
 69c:	8a 8f       	std	Y+26, r24	; 0x1a
			}
			
			//set the NRF_RX_READY bit in the status register
			status |= (1<<NRF_RX_READY);
 69e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6a0:	80 68       	ori	r24, 0x80	; 128
 6a2:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6a4:	4a c0       	rjmp	.+148    	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_READ_DYNAMIC_DATA:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6a6:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6a8:	8f 7e       	andi	r24, 0xEF	; 239
 6aa:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6ac:	46 c0       	rjmp	.+140    	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_WRITE_DYNAMIC_DATA:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6ae:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6b0:	8f 7e       	andi	r24, 0xEF	; 239
 6b2:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6b4:	42 c0       	rjmp	.+132    	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[4-5]	:	Config ID - (LSB/MSB)
			//RxData[6]		:	ACI Protocol version
			//
		
			//TODO: finish this
			version = RxData[6];
 6b6:	89 a1       	ldd	r24, Y+33	; 0x21
 6b8:	90 e0       	ldi	r25, 0x00	; 0
 6ba:	99 8f       	std	Y+25, r25	; 0x19
 6bc:	88 8f       	std	Y+24, r24	; 0x18
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6be:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6c0:	8f 7e       	andi	r24, 0xEF	; 239
 6c2:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6c4:	3a c0       	rjmp	.+116    	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_GET_DEVICE_ADDRESS:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6c6:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6c8:	8f 7e       	andi	r24, 0xEF	; 239
 6ca:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6cc:	36 c0       	rjmp	.+108    	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_GET_BATTERY_LEVEL:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6ce:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6d0:	8f 7e       	andi	r24, 0xEF	; 239
 6d2:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6d4:	32 c0       	rjmp	.+100    	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
			// RxData[5] : temperature MSB
		
			//data[0] = NRF_CMD_GET_TEMPERATURE;
			//data[1] = RxData[4];
			//data[2] = RxData[3];
			if (RxData[3] == ACI_STATUS_SUCCESS)
 6d6:	8e 8d       	ldd	r24, Y+30	; 0x1e
 6d8:	81 11       	cpse	r24, r1
 6da:	09 c0       	rjmp	.+18     	; 0x6ee <_ZN3NRF22processCommandResponseEv+0xa2>
			temperature = (RxData[5]<<4 | RxData[4]);
 6dc:	88 a1       	ldd	r24, Y+32	; 0x20
 6de:	20 e1       	ldi	r18, 0x10	; 16
 6e0:	82 9f       	mul	r24, r18
 6e2:	c0 01       	movw	r24, r0
 6e4:	11 24       	eor	r1, r1
 6e6:	2f 8d       	ldd	r18, Y+31	; 0x1f
 6e8:	82 2b       	or	r24, r18
 6ea:	9f 8b       	std	Y+23, r25	; 0x17
 6ec:	8e 8b       	std	Y+22, r24	; 0x16
			clearRxData();
 6ee:	ce 01       	movw	r24, r28
 6f0:	0e 94 1b 03 	call	0x636	; 0x636 <_ZN3NRF11clearRxDataEv>
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6f4:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6f6:	8f 7e       	andi	r24, 0xEF	; 239
 6f8:	8a 8f       	std	Y+26, r24	; 0x1a
		break;
 6fa:	1f c0       	rjmp	.+62     	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
			case NRF_CMD_RADIO_RESET:
			//will initialization have to be redone upon reset?
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6fc:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6fe:	8f 7e       	andi	r24, 0xEF	; 239
 700:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 702:	1b c0       	rjmp	.+54     	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
			//status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
			break;
		case NRF_CMD_SET_TX_POWER:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 704:	8a 8d       	ldd	r24, Y+26	; 0x1a
 706:	8f 7e       	andi	r24, 0xEF	; 239
 708:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 70a:	17 c0       	rjmp	.+46     	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
			//or by NRF_EVT_PIPE_ERROR(failure)
			break;
		case NRF_CMD_SET_APP_LATENCY:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 70c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 70e:	8f 7e       	andi	r24, 0xEF	; 239
 710:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 712:	13 c0       	rjmp	.+38     	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_SET_KEY:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 714:	8a 8d       	ldd	r24, Y+26	; 0x1a
 716:	8f 7e       	andi	r24, 0xEF	; 239
 718:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 71a:	0f c0       	rjmp	.+30     	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_OPEN_ADV_PIPE:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 71c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 71e:	8f 7e       	andi	r24, 0xEF	; 239
 720:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 722:	0b c0       	rjmp	.+22     	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_BROADCAST:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 724:	8a 8d       	ldd	r24, Y+26	; 0x1a
 726:	8f 7e       	andi	r24, 0xEF	; 239
 728:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 72a:	07 c0       	rjmp	.+14     	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_BOND_SEC_REQUEST:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 72c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 72e:	8f 7e       	andi	r24, 0xEF	; 239
 730:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 732:	03 c0       	rjmp	.+6      	; 0x73a <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_DIRECT_CONNECT:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 734:	8a 8d       	ldd	r24, Y+26	; 0x1a
 736:	8f 7e       	andi	r24, 0xEF	; 239
 738:	8a 8f       	std	Y+26, r24	; 0x1a
		default:
			break;
		
	}//end switch RxData[2]
	
}//processCommandResponse()
 73a:	df 91       	pop	r29
 73c:	cf 91       	pop	r28
 73e:	08 95       	ret

00000740 <_ZN3NRF7processEv>:
	//set to INIT_MODE and RX_READY
	//we are waiting for a NRF_EVT_DEVICE_STARTED in NRF_MODE_SETUP
	//status |= (1<<NRF_RX_READY | 1<<NRF_INIT_MODE | 1<<NRF_WAIT_FOR_RESPONSE);
	status |= (1<<NRF_RX_READY | 1<<NRF_WAIT_FOR_RESPONSE);
}
void NRF::process(void){	
 740:	1f 93       	push	r17
 742:	cf 93       	push	r28
 744:	df 93       	push	r29
 746:	ec 01       	movw	r28, r24
	uint8_t i;
	if (isReadyToReceiveData()){
 748:	8a 8d       	ldd	r24, Y+26	; 0x1a
 74a:	88 23       	and	r24, r24
 74c:	1c f4       	brge	.+6      	; 0x754 <_ZN3NRF7processEv+0x14>
		clearRxData();
 74e:	ce 01       	movw	r24, r28
 750:	0e 94 1b 03 	call	0x636	; 0x636 <_ZN3NRF11clearRxDataEv>
	}
		
	
	//setup message from services.h file loaded onto nRF8001
	if( (mode == NRF_MODE_SETUP)  && !hasDataToSend() && !waitingForResponse() ) {
 754:	fe 01       	movw	r30, r28
 756:	ef 58       	subi	r30, 0x8F	; 143
 758:	ff 4f       	sbci	r31, 0xFF	; 255
 75a:	80 81       	ld	r24, Z
 75c:	82 30       	cpi	r24, 0x02	; 2
 75e:	31 f5       	brne	.+76     	; 0x7ac <_ZN3NRF7processEv+0x6c>
 760:	ce 01       	movw	r24, r28
 762:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 766:	81 11       	cpse	r24, r1
 768:	21 c0       	rjmp	.+66     	; 0x7ac <_ZN3NRF7processEv+0x6c>
 76a:	ce 01       	movw	r24, r28
 76c:	0e 94 04 01 	call	0x208	; 0x208 <_ZN3NRF18waitingForResponseEv>
 770:	88 23       	and	r24, r24
 772:	09 f4       	brne	.+2      	; 0x776 <_ZN3NRF7processEv+0x36>
 774:	ca c0       	rjmp	.+404    	; 0x90a <__stack+0xb>
 776:	1a c0       	rjmp	.+52     	; 0x7ac <_ZN3NRF7processEv+0x6c>
		//load current line of setup msg into TX buffer
		for(int i = 0; i <= setup_msgs[initCount].buffer[0]; i++){
#ifdef PROGRAMSPACE			
			TxData[i] = pgm_read_byte(&setup_msgs[initCount].buffer[i]);
#else
			TxData[i] = setup_msgs[initCount].buffer[i];
 778:	dc 01       	movw	r26, r24
 77a:	a2 0f       	add	r26, r18
 77c:	b3 1f       	adc	r27, r19
 77e:	11 96       	adiw	r26, 0x01	; 1
 780:	6c 91       	ld	r22, X
 782:	61 93       	st	Z+, r22
		
	
	//setup message from services.h file loaded onto nRF8001
	if( (mode == NRF_MODE_SETUP)  && !hasDataToSend() && !waitingForResponse() ) {
		//load current line of setup msg into TX buffer
		for(int i = 0; i <= setup_msgs[initCount].buffer[0]; i++){
 784:	2f 5f       	subi	r18, 0xFF	; 255
 786:	3f 4f       	sbci	r19, 0xFF	; 255
 788:	42 17       	cp	r20, r18
 78a:	53 07       	cpc	r21, r19
 78c:	ac f7       	brge	.-22     	; 0x778 <_ZN3NRF7processEv+0x38>
			TxData[i] = setup_msgs[initCount].buffer[i];
#endif
		}
		
		//set transmit ready and wait for response flags in status register
		status |= ((1<<NRF_TX_READY));
 78e:	9a 8d       	ldd	r25, Y+26	; 0x1a
 790:	90 64       	ori	r25, 0x40	; 64
 792:	9a 8f       	std	Y+26, r25	; 0x1a
		
		initCount++;
 794:	81 e0       	ldi	r24, 0x01	; 1
 796:	87 0f       	add	r24, r23
		////after the last setup message
		if (initCount > NB_SETUP_MESSAGES) 
 798:	84 31       	cpi	r24, 0x14	; 20
 79a:	18 f4       	brcc	.+6      	; 0x7a2 <_ZN3NRF7processEv+0x62>
		}
		
		//set transmit ready and wait for response flags in status register
		status |= ((1<<NRF_TX_READY));
		
		initCount++;
 79c:	80 93 74 03 	sts	0x0374, r24
 7a0:	05 c0       	rjmp	.+10     	; 0x7ac <_ZN3NRF7processEv+0x6c>
		////after the last setup message
		if (initCount > NB_SETUP_MESSAGES) 
		{
			initCount = 0;
 7a2:	10 92 74 03 	sts	0x0374, r1
			
			clearTxData();
 7a6:	ce 01       	movw	r24, r28
 7a8:	0e 94 3c 01 	call	0x278	; 0x278 <_ZN3NRF11clearTxDataEv>
}
uint8_t NRF::hasDataToSend(void){
	return ((status & (1<<NRF_TX_READY))?TRUE:FALSE);
}
uint8_t NRF::isReadyToReceiveData(){
	return ((status & (1<<NRF_RX_READY))?TRUE:FALSE);
 7ac:	1a 8d       	ldd	r17, Y+26	; 0x1a
	}//setup message
	
	
	//handle messages received from nRF8001
	//else //testing**************************************************************************************
	if (!isReadyToReceiveData()){
 7ae:	11 23       	and	r17, r17
 7b0:	0c f4       	brge	.+2      	; 0x7b4 <_ZN3NRF7processEv+0x74>
 7b2:	a0 c0       	rjmp	.+320    	; 0x8f4 <_ZN3NRF7processEv+0x1b4>
		RxCount++;
 7b4:	8d 89       	ldd	r24, Y+21	; 0x15
 7b6:	91 e0       	ldi	r25, 0x01	; 1
 7b8:	98 0f       	add	r25, r24
 7ba:	9d 8b       	std	Y+21, r25	; 0x15
				
		switch (RxData[1]){
 7bc:	4c 8d       	ldd	r20, Y+28	; 0x1c
 7be:	50 e0       	ldi	r21, 0x00	; 0
 7c0:	fa 01       	movw	r30, r20
 7c2:	e1 58       	subi	r30, 0x81	; 129
 7c4:	f1 09       	sbc	r31, r1
 7c6:	ef 30       	cpi	r30, 0x0F	; 15
 7c8:	f1 05       	cpc	r31, r1
 7ca:	08 f0       	brcs	.+2      	; 0x7ce <_ZN3NRF7processEv+0x8e>
 7cc:	8e c0       	rjmp	.+284    	; 0x8ea <_ZN3NRF7processEv+0x1aa>
 7ce:	ee 5a       	subi	r30, 0xAE	; 174
 7d0:	ff 4f       	sbci	r31, 0xFF	; 255
 7d2:	0c 94 ba 06 	jmp	0xd74	; 0xd74 <__tablejump2__>
				//RxData[2]		:	service pipe number
				//RxData[3..23]	:	Data
				
				// Fill data with RxData values
				
				for (i = 0; i< RxData[0] - 1;i++){
 7d6:	5b 8d       	ldd	r21, Y+27	; 0x1b
 7d8:	25 2f       	mov	r18, r21
 7da:	30 e0       	ldi	r19, 0x00	; 0
 7dc:	21 50       	subi	r18, 0x01	; 1
 7de:	31 09       	sbc	r19, r1
 7e0:	12 16       	cp	r1, r18
 7e2:	13 06       	cpc	r1, r19
 7e4:	0c f4       	brge	.+2      	; 0x7e8 <_ZN3NRF7processEv+0xa8>
 7e6:	6b c0       	rjmp	.+214    	; 0x8be <_ZN3NRF7processEv+0x17e>
 7e8:	78 c0       	rjmp	.+240    	; 0x8da <_ZN3NRF7processEv+0x19a>
				//					0x02	Setup
				//					0x03	Standby
				//RxData[3]	:	HWError 0x01 = error, 0x00 = no error
				//RxData[4]	:	DataCreditAvailable - Number of DataCommand buffers available
				
				if (RxData[2]>0)
 7ea:	8d 8d       	ldd	r24, Y+29	; 0x1d
 7ec:	88 23       	and	r24, r24
 7ee:	21 f0       	breq	.+8      	; 0x7f8 <_ZN3NRF7processEv+0xb8>
					mode = RxData[2];
 7f0:	fe 01       	movw	r30, r28
 7f2:	ef 58       	subi	r30, 0x8F	; 143
 7f4:	ff 4f       	sbci	r31, 0xFF	; 255
 7f6:	80 83       	st	Z, r24
				
				status &= ~(1<<NRF_SLEEPING);
 7f8:	81 2f       	mov	r24, r17
 7fa:	8d 7f       	andi	r24, 0xFD	; 253
 7fc:	8a 8f       	std	Y+26, r24	; 0x1a
				
				//when NRF_CMD_WAKEUP has been called, the NRF_WAIT_FOR_RESPONSE bit in the status register should NOT be cleared
				//when finishing a NRF_CMD_SETUP, the NRF_WAIT_FOR_RESPONSE bit in the status register SHOULD be cleared
				if (mode == NRF_MODE_SETUP){
 7fe:	fe 01       	movw	r30, r28
 800:	ef 58       	subi	r30, 0x8F	; 143
 802:	ff 4f       	sbci	r31, 0xFF	; 255
 804:	80 81       	ld	r24, Z
 806:	82 30       	cpi	r24, 0x02	; 2
 808:	19 f4       	brne	.+6      	; 0x810 <_ZN3NRF7processEv+0xd0>
				//if (isInitializing()){
					//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
					status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 80a:	1d 7e       	andi	r17, 0xED	; 237
 80c:	1a 8f       	std	Y+26, r17	; 0x1a
 80e:	0a c0       	rjmp	.+20     	; 0x824 <_ZN3NRF7processEv+0xe4>
					
				}
				
				
				if (mode == NRF_MODE_STANDBY){
 810:	83 30       	cpi	r24, 0x03	; 3
 812:	41 f4       	brne	.+16     	; 0x824 <_ZN3NRF7processEv+0xe4>
					//clear the NRF_INIT_MODE bit in the status register when SETUP finishes
					//status &= ~(1<<NRF_INIT_MODE);
					dataCredit = RxData[4];
 814:	8f 8d       	ldd	r24, Y+31	; 0x1f
 816:	fe 01       	movw	r30, r28
 818:	ee 58       	subi	r30, 0x8E	; 142
 81a:	ff 4f       	sbci	r31, 0xFF	; 255
 81c:	80 83       	st	Z, r24
					status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 81e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 820:	8f 7e       	andi	r24, 0xEF	; 239
 822:	8a 8f       	std	Y+26, r24	; 0x1a
				}
				
				
				
				//set the NRF_RX_READY bit in the status register
				status |= (1<<NRF_RX_READY);
 824:	8a 8d       	ldd	r24, Y+26	; 0x1a
 826:	80 68       	ori	r24, 0x80	; 128
 828:	8a 8f       	std	Y+26, r24	; 0x1a
				
				//TODO: error handling
				break;
 82a:	60 c0       	rjmp	.+192    	; 0x8ec <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_ECHO:				//0x82
				//returns an identical copy of the PDU sent using the echo command in Test Mode
				//RxData[0]	:	length
				//RxData[1]	:	NRF_EVT_ECHO (0x82)
				//RxData[2..31]	:	Identical message to one sent with NRF_CMD_ECHO
				data[0] = RxData[0];
 82c:	8b 8d       	ldd	r24, Y+27	; 0x1b
 82e:	88 83       	st	Y, r24
				data[1] = RxData[1];
 830:	82 e8       	ldi	r24, 0x82	; 130
 832:	89 83       	std	Y+1, r24	; 0x01
				data[2] = RxData[2];
 834:	8d 8d       	ldd	r24, Y+29	; 0x1d
 836:	8a 83       	std	Y+2, r24	; 0x02
				data[3] = RxData[3];
 838:	8e 8d       	ldd	r24, Y+30	; 0x1e
 83a:	8b 83       	std	Y+3, r24	; 0x03
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 83c:	1f 7e       	andi	r17, 0xEF	; 239
 83e:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 840:	55 c0       	rjmp	.+170    	; 0x8ec <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_HARDWARE_ERROR:	//0x83
				//provides debug information
				//in case of firmware failure, this event follows NRF_EVT_DEVICE_STARTED
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 842:	1f 7e       	andi	r17, 0xEF	; 239
 844:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 846:	52 c0       	rjmp	.+164    	; 0x8ec <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_COMMAND_RESPONSE:	//0x84
				//confirms reception or execution of an ACI command
				processCommandResponse();				
 848:	ce 01       	movw	r24, r28
 84a:	0e 94 26 03 	call	0x64c	; 0x64c <_ZN3NRF22processCommandResponseEv>
				break;
 84e:	4e c0       	rjmp	.+156    	; 0x8ec <_ZN3NRF7processEv+0x1ac>
				status |= (1<<NRF_CONNECTED);
				
							//do NOT clear the NRF_WAIT_FOR_RESPONSE bit of the status register here
							//there will be either a NRF_EVT_BOND_STATUS or a NRF_EVT_PIPE_STATUS following NRF_EVT_CONNECTED
				//actually it seems to need to be cleared here
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 850:	81 2f       	mov	r24, r17
 852:	8f 7e       	andi	r24, 0xEF	; 239
 854:	88 60       	ori	r24, 0x08	; 8
 856:	8a 8f       	std	Y+26, r24	; 0x1a
				
				break;
 858:	49 c0       	rjmp	.+146    	; 0x8ec <_ZN3NRF7processEv+0x1ac>
				
				//TODO: can we be still connected if we get here through a failure to bond
				status &= ~(1<<NRF_CONNECTED | 1<<NRF_BONDED);
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 85a:	13 7e       	andi	r17, 0xE3	; 227
 85c:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 85e:	46 c0       	rjmp	.+140    	; 0x8ec <_ZN3NRF7processEv+0x1ac>
				//					0x02		: generated by the remote peer.
				//	4		:	BondStatus-SecMode1 - LE Security Mode 1
				//	5		:	LE Security Mode 2
				//	6		:	Keys Exchanged (slave)
				//	7		:	Keys Exchanged (master)
				if (RxData[2] == 0x00){ // successful bond
 860:	8d 8d       	ldd	r24, Y+29	; 0x1d
 862:	81 11       	cpse	r24, r1
 864:	02 c0       	rjmp	.+4      	; 0x86a <_ZN3NRF7processEv+0x12a>
					status |= (1<<NRF_BONDED);
 866:	14 60       	ori	r17, 0x04	; 4
 868:	1a 8f       	std	Y+26, r17	; 0x1a
				}
				
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 86a:	8a 8d       	ldd	r24, Y+26	; 0x1a
 86c:	8f 7e       	andi	r24, 0xEF	; 239
 86e:	8a 8f       	std	Y+26, r24	; 0x1a
				break;
 870:	3d c0       	rjmp	.+122    	; 0x8ec <_ZN3NRF7processEv+0x1ac>
 872:	fe 01       	movw	r30, r28
 874:	ed 59       	subi	r30, 0x9D	; 157
 876:	ff 4f       	sbci	r31, 0xFF	; 255
	//handle messages received from nRF8001
	//else //testing**************************************************************************************
	if (!isReadyToReceiveData()){
		RxCount++;
				
		switch (RxData[1]){
 878:	80 e0       	ldi	r24, 0x00	; 0
 87a:	df 01       	movw	r26, r30
 87c:	a6 54       	subi	r26, 0x46	; 70
 87e:	b1 09       	sbc	r27, r1
				//this event is sent when there is a change in service pipe availability
				//RxData[2..9]		: 64-bit PipesOpen bitmap
				//RxData[10..17]	: 64-bit PipesClosed bitmap
				//see pg 148 of datasheet for details
				for (i = 0 ; i<8; i++){
					pipesOpen[i] = RxData[i+2];
 880:	9c 91       	ld	r25, X
 882:	de 96       	adiw	r26, 0x3e	; 62
 884:	9c 93       	st	X, r25
 886:	d6 97       	sbiw	r26, 0x36	; 54
					pipesClosed[i] = RxData[i+10];
 888:	9c 91       	ld	r25, X
 88a:	91 93       	st	Z+, r25
			case NRF_EVT_PIPE_STATUS:
				//this event is sent when there is a change in service pipe availability
				//RxData[2..9]		: 64-bit PipesOpen bitmap
				//RxData[10..17]	: 64-bit PipesClosed bitmap
				//see pg 148 of datasheet for details
				for (i = 0 ; i<8; i++){
 88c:	8f 5f       	subi	r24, 0xFF	; 255
 88e:	88 30       	cpi	r24, 0x08	; 8
 890:	a1 f7       	brne	.-24     	; 0x87a <_ZN3NRF7processEv+0x13a>
					pipesOpen[i] = RxData[i+2];
					pipesClosed[i] = RxData[i+10];
				}
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 892:	1f 7e       	andi	r17, 0xEF	; 239
 894:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 896:	2a c0       	rjmp	.+84     	; 0x8ec <_ZN3NRF7processEv+0x1ac>
				//RxData[2-3]	: ConnectionInterval (MSB first)
				//RxData[4-5]	: SlaveLatency (LSB/MSB)
				//RxData[6-7]	: SupervisionTimeout (x10ms)
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 898:	1f 7e       	andi	r17, 0xEF	; 239
 89a:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 89c:	27 c0       	rjmp	.+78     	; 0x8ec <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_DISPLAY_KEY:
				//RxData[2..7] A fixed 6-byte ASCII string representing the passkey
				//padded with zeros if shorter than 6 digits
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 89e:	1f 7e       	andi	r17, 0xEF	; 239
 8a0:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 8a2:	24 c0       	rjmp	.+72     	; 0x8ec <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_KEY_REQUEST:
				//RxData[2] : key requested
				//must send the SetKey command within 30 seconds after receiving this command
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 8a4:	1f 7e       	andi	r17, 0xEF	; 239
 8a6:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 8a8:	21 c0       	rjmp	.+66     	; 0x8ec <_ZN3NRF7processEv+0x1ac>
			//Data Events:
			case NRF_EVT_DATA_CREDIT:		//0x8A
				//RxData[2]	:	number of data credits returned to the application controller
				dataCredit += RxData[2];	
 8aa:	fe 01       	movw	r30, r28
 8ac:	ee 58       	subi	r30, 0x8E	; 142
 8ae:	ff 4f       	sbci	r31, 0xFF	; 255
 8b0:	9d 8d       	ldd	r25, Y+29	; 0x1d
 8b2:	80 81       	ld	r24, Z
 8b4:	89 0f       	add	r24, r25
 8b6:	80 83       	st	Z, r24
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);			
 8b8:	1f 7e       	andi	r17, 0xEF	; 239
 8ba:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 8bc:	17 c0       	rjmp	.+46     	; 0x8ec <_ZN3NRF7processEv+0x1ac>
				//RxData[2]		:	service pipe number
				//RxData[3..23]	:	Data
				
				// Fill data with RxData values
				
				for (i = 0; i< RxData[0] - 1;i++){
 8be:	80 e0       	ldi	r24, 0x00	; 0
 8c0:	90 e0       	ldi	r25, 0x00	; 0
 8c2:	40 e0       	ldi	r20, 0x00	; 0
					data[i] = RxData[0] + 2;
 8c4:	5e 5f       	subi	r21, 0xFE	; 254
 8c6:	fe 01       	movw	r30, r28
 8c8:	e8 0f       	add	r30, r24
 8ca:	f9 1f       	adc	r31, r25
 8cc:	50 83       	st	Z, r21
				//RxData[2]		:	service pipe number
				//RxData[3..23]	:	Data
				
				// Fill data with RxData values
				
				for (i = 0; i< RxData[0] - 1;i++){
 8ce:	4f 5f       	subi	r20, 0xFF	; 255
 8d0:	84 2f       	mov	r24, r20
 8d2:	90 e0       	ldi	r25, 0x00	; 0
 8d4:	82 17       	cp	r24, r18
 8d6:	93 07       	cpc	r25, r19
 8d8:	b4 f3       	brlt	.-20     	; 0x8c6 <_ZN3NRF7processEv+0x186>
				
				//set data flag in status
				status |= (1<<NRF_DATA_TO_PROCESS);
								
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 8da:	81 2f       	mov	r24, r17
 8dc:	8f 7e       	andi	r24, 0xEF	; 239
 8de:	80 62       	ori	r24, 0x20	; 32
 8e0:	8a 8f       	std	Y+26, r24	; 0x1a
				break;
 8e2:	04 c0       	rjmp	.+8      	; 0x8ec <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_PIPE_ERROR:
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 8e4:	1f 7e       	andi	r17, 0xEF	; 239
 8e6:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 8e8:	01 c0       	rjmp	.+2      	; 0x8ec <_ZN3NRF7processEv+0x1ac>
			default:			
				RxCount--;
 8ea:	8d 8b       	std	Y+21, r24	; 0x15
				//RxData[0] = 0x00;					
				break;
		}//end switch		
		
		//set the NRF_RX_READY bit in the status register
		status |= (1<<NRF_RX_READY);
 8ec:	8a 8d       	ldd	r24, Y+26	; 0x1a
 8ee:	80 68       	ori	r24, 0x80	; 128
 8f0:	8a 8f       	std	Y+26, r24	; 0x1a
 8f2:	20 c0       	rjmp	.+64     	; 0x934 <__stack+0x35>
	else{
		//Receive Buffer doesn't contain useful data
		
		//if nRF8001 is requesting transfer, receive it
		//if we have data to send, send it
		if ((RDYN == 0) || (hasDataToSend())) {			
 8f4:	2a 9b       	sbis	0x05, 2	; 5
 8f6:	05 c0       	rjmp	.+10     	; 0x902 <__stack+0x3>
 8f8:	ce 01       	movw	r24, r28
 8fa:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 8fe:	88 23       	and	r24, r24
 900:	c9 f0       	breq	.+50     	; 0x934 <__stack+0x35>
			transferACI();
 902:	ce 01       	movw	r24, r28
 904:	0e 94 a1 02 	call	0x542	; 0x542 <_ZN3NRF11transferACIEv>
 908:	15 c0       	rjmp	.+42     	; 0x934 <__stack+0x35>
		
	
	//setup message from services.h file loaded onto nRF8001
	if( (mode == NRF_MODE_SETUP)  && !hasDataToSend() && !waitingForResponse() ) {
		//load current line of setup msg into TX buffer
		for(int i = 0; i <= setup_msgs[initCount].buffer[0]; i++){
 90a:	70 91 74 03 	lds	r23, 0x0374
 90e:	61 e2       	ldi	r22, 0x21	; 33
 910:	76 9f       	mul	r23, r22
 912:	f0 01       	movw	r30, r0
 914:	11 24       	eor	r1, r1
 916:	e0 50       	subi	r30, 0x00	; 0
 918:	ff 4f       	sbci	r31, 0xFF	; 255
 91a:	41 81       	ldd	r20, Z+1	; 0x01
 91c:	50 e0       	ldi	r21, 0x00	; 0
 91e:	fe 01       	movw	r30, r28
 920:	fb 96       	adiw	r30, 0x3b	; 59
 922:	20 e0       	ldi	r18, 0x00	; 0
 924:	30 e0       	ldi	r19, 0x00	; 0
#ifdef PROGRAMSPACE			
			TxData[i] = pgm_read_byte(&setup_msgs[initCount].buffer[i]);
#else
			TxData[i] = setup_msgs[initCount].buffer[i];
 926:	61 e2       	ldi	r22, 0x21	; 33
 928:	76 9f       	mul	r23, r22
 92a:	c0 01       	movw	r24, r0
 92c:	11 24       	eor	r1, r1
 92e:	80 50       	subi	r24, 0x00	; 0
 930:	9f 4f       	sbci	r25, 0xFF	; 255
 932:	22 cf       	rjmp	.-444    	; 0x778 <_ZN3NRF7processEv+0x38>
		if ((RDYN == 0) || (hasDataToSend())) {			
			transferACI();
			
		}
	}//else RxData
}//process
 934:	df 91       	pop	r29
 936:	cf 91       	pop	r28
 938:	1f 91       	pop	r17
 93a:	08 95       	ret

0000093c <_GLOBAL__sub_I_spi>:
	//(1<<MSTR)|             // Master/Slave select
	//(0<<SPR1)|(1<<SPR0)|   // SPI Clock Rate
	//(0<<CPOL)|             // Clock Polarity (0:SCK low / 1:SCK hi when idle)
	//(0<<CPHA))             // Clock Phase (0:leading / 1:trailing edge sampling)

SPI spi(SPI_SETTING);
 93c:	63 e7       	ldi	r22, 0x73	; 115
 93e:	85 e7       	ldi	r24, 0x75	; 117
 940:	93 e0       	ldi	r25, 0x03	; 3
 942:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <_ZN3SPIC1Eh>
 946:	08 95       	ret

00000948 <_ZN6TIMER1C1Ehhj>:
TIMER1::TIMER1(){
	TIMER1(TIMER_DIV1, 0, 0);
}

///@brief initialize AD converter on Atmega168 for
TIMER1::TIMER1(uint8_t pscalar, uint8_t WGMmode, uint16_t rload){
 948:	fc 01       	movw	r30, r24
	reload = rload;
 94a:	33 83       	std	Z+3, r19	; 0x03
 94c:	22 83       	std	Z+2, r18	; 0x02
	mode = WGMmode;
 94e:	41 83       	std	Z+1, r20	; 0x01
	prescalar = pscalar;
 950:	60 83       	st	Z, r22
	
	// The PRTIM1 bit in the Power reduction register must be written to zero to enable Timer/Counter1 module.
	PRR &= ~(1<<PRTIM1);
 952:	a4 e6       	ldi	r26, 0x64	; 100
 954:	b0 e0       	ldi	r27, 0x00	; 0
 956:	8c 91       	ld	r24, X
 958:	87 7f       	andi	r24, 0xF7	; 247
 95a:	8c 93       	st	X, r24
	
	//disable timer1
	TCCR1B = 0x00;
 95c:	10 92 81 00 	sts	0x0081, r1
	
	//clear counter	
	TCNT1 = 0;
 960:	10 92 85 00 	sts	0x0085, r1
 964:	10 92 84 00 	sts	0x0084, r1
	
	//set reload value
	if (mode == 4) OCR1A = reload;
 968:	81 81       	ldd	r24, Z+1	; 0x01
 96a:	84 30       	cpi	r24, 0x04	; 4
 96c:	31 f4       	brne	.+12     	; 0x97a <_ZN6TIMER1C1Ehhj+0x32>
 96e:	82 81       	ldd	r24, Z+2	; 0x02
 970:	93 81       	ldd	r25, Z+3	; 0x03
 972:	90 93 89 00 	sts	0x0089, r25
 976:	80 93 88 00 	sts	0x0088, r24
	if (mode == 12) ICR1 = reload;
 97a:	81 81       	ldd	r24, Z+1	; 0x01
 97c:	8c 30       	cpi	r24, 0x0C	; 12
 97e:	31 f4       	brne	.+12     	; 0x98c <_ZN6TIMER1C1Ehhj+0x44>
 980:	82 81       	ldd	r24, Z+2	; 0x02
 982:	93 81       	ldd	r25, Z+3	; 0x03
 984:	90 93 87 00 	sts	0x0087, r25
 988:	80 93 86 00 	sts	0x0086, r24
	if (mode == 0) TCNT1 = reload;
 98c:	81 81       	ldd	r24, Z+1	; 0x01
 98e:	81 11       	cpse	r24, r1
 990:	06 c0       	rjmp	.+12     	; 0x99e <_ZN6TIMER1C1Ehhj+0x56>
 992:	82 81       	ldd	r24, Z+2	; 0x02
 994:	93 81       	ldd	r25, Z+3	; 0x03
 996:	90 93 85 00 	sts	0x0085, r25
 99a:	80 93 84 00 	sts	0x0084, r24
	
	//setup and enable timer
	TCCR1A = (mode & 0x03);		//normal timer operation, no PWM, etc
 99e:	81 81       	ldd	r24, Z+1	; 0x01
 9a0:	83 70       	andi	r24, 0x03	; 3
 9a2:	80 93 80 00 	sts	0x0080, r24
	//TCCR1B = ((mode & 0x0C)<<WGM12) | (prescalar << CS10);
	TCCR1C = 0x00;		//force output compare off	
 9a6:	10 92 82 00 	sts	0x0082, r1
 9aa:	08 95       	ret

000009ac <_ZN6TIMER15startEv>:
	//sei();
}

void	TIMER1::start(void)
{
	TCCR1B = ((mode & 0x0C)<<WGM12) | (prescalar << CS10);
 9ac:	fc 01       	movw	r30, r24
 9ae:	21 81       	ldd	r18, Z+1	; 0x01
 9b0:	2c 70       	andi	r18, 0x0C	; 12
 9b2:	22 0f       	add	r18, r18
 9b4:	22 0f       	add	r18, r18
 9b6:	22 0f       	add	r18, r18
 9b8:	90 81       	ld	r25, Z
 9ba:	82 2f       	mov	r24, r18
 9bc:	89 2b       	or	r24, r25
 9be:	80 93 81 00 	sts	0x0081, r24
 9c2:	08 95       	ret

000009c4 <_ZN6TIMER117isCompareAFlagSetEv>:
	return ((TIFR1 & 1<<TOV1)? 1:0);
	//return ((EIFR & 1<< INTF0)?1:0);
}

uint8_t TIMER1::isCompareAFlagSet(){
	return ((TIFR1 & 1<<OCF1A)? 1:0);
 9c4:	86 b3       	in	r24, 0x16	; 22
	
}
 9c6:	86 95       	lsr	r24
 9c8:	81 70       	andi	r24, 0x01	; 1
 9ca:	08 95       	ret

000009cc <_ZN6TIMER117clearCompareAFlagEv>:
	
	//EIFR = (1<<INTF0);		//Reset flag
}

void	TIMER1::clearCompareAFlag(){
	TIFR1 |= (1<<OCF1A);
 9cc:	b1 9a       	sbi	0x16, 1	; 22
 9ce:	08 95       	ret

000009d0 <_ZN6TIMER18setCountEj>:
	
	//EIFR = (1<<INTF0);		//Reset flag
}

void	TIMER1::setCount(uint16_t count){
	TCNT1 = count;
 9d0:	70 93 85 00 	sts	0x0085, r23
 9d4:	60 93 84 00 	sts	0x0084, r22
 9d8:	08 95       	ret

000009da <main>:
//  3. SLEEP;
//	4. After waking, DisableSleep()

#pragma endregion sleep

int main(void){	
 9da:	cf 93       	push	r28
 9dc:	df 93       	push	r29
 9de:	cd b7       	in	r28, 0x3d	; 61
 9e0:	de b7       	in	r29, 0x3e	; 62
 9e2:	2d 97       	sbiw	r28, 0x0d	; 13
 9e4:	0f b6       	in	r0, 0x3f	; 63
 9e6:	f8 94       	cli
 9e8:	de bf       	out	0x3e, r29	; 62
 9ea:	0f be       	out	0x3f, r0	; 63
 9ec:	cd bf       	out	0x3d, r28	; 61
	//timer
	// 8MHz/90Hz			= 88,888.8888 cycles to count
	// 88,888.888 / 8 (div8)	= 11,111 = 0x2B67
	
	//prescalar, mode, reload
	TIMER1 timer(TIMER_DIV8, 4, 0x2B67);
 9ee:	27 e6       	ldi	r18, 0x67	; 103
 9f0:	3b e2       	ldi	r19, 0x2B	; 43
 9f2:	44 e0       	ldi	r20, 0x04	; 4
 9f4:	62 e0       	ldi	r22, 0x02	; 2
 9f6:	ce 01       	movw	r24, r28
 9f8:	08 96       	adiw	r24, 0x08	; 8
 9fa:	0e 94 a4 04 	call	0x948	; 0x948 <_ZN6TIMER1C1Ehhj>
	
	//pin, prescalar
	ANALOG sensor(ADC_PIN, ADC_DIV64);
 9fe:	46 e0       	ldi	r20, 0x06	; 6
 a00:	60 e0       	ldi	r22, 0x00	; 0
 a02:	ce 01       	movw	r24, r28
 a04:	0c 96       	adiw	r24, 0x0c	; 12
 a06:	0e 94 b1 00 	call	0x162	; 0x162 <_ZN6ANALOGC1Ehh>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 a0a:	2f ef       	ldi	r18, 0xFF	; 255
 a0c:	84 e3       	ldi	r24, 0x34	; 52
 a0e:	9c e0       	ldi	r25, 0x0C	; 12
 a10:	21 50       	subi	r18, 0x01	; 1
 a12:	80 40       	sbci	r24, 0x00	; 0
 a14:	90 40       	sbci	r25, 0x00	; 0
 a16:	e1 f7       	brne	.-8      	; 0xa10 <main+0x36>
 a18:	00 c0       	rjmp	.+0      	; 0xa1a <main+0x40>
 a1a:	00 00       	nop
#endif
	
	_delay_ms(500);
	
	//d6,d7 - LEDs
	DDRD = 0xE0;			//set PD7:6 to outputs for LEDs
 a1c:	80 ee       	ldi	r24, 0xE0	; 224
 a1e:	8a b9       	out	0x0a, r24	; 10
	//PD2 as an input for switch
	RED_ON;					//Set PD7 high and PD6 low
 a20:	55 98       	cbi	0x0a, 5	; 10
 a22:	89 b1       	in	r24, 0x09	; 9
 a24:	8f 73       	andi	r24, 0x3F	; 63
 a26:	80 68       	ori	r24, 0x80	; 128
 a28:	8b b9       	out	0x0b, r24	; 11
	//while (1);
	//Switch
	PORTD = (1<<PD2);		//set PD2 to high(pullup resistor) for switch
 a2a:	84 e0       	ldi	r24, 0x04	; 4
 a2c:	8b b9       	out	0x0b, r24	; 11
	
	//External Interrupt Mask Register
	EIMSK |= (1<<INT0);	//turn on interrupt 0 (PD2)
 a2e:	e8 9a       	sbi	0x1d, 0	; 29
	
	////External Interrupt Control Register A
	//EICRA = 0x02;		//Interrupt on falling edge of INT0
	EICRA = 0x00;		//Interrupt on low level of INT0
 a30:	10 92 69 00 	sts	0x0069, r1
	
	//opamp is Powered Down when PD is low, initialize HIGH?
	//250nS delay when powering up, 50nS delay when powering down (1/8MHz = 125nS)
	WakeOpAmp();
 a34:	41 9a       	sbi	0x08, 1	; 8
	sensor.clearFlag();
 a36:	ce 01       	movw	r24, r28
 a38:	0c 96       	adiw	r24, 0x0c	; 12
 a3a:	0e 94 c6 00 	call	0x18c	; 0x18c <_ZN6ANALOG9clearFlagEv>
 a3e:	ef ef       	ldi	r30, 0xFF	; 255
 a40:	f4 e3       	ldi	r31, 0x34	; 52
 a42:	2c e0       	ldi	r18, 0x0C	; 12
 a44:	e1 50       	subi	r30, 0x01	; 1
 a46:	f0 40       	sbci	r31, 0x00	; 0
 a48:	20 40       	sbci	r18, 0x00	; 0
 a4a:	e1 f7       	brne	.-8      	; 0xa44 <main+0x6a>
 a4c:	00 c0       	rjmp	.+0      	; 0xa4e <main+0x74>
 a4e:	00 00       	nop
		
	_delay_ms(500);
#ifdef TESTMODE	
	lcdClearDisplay();
#endif	
	RED_ON; //TESTING
 a50:	55 98       	cbi	0x0a, 5	; 10
 a52:	89 b1       	in	r24, 0x09	; 9
 a54:	8f 73       	andi	r24, 0x3F	; 63
 a56:	80 68       	ori	r24, 0x80	; 128
 a58:	8b b9       	out	0x0b, r24	; 11
	enum lights_t {I,R,O} led_state = R;
		 
	state_t state = INIT;
	uint8_t oxygenSaturationData[PIPE_OXYGEN_SATURATION_O2_SET_MAX_SIZE];// = {0,1,2,3,4,5,6};
	uint8_t count = 0;
	uint8_t settings = 0x00;
 a5a:	91 2c       	mov	r9, r1
	ANALOG sensor(ADC_PIN, ADC_DIV64);
	
	enum state_t {INIT = 0x00, CONNECT, CONNECTING, SEND, RECEIVE, IDLE, GO2SLEEP, WAKEUP};
	enum lights_t {I,R,O} led_state = R;
		 
	state_t state = INIT;
 a5c:	81 2c       	mov	r8, r1
	
	//pin, prescalar
	ANALOG sensor(ADC_PIN, ADC_DIV64);
	
	enum state_t {INIT = 0x00, CONNECT, CONNECTING, SEND, RECEIVE, IDLE, GO2SLEEP, WAKEUP};
	enum lights_t {I,R,O} led_state = R;
 a5e:	33 24       	eor	r3, r3
 a60:	33 94       	inc	r3
			if (nrf.data[0] == PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX){
				settings = nrf.data[1];				
			}
			nrf.dataHasBeenProcessed();
			if (settings == PULSEOX_GO_TO_SLEEP)
				state = GO2SLEEP;
 a62:	0f 2e       	mov	r0, r31
 a64:	f6 e0       	ldi	r31, 0x06	; 6
 a66:	7f 2e       	mov	r7, r31
 a68:	f0 2d       	mov	r31, r0
	RED_ON; //TESTING
	
	while(1){		
		if (nrf.hasDataToProcess()){
			if (nrf.data[0] == PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX){
				settings = nrf.data[1];				
 a6a:	0f 2e       	mov	r0, r31
 a6c:	f8 e7       	ldi	r31, 0x78	; 120
 a6e:	ef 2e       	mov	r14, r31
 a70:	f3 e0       	ldi	r31, 0x03	; 3
 a72:	ff 2e       	mov	r15, r31
 a74:	f0 2d       	mov	r31, r0
			nrf.dataHasBeenProcessed();
			if (settings == PULSEOX_GO_TO_SLEEP)
				state = GO2SLEEP;
		}
		
		if (nrf.mode == NRF_MODE_STANDBY){			
 a76:	08 ee       	ldi	r16, 0xE8	; 232
 a78:	13 e0       	ldi	r17, 0x03	; 3
 a7a:	0f 2e       	mov	r0, r31
 a7c:	f7 e0       	ldi	r31, 0x07	; 7
 a7e:	4f 2e       	mov	r4, r31
 a80:	f0 2d       	mov	r31, r0
					if (nrf.isSleeping() && !nrf.hasDataToSend()){
						nrf.wakeup();
					}
					
					if (!nrf.isSleeping() && !nrf.hasDataToSend()){						
						state = CONNECT;
 a82:	55 24       	eor	r5, r5
 a84:	53 94       	inc	r5
#define SLEEP_MODE_STANDBY		0b110
#define EnableSleep() 			SMCR |= (1<<SE)
#define DisableSleep()			SMCR &= ~(1<<SE)
void SetSleepMode(uint8_t mode){
	if((mode == SLEEP_MODE_STANDBY) | (mode<=SLEEP_MODE_POWER_SAVE))
	SMCR = (mode<<SM0);
 a86:	68 94       	set
 a88:	22 24       	eor	r2, r2
 a8a:	22 f8       	bld	r2, 2
									oxygenSaturationData[6*count+5] = ADCH;
									RED_ON;
									led_state = R;
									break;
								case R:
									oxygenSaturationData[6*count+2] = ADCL;
 a8c:	0f 2e       	mov	r0, r31
 a8e:	f8 e7       	ldi	r31, 0x78	; 120
 a90:	af 2e       	mov	r10, r31
 a92:	b1 2c       	mov	r11, r1
 a94:	f0 2d       	mov	r31, r0
									oxygenSaturationData[6*count+1] = ADCH;
 a96:	0f 2e       	mov	r0, r31
 a98:	f9 e7       	ldi	r31, 0x79	; 121
 a9a:	cf 2e       	mov	r12, r31
 a9c:	d1 2c       	mov	r13, r1
 a9e:	f0 2d       	mov	r31, r0
									IR_ON;
									led_state = I;
 aa0:	61 2c       	mov	r6, r1
	lcdClearDisplay();
#endif	
	RED_ON; //TESTING
	
	while(1){		
		if (nrf.hasDataToProcess()){
 aa2:	87 e7       	ldi	r24, 0x77	; 119
 aa4:	93 e0       	ldi	r25, 0x03	; 3
 aa6:	0e 94 0f 01 	call	0x21e	; 0x21e <_ZN3NRF16hasDataToProcessEv>
 aaa:	88 23       	and	r24, r24
 aac:	71 f0       	breq	.+28     	; 0xaca <main+0xf0>
			if (nrf.data[0] == PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX){
 aae:	80 91 77 03 	lds	r24, 0x0377
 ab2:	82 30       	cpi	r24, 0x02	; 2
 ab4:	11 f4       	brne	.+4      	; 0xaba <main+0xe0>
				settings = nrf.data[1];				
 ab6:	f7 01       	movw	r30, r14
 ab8:	90 80       	ld	r9, Z
			}
			nrf.dataHasBeenProcessed();
 aba:	87 e7       	ldi	r24, 0x77	; 119
 abc:	93 e0       	ldi	r25, 0x03	; 3
 abe:	0e 94 15 01 	call	0x22a	; 0x22a <_ZN3NRF20dataHasBeenProcessedEv>
			if (settings == PULSEOX_GO_TO_SLEEP)
 ac2:	f1 e0       	ldi	r31, 0x01	; 1
 ac4:	9f 12       	cpse	r9, r31
 ac6:	01 c0       	rjmp	.+2      	; 0xaca <main+0xf0>
				state = GO2SLEEP;
 ac8:	87 2c       	mov	r8, r7
		}
		
		if (nrf.mode == NRF_MODE_STANDBY){			
 aca:	f8 01       	movw	r30, r16
 acc:	80 81       	ld	r24, Z
 ace:	83 30       	cpi	r24, 0x03	; 3
 ad0:	09 f0       	breq	.+2      	; 0xad4 <main+0xfa>
 ad2:	23 c1       	rjmp	.+582    	; 0xd1a <main+0x340>
			if(buttonWasPressed){
 ad4:	80 91 76 03 	lds	r24, 0x0376
 ad8:	88 23       	and	r24, r24
 ada:	89 f0       	breq	.+34     	; 0xafe <main+0x124>
				buttonWasPressed = false;
 adc:	60 92 76 03 	sts	0x0376, r6
				if (state == GO2SLEEP){
 ae0:	f6 e0       	ldi	r31, 0x06	; 6
 ae2:	8f 12       	cpse	r8, r31
 ae4:	06 c0       	rjmp	.+12     	; 0xaf2 <main+0x118>
					RED_ON; //testing
 ae6:	55 98       	cbi	0x0a, 5	; 10
 ae8:	89 b1       	in	r24, 0x09	; 9
 aea:	8f 73       	andi	r24, 0x3F	; 63
 aec:	80 68       	ori	r24, 0x80	; 128
 aee:	8b b9       	out	0x0b, r24	; 11
 af0:	de c0       	rjmp	.+444    	; 0xcae <main+0x2d4>
					state = WAKEUP;
				}else{
					RED_ON;					
 af2:	55 98       	cbi	0x0a, 5	; 10
 af4:	89 b1       	in	r24, 0x09	; 9
 af6:	8f 73       	andi	r24, 0x3F	; 63
 af8:	80 68       	ori	r24, 0x80	; 128
 afa:	8b b9       	out	0x0b, r24	; 11
 afc:	a4 c0       	rjmp	.+328    	; 0xc46 <main+0x26c>
					state = GO2SLEEP;
				}
			}
			
			switch (state){
 afe:	88 2d       	mov	r24, r8
 b00:	90 e0       	ldi	r25, 0x00	; 0
 b02:	fc 01       	movw	r30, r24
 b04:	ef 59       	subi	r30, 0x9F	; 159
 b06:	ff 4f       	sbci	r31, 0xFF	; 255
 b08:	0c 94 ba 06 	jmp	0xd74	; 0xd74 <__tablejump2__>
				case INIT:	//initializing
					if (!nrf.isInitializing()){
 b0c:	87 e7       	ldi	r24, 0x77	; 119
 b0e:	93 e0       	ldi	r25, 0x03	; 3
 b10:	0e 94 f5 00 	call	0x1ea	; 0x1ea <_ZN3NRF14isInitializingEv>
 b14:	81 11       	cpse	r24, r1
 b16:	01 c1       	rjmp	.+514    	; 0xd1a <main+0x340>
						timer.start();
 b18:	ce 01       	movw	r24, r28
 b1a:	08 96       	adiw	r24, 0x08	; 8
 b1c:	0e 94 d6 04 	call	0x9ac	; 0x9ac <_ZN6TIMER15startEv>
						sei();	
 b20:	78 94       	sei
						RED_ON;		
 b22:	55 98       	cbi	0x0a, 5	; 10
 b24:	89 b1       	in	r24, 0x09	; 9
 b26:	8f 73       	andi	r24, 0x3F	; 63
 b28:	80 68       	ori	r24, 0x80	; 128
 b2a:	8b b9       	out	0x0b, r24	; 11
						//this will put it to sleep the first time it boots up	
						//state = GO2SLEEP;		//FINAL PRODUCT	
						
						//this will go straight into connect mode upon boot			
						state = CONNECT;		//TESTING			
 b2c:	85 2c       	mov	r8, r5
 b2e:	f5 c0       	rjmp	.+490    	; 0xd1a <main+0x340>
					//_delay_ms(25);
#endif
					break;				
					
				case CONNECT:	//connect
					if (nrf.connect(180,0x0100) == 0x00)
 b30:	40 e0       	ldi	r20, 0x00	; 0
 b32:	51 e0       	ldi	r21, 0x01	; 1
 b34:	64 eb       	ldi	r22, 0xB4	; 180
 b36:	70 e0       	ldi	r23, 0x00	; 0
 b38:	87 e7       	ldi	r24, 0x77	; 119
 b3a:	93 e0       	ldi	r25, 0x03	; 3
 b3c:	0e 94 62 02 	call	0x4c4	; 0x4c4 <_ZN3NRF7connectEjj>
 b40:	88 23       	and	r24, r24
 b42:	09 f4       	brne	.+2      	; 0xb46 <main+0x16c>
 b44:	d6 c0       	rjmp	.+428    	; 0xcf2 <main+0x318>
 b46:	e9 c0       	rjmp	.+466    	; 0xd1a <main+0x340>
						state = CONNECTING;
					break;				
				
				case CONNECTING:	
					if (nrf.isConnected())
 b48:	87 e7       	ldi	r24, 0x77	; 119
 b4a:	93 e0       	ldi	r25, 0x03	; 3
 b4c:	0e 94 09 01 	call	0x212	; 0x212 <_ZN3NRF11isConnectedEv>
 b50:	81 11       	cpse	r24, r1
 b52:	d3 c0       	rjmp	.+422    	; 0xcfa <main+0x320>
 b54:	e2 c0       	rjmp	.+452    	; 0xd1a <main+0x340>
						state = IDLE;
					break;
					
				case SEND:					
					if (0x00 == nrf.setLocalData(PIPE_OXYGEN_SATURATION_O2_SET, oxygenSaturationData, PIPE_OXYGEN_SATURATION_O2_SET_MAX_SIZE)){						
 b56:	24 2d       	mov	r18, r4
 b58:	ae 01       	movw	r20, r28
 b5a:	4f 5f       	subi	r20, 0xFF	; 255
 b5c:	5f 4f       	sbci	r21, 0xFF	; 255
 b5e:	65 2d       	mov	r22, r5
 b60:	87 e7       	ldi	r24, 0x77	; 119
 b62:	93 e0       	ldi	r25, 0x03	; 3
 b64:	0e 94 1a 02 	call	0x434	; 0x434 <_ZN3NRF12setLocalDataEhPhh>
 b68:	81 11       	cpse	r24, r1
 b6a:	d7 c0       	rjmp	.+430    	; 0xd1a <main+0x340>
						oxygenSaturationData[0]++;									
 b6c:	89 81       	ldd	r24, Y+1	; 0x01
 b6e:	8f 5f       	subi	r24, 0xFF	; 255
 b70:	89 83       	std	Y+1, r24	; 0x01
						state = IDLE;	
 b72:	0f 2e       	mov	r0, r31
 b74:	f5 e0       	ldi	r31, 0x05	; 5
 b76:	8f 2e       	mov	r8, r31
 b78:	f0 2d       	mov	r31, r0
 b7a:	cf c0       	rjmp	.+414    	; 0xd1a <main+0x340>
					}					
					break;
				
				case RECEIVE:
					nrf.requestData(PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX);
 b7c:	62 e0       	ldi	r22, 0x02	; 2
 b7e:	87 e7       	ldi	r24, 0x77	; 119
 b80:	93 e0       	ldi	r25, 0x03	; 3
 b82:	0e 94 a9 01 	call	0x352	; 0x352 <_ZN3NRF11requestDataEh>
					state = IDLE;
 b86:	0f 2e       	mov	r0, r31
 b88:	f5 e0       	ldi	r31, 0x05	; 5
 b8a:	8f 2e       	mov	r8, r31
 b8c:	f0 2d       	mov	r31, r0
					break;				
 b8e:	c5 c0       	rjmp	.+394    	; 0xd1a <main+0x340>
																
				case IDLE:		//idle
					if(!nrf.isConnected()){
 b90:	87 e7       	ldi	r24, 0x77	; 119
 b92:	93 e0       	ldi	r25, 0x03	; 3
 b94:	0e 94 09 01 	call	0x212	; 0x212 <_ZN3NRF11isConnectedEv>
 b98:	88 23       	and	r24, r24
 b9a:	09 f4       	brne	.+2      	; 0xb9e <main+0x1c4>
 b9c:	b3 c0       	rjmp	.+358    	; 0xd04 <main+0x32a>
						state = GO2SLEEP;
					}else {
						if (timer.isCompareAFlagSet()){
 b9e:	ce 01       	movw	r24, r28
 ba0:	08 96       	adiw	r24, 0x08	; 8
 ba2:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <_ZN6TIMER117isCompareAFlagSetEv>
 ba6:	88 23       	and	r24, r24
 ba8:	71 f0       	breq	.+28     	; 0xbc6 <main+0x1ec>
							timer.clearCompareAFlag();
 baa:	ce 01       	movw	r24, r28
 bac:	08 96       	adiw	r24, 0x08	; 8
 bae:	0e 94 e6 04 	call	0x9cc	; 0x9cc <_ZN6TIMER117clearCompareAFlagEv>
							timer.setCount(0);
 bb2:	60 e0       	ldi	r22, 0x00	; 0
 bb4:	70 e0       	ldi	r23, 0x00	; 0
 bb6:	ce 01       	movw	r24, r28
 bb8:	08 96       	adiw	r24, 0x08	; 8
 bba:	0e 94 e8 04 	call	0x9d0	; 0x9d0 <_ZN6TIMER18setCountEj>
							sensor.start();
 bbe:	ce 01       	movw	r24, r28
 bc0:	0c 96       	adiw	r24, 0x0c	; 12
 bc2:	0e 94 b7 00 	call	0x16e	; 0x16e <_ZN6ANALOG5startEv>
 						}//if
 					
 						if (sensor.isInterruptFlagSet()){
 bc6:	ce 01       	movw	r24, r28
 bc8:	0c 96       	adiw	r24, 0x0c	; 12
 bca:	0e 94 c2 00 	call	0x184	; 0x184 <_ZN6ANALOG18isInterruptFlagSetEv>
 bce:	88 23       	and	r24, r24
 bd0:	09 f4       	brne	.+2      	; 0xbd4 <main+0x1fa>
 bd2:	a3 c0       	rjmp	.+326    	; 0xd1a <main+0x340>
							sensor.clearFlag();
 bd4:	ce 01       	movw	r24, r28
 bd6:	0c 96       	adiw	r24, 0x0c	; 12
 bd8:	0e 94 c6 00 	call	0x18c	; 0x18c <_ZN6ANALOG9clearFlagEv>
							switch(led_state){
 bdc:	21 e0       	ldi	r18, 0x01	; 1
 bde:	32 16       	cp	r3, r18
 be0:	09 f1       	breq	.+66     	; 0xc24 <main+0x24a>
 be2:	32 16       	cp	r3, r18
 be4:	20 f0       	brcs	.+8      	; 0xbee <main+0x214>
 be6:	82 e0       	ldi	r24, 0x02	; 2
 be8:	38 16       	cp	r3, r24
 bea:	79 f0       	breq	.+30     	; 0xc0a <main+0x230>
 bec:	96 c0       	rjmp	.+300    	; 0xd1a <main+0x340>
								case I:
									oxygenSaturationData[6*count+4] = ADCL;
 bee:	f5 01       	movw	r30, r10
 bf0:	80 81       	ld	r24, Z
 bf2:	8d 83       	std	Y+5, r24	; 0x05
									oxygenSaturationData[6*count+3] = ADCH;
 bf4:	f6 01       	movw	r30, r12
 bf6:	80 81       	ld	r24, Z
 bf8:	8c 83       	std	Y+4, r24	; 0x04
									LEDS_OFF;
 bfa:	55 98       	cbi	0x0a, 5	; 10
 bfc:	89 b1       	in	r24, 0x09	; 9
 bfe:	8f 71       	andi	r24, 0x1F	; 31
 c00:	8b b9       	out	0x0b, r24	; 11
									led_state = O;
 c02:	68 94       	set
 c04:	33 24       	eor	r3, r3
 c06:	31 f8       	bld	r3, 1
									break;
 c08:	88 c0       	rjmp	.+272    	; 0xd1a <main+0x340>
								case O:
									oxygenSaturationData[6*count+6] = ADCL;
 c0a:	f5 01       	movw	r30, r10
 c0c:	80 81       	ld	r24, Z
 c0e:	8f 83       	std	Y+7, r24	; 0x07
									oxygenSaturationData[6*count+5] = ADCH;
 c10:	f6 01       	movw	r30, r12
 c12:	80 81       	ld	r24, Z
 c14:	8e 83       	std	Y+6, r24	; 0x06
									RED_ON;
 c16:	55 98       	cbi	0x0a, 5	; 10
 c18:	89 b1       	in	r24, 0x09	; 9
 c1a:	8f 73       	andi	r24, 0x3F	; 63
 c1c:	80 68       	ori	r24, 0x80	; 128
 c1e:	8b b9       	out	0x0b, r24	; 11
									led_state = R;
 c20:	35 2c       	mov	r3, r5
									break;
 c22:	7b c0       	rjmp	.+246    	; 0xd1a <main+0x340>
								case R:
									oxygenSaturationData[6*count+2] = ADCL;
 c24:	f5 01       	movw	r30, r10
 c26:	80 81       	ld	r24, Z
 c28:	8b 83       	std	Y+3, r24	; 0x03
									oxygenSaturationData[6*count+1] = ADCH;
 c2a:	f6 01       	movw	r30, r12
 c2c:	80 81       	ld	r24, Z
 c2e:	8a 83       	std	Y+2, r24	; 0x02
									IR_ON;
 c30:	55 9a       	sbi	0x0a, 5	; 10
 c32:	89 b1       	in	r24, 0x09	; 9
 c34:	8f 71       	andi	r24, 0x1F	; 31
 c36:	80 66       	ori	r24, 0x60	; 96
 c38:	8b b9       	out	0x0b, r24	; 11
									led_state = I;
									if (++count == NUM_QUEUE){
										count = 0;
										state = SEND;
 c3a:	0f 2e       	mov	r0, r31
 c3c:	f3 e0       	ldi	r31, 0x03	; 3
 c3e:	8f 2e       	mov	r8, r31
 c40:	f0 2d       	mov	r31, r0
									break;
								case R:
									oxygenSaturationData[6*count+2] = ADCL;
									oxygenSaturationData[6*count+1] = ADCH;
									IR_ON;
									led_state = I;
 c42:	36 2c       	mov	r3, r6
 c44:	6a c0       	rjmp	.+212    	; 0xd1a <main+0x340>
							} //switch(led_state)
						} //if (sensor.isInterruptFlagSet())						
					}	
					break;
				case GO2SLEEP:
					SleepOpAmp();
 c46:	41 98       	cbi	0x08, 1	; 8
					//disconnect
					if (nrf.isConnected())
 c48:	87 e7       	ldi	r24, 0x77	; 119
 c4a:	93 e0       	ldi	r25, 0x03	; 3
 c4c:	0e 94 09 01 	call	0x212	; 0x212 <_ZN3NRF11isConnectedEv>
 c50:	88 23       	and	r24, r24
 c52:	29 f0       	breq	.+10     	; 0xc5e <main+0x284>
						nrf.disconnect(0x01);
 c54:	65 2d       	mov	r22, r5
 c56:	87 e7       	ldi	r24, 0x77	; 119
 c58:	93 e0       	ldi	r25, 0x03	; 3
 c5a:	0e 94 98 01 	call	0x330	; 0x330 <_ZN3NRF10disconnectEh>
					
					if (!nrf.isConnected()){
 c5e:	87 e7       	ldi	r24, 0x77	; 119
 c60:	93 e0       	ldi	r25, 0x03	; 3
 c62:	0e 94 09 01 	call	0x212	; 0x212 <_ZN3NRF11isConnectedEv>
 c66:	81 11       	cpse	r24, r1
 c68:	4f c0       	rjmp	.+158    	; 0xd08 <main+0x32e>
						//put nrf to sleep
						if (!nrf.isSleeping()){
 c6a:	87 e7       	ldi	r24, 0x77	; 119
 c6c:	93 e0       	ldi	r25, 0x03	; 3
 c6e:	0e 94 1a 01 	call	0x234	; 0x234 <_ZN3NRF10isSleepingEv>
 c72:	81 11       	cpse	r24, r1
 c74:	04 c0       	rjmp	.+8      	; 0xc7e <main+0x2a4>
							nrf.sleep();
 c76:	87 e7       	ldi	r24, 0x77	; 119
 c78:	93 e0       	ldi	r25, 0x03	; 3
 c7a:	0e 94 56 02 	call	0x4ac	; 0x4ac <_ZN3NRF5sleepEv>
						}																
						
						if (nrf.isSleeping() && !nrf.hasDataToSend()){							
 c7e:	87 e7       	ldi	r24, 0x77	; 119
 c80:	93 e0       	ldi	r25, 0x03	; 3
 c82:	0e 94 1a 01 	call	0x234	; 0x234 <_ZN3NRF10isSleepingEv>
 c86:	88 23       	and	r24, r24
 c88:	09 f4       	brne	.+2      	; 0xc8c <main+0x2b2>
 c8a:	40 c0       	rjmp	.+128    	; 0xd0c <main+0x332>
 c8c:	87 e7       	ldi	r24, 0x77	; 119
 c8e:	93 e0       	ldi	r25, 0x03	; 3
 c90:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 c94:	81 11       	cpse	r24, r1
 c96:	3c c0       	rjmp	.+120    	; 0xd10 <main+0x336>
							LEDS_OFF;
 c98:	55 98       	cbi	0x0a, 5	; 10
 c9a:	89 b1       	in	r24, 0x09	; 9
 c9c:	8f 71       	andi	r24, 0x1F	; 31
 c9e:	8b b9       	out	0x0b, r24	; 11
#define SLEEP_MODE_STANDBY		0b110
#define EnableSleep() 			SMCR |= (1<<SE)
#define DisableSleep()			SMCR &= ~(1<<SE)
void SetSleepMode(uint8_t mode){
	if((mode == SLEEP_MODE_STANDBY) | (mode<=SLEEP_MODE_POWER_SAVE))
	SMCR = (mode<<SM0);
 ca0:	23 be       	out	0x33, r2	; 51
						
						if (nrf.isSleeping() && !nrf.hasDataToSend()){							
							LEDS_OFF;
							//put uC to sleep							
  							SetSleepMode(SLEEP_MODE_POWER_DOWN);
  							EnableSleep();
 ca2:	83 b7       	in	r24, 0x33	; 51
 ca4:	81 60       	ori	r24, 0x01	; 1
 ca6:	83 bf       	out	0x33, r24	; 51
  							__asm__ __volatile__ ("sleep" ::);
 ca8:	88 95       	sleep
 caa:	87 2c       	mov	r8, r7
 cac:	36 c0       	rjmp	.+108    	; 0xd1a <main+0x340>
						}
					}
					break;
				case WAKEUP:
					DisableSleep();					
 cae:	83 b7       	in	r24, 0x33	; 51
 cb0:	8e 7f       	andi	r24, 0xFE	; 254
 cb2:	83 bf       	out	0x33, r24	; 51
					
					//wakeup opamp
					WakeOpAmp();
 cb4:	41 9a       	sbi	0x08, 1	; 8
					//wakeup nrf
					if (nrf.isSleeping() && !nrf.hasDataToSend()){
 cb6:	87 e7       	ldi	r24, 0x77	; 119
 cb8:	93 e0       	ldi	r25, 0x03	; 3
 cba:	0e 94 1a 01 	call	0x234	; 0x234 <_ZN3NRF10isSleepingEv>
 cbe:	88 23       	and	r24, r24
 cc0:	51 f0       	breq	.+20     	; 0xcd6 <main+0x2fc>
 cc2:	87 e7       	ldi	r24, 0x77	; 119
 cc4:	93 e0       	ldi	r25, 0x03	; 3
 cc6:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 cca:	81 11       	cpse	r24, r1
 ccc:	04 c0       	rjmp	.+8      	; 0xcd6 <main+0x2fc>
						nrf.wakeup();
 cce:	87 e7       	ldi	r24, 0x77	; 119
 cd0:	93 e0       	ldi	r25, 0x03	; 3
 cd2:	0e 94 5e 02 	call	0x4bc	; 0x4bc <_ZN3NRF6wakeupEv>
					}
					
					if (!nrf.isSleeping() && !nrf.hasDataToSend()){						
 cd6:	87 e7       	ldi	r24, 0x77	; 119
 cd8:	93 e0       	ldi	r25, 0x03	; 3
 cda:	0e 94 1a 01 	call	0x234	; 0x234 <_ZN3NRF10isSleepingEv>
 cde:	81 11       	cpse	r24, r1
 ce0:	19 c0       	rjmp	.+50     	; 0xd14 <main+0x33a>
 ce2:	87 e7       	ldi	r24, 0x77	; 119
 ce4:	93 e0       	ldi	r25, 0x03	; 3
 ce6:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 cea:	88 23       	and	r24, r24
 cec:	a9 f0       	breq	.+42     	; 0xd18 <main+0x33e>
 cee:	84 2c       	mov	r8, r4
 cf0:	14 c0       	rjmp	.+40     	; 0xd1a <main+0x340>
#endif
					break;				
					
				case CONNECT:	//connect
					if (nrf.connect(180,0x0100) == 0x00)
						state = CONNECTING;
 cf2:	68 94       	set
 cf4:	88 24       	eor	r8, r8
 cf6:	81 f8       	bld	r8, 1
 cf8:	10 c0       	rjmp	.+32     	; 0xd1a <main+0x340>
					break;				
				
				case CONNECTING:	
					if (nrf.isConnected())
						state = IDLE;
 cfa:	0f 2e       	mov	r0, r31
 cfc:	f5 e0       	ldi	r31, 0x05	; 5
 cfe:	8f 2e       	mov	r8, r31
 d00:	f0 2d       	mov	r31, r0
 d02:	0b c0       	rjmp	.+22     	; 0xd1a <main+0x340>
					state = IDLE;
					break;				
																
				case IDLE:		//idle
					if(!nrf.isConnected()){
						state = GO2SLEEP;
 d04:	87 2c       	mov	r8, r7
 d06:	09 c0       	rjmp	.+18     	; 0xd1a <main+0x340>
 d08:	87 2c       	mov	r8, r7
 d0a:	07 c0       	rjmp	.+14     	; 0xd1a <main+0x340>
 d0c:	87 2c       	mov	r8, r7
 d0e:	05 c0       	rjmp	.+10     	; 0xd1a <main+0x340>
 d10:	87 2c       	mov	r8, r7
 d12:	03 c0       	rjmp	.+6      	; 0xd1a <main+0x340>
 d14:	84 2c       	mov	r8, r4
 d16:	01 c0       	rjmp	.+2      	; 0xd1a <main+0x340>
					if (nrf.isSleeping() && !nrf.hasDataToSend()){
						nrf.wakeup();
					}
					
					if (!nrf.isSleeping() && !nrf.hasDataToSend()){						
						state = CONNECT;
 d18:	85 2c       	mov	r8, r5
		//display
		//sprintf(line1, " %02X%02X %02X %02X%02X ", nrf.RxCount, nrf.dataCredit, state, nrf.status, nrf.mode);
		sprintf(line2, "%02X%02X %02X %02X%02X ", nrf.RxCount, /*nrf.dataCredit,*/ state, nrf.status, nrf.mode, nrf.lastCommand);
		displayLCD();
#else
		if (nrf.mode == NRF_MODE_SETUP)
 d1a:	f8 01       	movw	r30, r16
 d1c:	80 81       	ld	r24, Z
 d1e:	82 30       	cpi	r24, 0x02	; 2
 d20:	31 f4       	brne	.+12     	; 0xd2e <main+0x354>
 d22:	8f e2       	ldi	r24, 0x2F	; 47
 d24:	95 e7       	ldi	r25, 0x75	; 117
 d26:	01 97       	sbiw	r24, 0x01	; 1
 d28:	f1 f7       	brne	.-4      	; 0xd26 <main+0x34c>
 d2a:	00 c0       	rjmp	.+0      	; 0xd2c <main+0x352>
 d2c:	00 00       	nop
			_delay_ms(15);
#endif			
		nrf.process();		
 d2e:	87 e7       	ldi	r24, 0x77	; 119
 d30:	93 e0       	ldi	r25, 0x03	; 3
 d32:	0e 94 a0 03 	call	0x740	; 0x740 <_ZN3NRF7processEv>
	}//while 1
 d36:	b5 ce       	rjmp	.-662    	; 0xaa2 <main+0xc8>

00000d38 <__vector_1>:
}//main

ISR(INT0_vect){
 d38:	1f 92       	push	r1
 d3a:	0f 92       	push	r0
 d3c:	0f b6       	in	r0, 0x3f	; 63
 d3e:	0f 92       	push	r0
 d40:	11 24       	eor	r1, r1
 d42:	8f 93       	push	r24
 d44:	9f 93       	push	r25
 d46:	8f e0       	ldi	r24, 0x0F	; 15
 d48:	97 e2       	ldi	r25, 0x27	; 39
 d4a:	01 97       	sbiw	r24, 0x01	; 1
 d4c:	f1 f7       	brne	.-4      	; 0xd4a <__vector_1+0x12>
 d4e:	00 c0       	rjmp	.+0      	; 0xd50 <__vector_1+0x18>
 d50:	00 00       	nop
	//to debounce switch, wait 5ms, then check for low condition again
	_delay_ms(5);
	if (!(PIND & (1<<PD2)))
 d52:	4a 99       	sbic	0x09, 2	; 9
 d54:	03 c0       	rjmp	.+6      	; 0xd5c <__vector_1+0x24>
	buttonWasPressed = true;
 d56:	81 e0       	ldi	r24, 0x01	; 1
 d58:	80 93 76 03 	sts	0x0376, r24
	
}
 d5c:	9f 91       	pop	r25
 d5e:	8f 91       	pop	r24
 d60:	0f 90       	pop	r0
 d62:	0f be       	out	0x3f, r0	; 63
 d64:	0f 90       	pop	r0
 d66:	1f 90       	pop	r1
 d68:	18 95       	reti

00000d6a <_GLOBAL__sub_I_nrf>:

//size of pipe in settings.h sets size of queue, which is how many times we read
//the data before we send
#define NUM_QUEUE ((PIPE_OXYGEN_SATURATION_O2_SET_MAX_SIZE-1)/6)

NRF nrf;
 d6a:	87 e7       	ldi	r24, 0x77	; 119
 d6c:	93 e0       	ldi	r25, 0x03	; 3
 d6e:	0e 94 2e 01 	call	0x25c	; 0x25c <_ZN3NRFC1Ev>
 d72:	08 95       	ret

00000d74 <__tablejump2__>:
 d74:	ee 0f       	add	r30, r30
 d76:	ff 1f       	adc	r31, r31

00000d78 <__tablejump__>:
 d78:	05 90       	lpm	r0, Z+
 d7a:	f4 91       	lpm	r31, Z
 d7c:	e0 2d       	mov	r30, r0
 d7e:	09 94       	ijmp

00000d80 <_exit>:
 d80:	f8 94       	cli

00000d82 <__stop_program>:
 d82:	ff cf       	rjmp	.-2      	; 0xd82 <__stop_program>
