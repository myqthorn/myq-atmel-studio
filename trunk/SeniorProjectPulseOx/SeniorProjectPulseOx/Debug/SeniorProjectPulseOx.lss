
SeniorProjectPulseOx.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000274  00800100  00000caa  00000d3e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000caa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000077  00800374  00800374  00000fb2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000fb2  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000328  00000000  00000000  00000fe2  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000041cd  00000000  00000000  0000130a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000b4b  00000000  00000000  000054d7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000d03  00000000  00000000  00006022  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000007ec  00000000  00000000  00006d28  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000013a0  00000000  00000000  00007514  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000254b  00000000  00000000  000088b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000308  00000000  00000000  0000adff  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__ctors_end>
   4:	0c 94 2f 06 	jmp	0xc5e	; 0xc5e <__vector_1>
   8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
   c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  14:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  18:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  1c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  2c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  30:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  34:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  44:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  54:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  64:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  68:	f6 02       	muls	r31, r22
  6a:	fa 02       	muls	r31, r26
  6c:	fe 02       	muls	r31, r30
  6e:	02 03       	mulsu	r16, r18
  70:	06 03       	mulsu	r16, r22
  72:	0a 03       	fmul	r16, r18
  74:	14 03       	mulsu	r17, r20
  76:	18 03       	fmul	r17, r16
  78:	1c 03       	fmul	r17, r20
  7a:	24 03       	mulsu	r18, r20
  7c:	28 03       	fmul	r18, r16
  7e:	2c 03       	fmul	r18, r20
  80:	5e 03       	fmul	r21, r22
  82:	3f 03       	fmul	r19, r23
  84:	5e 03       	fmul	r21, r22
  86:	5e 03       	fmul	r21, r22
  88:	5e 03       	fmul	r21, r22
  8a:	43 03       	mulsu	r20, r19
  8c:	5e 03       	fmul	r21, r22
  8e:	5e 03       	fmul	r21, r22
  90:	5e 03       	fmul	r21, r22
  92:	5e 03       	fmul	r21, r22
  94:	5e 03       	fmul	r21, r22
  96:	5e 03       	fmul	r21, r22
  98:	47 03       	mulsu	r20, r23
  9a:	4b 03       	fmul	r20, r19
  9c:	4f 03       	fmul	r20, r23
  9e:	53 03       	mulsu	r21, r19
  a0:	57 03       	mulsu	r21, r23
  a2:	5b 03       	fmul	r21, r19
  a4:	b6 03       	fmuls	r19, r22
  a6:	d7 03       	fmuls	r21, r23
  a8:	e2 03       	fmuls	r22, r18
  aa:	e5 03       	fmuls	r22, r21
  ac:	e9 03       	fmulsu	r22, r17
  ae:	ee 03       	fmulsu	r22, r22
  b0:	f1 03       	fmuls	r23, r17
  b2:	fa 03       	fmulsu	r23, r18
  b4:	0d 04       	cpc	r0, r13
  b6:	16 04       	cpc	r1, r6
  b8:	37 04       	cpc	r3, r7
  ba:	ac 03       	fmulsu	r18, r20
  bc:	33 04       	cpc	r3, r3
  be:	10 04       	cpc	r1, r0
  c0:	13 04       	cpc	r1, r3
  c2:	41 05       	cpc	r20, r1
  c4:	53 05       	cpc	r21, r3
  c6:	5f 05       	cpc	r21, r15
  c8:	66 05       	cpc	r22, r6
  ca:	79 05       	cpc	r23, r9
  cc:	83 05       	cpc	r24, r3
  ce:	dd 05       	cpc	r29, r13
  d0:	f9 05       	cpc	r31, r9

000000d2 <__ctors_start>:
  d2:	5f 04       	cpc	r5, r15
  d4:	48 06       	cpc	r4, r24

000000d6 <__ctors_end>:
  d6:	11 24       	eor	r1, r1
  d8:	1f be       	out	0x3f, r1	; 63
  da:	cf ef       	ldi	r28, 0xFF	; 255
  dc:	d8 e0       	ldi	r29, 0x08	; 8
  de:	de bf       	out	0x3e, r29	; 62
  e0:	cd bf       	out	0x3d, r28	; 61

000000e2 <__do_copy_data>:
  e2:	13 e0       	ldi	r17, 0x03	; 3
  e4:	a0 e0       	ldi	r26, 0x00	; 0
  e6:	b1 e0       	ldi	r27, 0x01	; 1
  e8:	ea ea       	ldi	r30, 0xAA	; 170
  ea:	fc e0       	ldi	r31, 0x0C	; 12
  ec:	02 c0       	rjmp	.+4      	; 0xf2 <__do_copy_data+0x10>
  ee:	05 90       	lpm	r0, Z+
  f0:	0d 92       	st	X+, r0
  f2:	a4 37       	cpi	r26, 0x74	; 116
  f4:	b1 07       	cpc	r27, r17
  f6:	d9 f7       	brne	.-10     	; 0xee <__do_copy_data+0xc>

000000f8 <__do_clear_bss>:
  f8:	23 e0       	ldi	r18, 0x03	; 3
  fa:	a4 e7       	ldi	r26, 0x74	; 116
  fc:	b3 e0       	ldi	r27, 0x03	; 3
  fe:	01 c0       	rjmp	.+2      	; 0x102 <.do_clear_bss_start>

00000100 <.do_clear_bss_loop>:
 100:	1d 92       	st	X+, r1

00000102 <.do_clear_bss_start>:
 102:	ab 3e       	cpi	r26, 0xEB	; 235
 104:	b2 07       	cpc	r27, r18
 106:	e1 f7       	brne	.-8      	; 0x100 <.do_clear_bss_loop>

00000108 <__do_global_ctors>:
 108:	10 e0       	ldi	r17, 0x00	; 0
 10a:	c6 ed       	ldi	r28, 0xD6	; 214
 10c:	d0 e0       	ldi	r29, 0x00	; 0
 10e:	04 c0       	rjmp	.+8      	; 0x118 <__do_global_ctors+0x10>
 110:	22 97       	sbiw	r28, 0x02	; 2
 112:	fe 01       	movw	r30, r28
 114:	0e 94 4f 06 	call	0xc9e	; 0xc9e <__tablejump__>
 118:	c2 3d       	cpi	r28, 0xD2	; 210
 11a:	d1 07       	cpc	r29, r17
 11c:	c9 f7       	brne	.-14     	; 0x110 <__do_global_ctors+0x8>
 11e:	0e 94 ae 04 	call	0x95c	; 0x95c <main>
 122:	0c 94 53 06 	jmp	0xca6	; 0xca6 <_exit>

00000126 <__bad_interrupt>:
 126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <_ZN6ANALOG12reinitializeEv>:
	
}

void ANALOG::reinitialize(){
	//Power reduction ADC bit must be zero to enable ADC
	PRR &= ~(1<<PRADC);
 12a:	e4 e6       	ldi	r30, 0x64	; 100
 12c:	f0 e0       	ldi	r31, 0x00	; 0
 12e:	20 81       	ld	r18, Z
 130:	2e 7f       	andi	r18, 0xFE	; 254
 132:	20 83       	st	Z, r18
	
	
	//ADC clock needs to be between 50kHz and 200kHz
	//8MHz/64 = 125kHz
	ADCSRA = (1<<ADEN | prescalar<<ADPS0);
 134:	dc 01       	movw	r26, r24
 136:	11 96       	adiw	r26, 0x01	; 1
 138:	2c 91       	ld	r18, X
 13a:	11 97       	sbiw	r26, 0x01	; 1
 13c:	20 68       	ori	r18, 0x80	; 128
 13e:	20 93 7a 00 	sts	0x007A, r18
	
	//Disable the digital input for the ADC channel we will be using
	DIDR0 |= (1<<channel);
 142:	ee e7       	ldi	r30, 0x7E	; 126
 144:	f0 e0       	ldi	r31, 0x00	; 0
 146:	40 81       	ld	r20, Z
 148:	21 e0       	ldi	r18, 0x01	; 1
 14a:	30 e0       	ldi	r19, 0x00	; 0
 14c:	b9 01       	movw	r22, r18
 14e:	0c 90       	ld	r0, X
 150:	02 c0       	rjmp	.+4      	; 0x156 <_ZN6ANALOG12reinitializeEv+0x2c>
 152:	66 0f       	add	r22, r22
 154:	77 1f       	adc	r23, r23
 156:	0a 94       	dec	r0
 158:	e2 f7       	brpl	.-8      	; 0x152 <_ZN6ANALOG12reinitializeEv+0x28>
 15a:	cb 01       	movw	r24, r22
 15c:	84 2b       	or	r24, r20
 15e:	80 83       	st	Z, r24
 160:	08 95       	ret

00000162 <_ZN6ANALOGC1Ehh>:
	reinitialize();
}

//@brief initialize AD converter on Atmega168 for
ANALOG::ANALOG(uint8_t ch, uint8_t pscalar){
	channel = ch;
 162:	fc 01       	movw	r30, r24
 164:	60 83       	st	Z, r22
	prescalar = pscalar;
 166:	41 83       	std	Z+1, r20	; 0x01
	reinitialize();
 168:	0e 94 95 00 	call	0x12a	; 0x12a <_ZN6ANALOG12reinitializeEv>
 16c:	08 95       	ret

0000016e <_ZN6ANALOG5startEv>:
	return (ADC);
}

void ANALOG::start(){
	//set ADC channel
	ADMUX = (1<<REFS0) | channel;
 16e:	fc 01       	movw	r30, r24
 170:	80 81       	ld	r24, Z
 172:	80 64       	ori	r24, 0x40	; 64
 174:	80 93 7c 00 	sts	0x007C, r24
	
	//start conversion
	ADCSRA |= (1<<ADSC);
 178:	ea e7       	ldi	r30, 0x7A	; 122
 17a:	f0 e0       	ldi	r31, 0x00	; 0
 17c:	80 81       	ld	r24, Z
 17e:	80 64       	ori	r24, 0x40	; 64
 180:	80 83       	st	Z, r24
 182:	08 95       	ret

00000184 <_ZN6ANALOG18isInterruptFlagSetEv>:
uint8_t ANALOG::isReading(){
	return (ADCSRA & (1<<ADSC));	
}

uint8_t	ANALOG::isInterruptFlagSet(){
	return(ADCSRA & (1<<ADIF));
 184:	80 91 7a 00 	lds	r24, 0x007A
}
 188:	80 71       	andi	r24, 0x10	; 16
 18a:	08 95       	ret

0000018c <_ZN6ANALOG9clearFlagEv>:

void ANALOG::clearFlag(){
	//clear interrupt by setting ADIF to 1
	ADCSRA |= (1<<ADIF);
 18c:	ea e7       	ldi	r30, 0x7A	; 122
 18e:	f0 e0       	ldi	r31, 0x00	; 0
 190:	80 81       	ld	r24, Z
 192:	80 61       	ori	r24, 0x10	; 16
 194:	80 83       	st	Z, r24
 196:	08 95       	ret

00000198 <_ZN3SPI4initEh>:
		init(SPCRvalue);
	}
	void SPI::init(uint8_t SPCRvalue)
	// Initialize pins for spi communication
	{
		DDR_SPI &= ~((1<<DD_MOSI)|(1<<DD_MISO)|(1<<DD_SS)|(1<<DD_SCK));
 198:	84 b1       	in	r24, 0x04	; 4
 19a:	83 7c       	andi	r24, 0xC3	; 195
 19c:	84 b9       	out	0x04, r24	; 4
		// Define the following pins as output
		DDR_SPI |= ((1<<DD_MOSI)|(1<<DD_SS)|(1<<DD_SCK));
 19e:	84 b1       	in	r24, 0x04	; 4
 1a0:	8c 62       	ori	r24, 0x2C	; 44
 1a2:	84 b9       	out	0x04, r24	; 4

		if (SPCRvalue == 0x00){
 1a4:	61 11       	cpse	r22, r1
 1a6:	03 c0       	rjmp	.+6      	; 0x1ae <_ZN3SPI4initEh+0x16>
			(0<<SPIE)|              // SPI Interrupt Enable
			(0<<DORD)|              // Data Order (0:MSB first / 1:LSB first)
			(1<<MSTR)|              // Master/Slave select
			(0<<SPR1)|(1<<SPR0)|    // SPI Clock Rate
			(0<<CPOL)|              // Clock Polarity (0:SCK low / 1:SCK hi when idle)
			(0<<CPHA));             // Clock Phase (0:leading / 1:trailing edge sampling)
 1a8:	81 e5       	ldi	r24, 0x51	; 81
 1aa:	8c bd       	out	0x2c, r24	; 44
 1ac:	08 95       	ret
		}
		else SPCR = SPCRvalue;
 1ae:	6c bd       	out	0x2c, r22	; 44
 1b0:	08 95       	ret

000001b2 <_ZN3SPIC1Eh>:
	
	SPI::SPI(){
		init(0x00);
	}
	SPI::SPI(uint8_t SPCRvalue){
		init(SPCRvalue);
 1b2:	0e 94 cc 00 	call	0x198	; 0x198 <_ZN3SPI4initEh>
 1b6:	08 95       	ret

000001b8 <_ZN3SPI8transferEPhS0_h>:
	
	void SPI::transfer (uint8_t * dataout, uint8_t * datain, uint8_t length)
	// Shift full array through target device
	{
		uint8_t i;
		for (i = 0; i < length; i++) {
 1b8:	22 23       	and	r18, r18
 1ba:	81 f0       	breq	.+32     	; 0x1dc <_ZN3SPI8transferEPhS0_h+0x24>
 1bc:	96 2f       	mov	r25, r22
 1be:	a4 2f       	mov	r26, r20
 1c0:	b5 2f       	mov	r27, r21
 1c2:	e6 2f       	mov	r30, r22
 1c4:	f7 2f       	mov	r31, r23
			SPDR = dataout[i];
 1c6:	81 91       	ld	r24, Z+
 1c8:	8e bd       	out	0x2e, r24	; 46
			while((SPSR & (1<<SPIF))==0);
 1ca:	0d b4       	in	r0, 0x2d	; 45
 1cc:	07 fe       	sbrs	r0, 7
 1ce:	fd cf       	rjmp	.-6      	; 0x1ca <_ZN3SPI8transferEPhS0_h+0x12>
			datain[i] = SPDR;
 1d0:	8e b5       	in	r24, 0x2e	; 46
 1d2:	8d 93       	st	X+, r24
 1d4:	8e 2f       	mov	r24, r30
 1d6:	89 1b       	sub	r24, r25
	
	void SPI::transfer (uint8_t * dataout, uint8_t * datain, uint8_t length)
	// Shift full array through target device
	{
		uint8_t i;
		for (i = 0; i < length; i++) {
 1d8:	82 17       	cp	r24, r18
 1da:	a8 f3       	brcs	.-22     	; 0x1c6 <_ZN3SPI8transferEPhS0_h+0xe>
 1dc:	08 95       	ret

000001de <_ZN3SPI13transfer1byteEh>:
	}
	
	uint8_t SPI::transfer1byte (uint8_t dataout)
	// Clocks only one byte to target device and returns the received one
	{
		SPDR = dataout;
 1de:	6e bd       	out	0x2e, r22	; 46
		while((SPSR & (1<<SPIF))==0);
 1e0:	0d b4       	in	r0, 0x2d	; 45
 1e2:	07 fe       	sbrs	r0, 7
 1e4:	fd cf       	rjmp	.-6      	; 0x1e0 <_ZN3SPI13transfer1byteEh+0x2>
		return SPDR;
 1e6:	8e b5       	in	r24, 0x2e	; 46
	}
 1e8:	08 95       	ret

000001ea <_ZN3NRF14isInitializingEv>:
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 1ea:	fc 01       	movw	r30, r24
 1ec:	ef 58       	subi	r30, 0x8F	; 143
 1ee:	ff 4f       	sbci	r31, 0xFF	; 255
 1f0:	81 e0       	ldi	r24, 0x01	; 1
 1f2:	90 81       	ld	r25, Z
 1f4:	92 30       	cpi	r25, 0x02	; 2
 1f6:	09 f0       	breq	.+2      	; 0x1fa <_ZN3NRF14isInitializingEv+0x10>
 1f8:	80 e0       	ldi	r24, 0x00	; 0
}
 1fa:	08 95       	ret

000001fc <_ZN3NRF13hasDataToSendEv>:
uint8_t NRF::hasDataToSend(void){
	return ((status & (1<<NRF_TX_READY))?TRUE:FALSE);
 1fc:	fc 01       	movw	r30, r24
 1fe:	82 8d       	ldd	r24, Z+26	; 0x1a
}
 200:	86 fb       	bst	r24, 6
 202:	88 27       	eor	r24, r24
 204:	80 f9       	bld	r24, 0
 206:	08 95       	ret

00000208 <_ZN3NRF18waitingForResponseEv>:
uint8_t NRF::isReadyToReceiveData(){
	return ((status & (1<<NRF_RX_READY))?TRUE:FALSE);
}
uint8_t NRF::waitingForResponse(void){
	return ((status & (1<<NRF_WAIT_FOR_RESPONSE))?TRUE:FALSE);
 208:	fc 01       	movw	r30, r24
 20a:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
 20c:	82 95       	swap	r24
 20e:	81 70       	andi	r24, 0x01	; 1
 210:	08 95       	ret

00000212 <_ZN3NRF11isConnectedEv>:
uint8_t NRF::isConnected(void){
	return ((status & (1<<NRF_CONNECTED))?TRUE:FALSE);
 212:	fc 01       	movw	r30, r24
 214:	82 8d       	ldd	r24, Z+26	; 0x1a
}	
 216:	83 fb       	bst	r24, 3
 218:	88 27       	eor	r24, r24
 21a:	80 f9       	bld	r24, 0
 21c:	08 95       	ret

0000021e <_ZN3NRF16hasDataToProcessEv>:
uint8_t NRF::isBonded(void){
	return ((status & (1<<NRF_BONDED))?TRUE:FALSE);	
}
uint8_t NRF::hasDataToProcess(void){
	return ((status & (1<<NRF_DATA_TO_PROCESS))?TRUE:FALSE);
 21e:	fc 01       	movw	r30, r24
 220:	82 8d       	ldd	r24, Z+26	; 0x1a
}
 222:	85 fb       	bst	r24, 5
 224:	88 27       	eor	r24, r24
 226:	80 f9       	bld	r24, 0
 228:	08 95       	ret

0000022a <_ZN3NRF20dataHasBeenProcessedEv>:
void	NRF::dataHasBeenProcessed(void){
	status &= ~(1<<NRF_DATA_TO_PROCESS);
 22a:	fc 01       	movw	r30, r24
 22c:	22 8d       	ldd	r18, Z+26	; 0x1a
 22e:	2f 7d       	andi	r18, 0xDF	; 223
 230:	22 8f       	std	Z+26, r18	; 0x1a
 232:	08 95       	ret

00000234 <_ZN3NRF10isSleepingEv>:
}
uint8_t NRF::isSleeping(void){
	return ((status & (1<<NRF_SLEEPING))?TRUE:FALSE);
 234:	fc 01       	movw	r30, r24
 236:	82 8d       	ldd	r24, Z+26	; 0x1a
}
 238:	86 95       	lsr	r24
 23a:	81 70       	andi	r24, 0x01	; 1
 23c:	08 95       	ret

0000023e <_ZN3NRF15isSystemCommandEh>:
uint8_t	NRF::isSystemCommand(uint8_t command){
	return ((	command == NRF_CMD_SET_LOCAL_DATA	||
		command == NRF_CMD_SEND_DATA		||
		command == NRF_CMD_SEND_DATA_ACK	||
		command == NRF_CMD_REQUEST_DATA		||
		command == NRF_CMD_SEND_DATA_NACK	 )	? FALSE: TRUE);
 23e:	6d 30       	cpi	r22, 0x0D	; 13
 240:	31 f0       	breq	.+12     	; 0x24e <_ZN3NRF15isSystemCommandEh+0x10>
	return ((status & (1<<NRF_SLEEPING))?TRUE:FALSE);
}
#pragma endregion Status Functions

uint8_t	NRF::isSystemCommand(uint8_t command){
	return ((	command == NRF_CMD_SET_LOCAL_DATA	||
 242:	65 51       	subi	r22, 0x15	; 21
 244:	81 e0       	ldi	r24, 0x01	; 1
 246:	64 30       	cpi	r22, 0x04	; 4
 248:	18 f4       	brcc	.+6      	; 0x250 <_ZN3NRF15isSystemCommandEh+0x12>
 24a:	80 e0       	ldi	r24, 0x00	; 0
 24c:	08 95       	ret
		command == NRF_CMD_SEND_DATA		||
		command == NRF_CMD_SEND_DATA_ACK	||
		command == NRF_CMD_REQUEST_DATA		||
		command == NRF_CMD_SEND_DATA_NACK	 )	? FALSE: TRUE);
 24e:	80 e0       	ldi	r24, 0x00	; 0
}
 250:	08 95       	ret

00000252 <_ZN3NRF4initEv>:
}


void NRF::init(){
	//ACT and RDYN set as inputs	
	ACT_DDR &= ~(1<<ACT_PIN);	
 252:	20 98       	cbi	0x04, 0	; 4
	RDYN_DDR &= ~(1<<RDYN_PIN);
 254:	22 98       	cbi	0x04, 2	; 4
	
	//REQN set as output
	REQN_DDR |= (1<<REQN_PIN);
 256:	21 9a       	sbi	0x04, 1	; 4
	//////DON'T KNOW WHY THIS IS CAUSING A PROBLEM********************************************************
	//set pullup on RDYN
	//RDYN_PORT |= (1<<RDYN_PIN);
	
	//REQN is active low, so initialize it HIGH
	SetREQN();
 258:	29 9a       	sbi	0x05, 1	; 5
 25a:	08 95       	ret

0000025c <_ZN3NRFC1Ev>:

//uint8_t initCodes[12][32];
static uint8_t initCount = 0;

//NRF::NRF(hal_aci_data_t *message){
NRF::NRF(){
 25c:	cf 93       	push	r28
 25e:	df 93       	push	r29
 260:	ec 01       	movw	r28, r24
	//msg = message;
	
	init();
 262:	0e 94 29 01 	call	0x252	; 0x252 <_ZN3NRF4initEv>
	RxCount = 0x00;
 266:	1d 8a       	std	Y+21, r1	; 0x15
	temperature = 0x00;
 268:	1f 8a       	std	Y+23, r1	; 0x17
 26a:	1e 8a       	std	Y+22, r1	; 0x16
	//mode = 0x00;
	//set to INIT_MODE and RX_READY
	//we are waiting for a NRF_EVT_DEVICE_STARTED in NRF_MODE_SETUP
	//status |= (1<<NRF_RX_READY | 1<<NRF_INIT_MODE | 1<<NRF_WAIT_FOR_RESPONSE);
	status |= (1<<NRF_RX_READY | 1<<NRF_WAIT_FOR_RESPONSE);
 26c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 26e:	80 69       	ori	r24, 0x90	; 144
 270:	8a 8f       	std	Y+26, r24	; 0x1a
}
 272:	df 91       	pop	r29
 274:	cf 91       	pop	r28
 276:	08 95       	ret

00000278 <_ZN3NRF11clearTxDataEv>:
		}
		
	}//else if(RDYN == 0)	
	
}//transferACI()
void NRF::clearTxData(){
 278:	fc 01       	movw	r30, r24
 27a:	fb 96       	adiw	r30, 0x3b	; 59
	for(int i = 0; i<32; i++) 
 27c:	20 e0       	ldi	r18, 0x00	; 0
 27e:	30 e0       	ldi	r19, 0x00	; 0
		TxData[i] = 0x00;		
 280:	11 92       	st	Z+, r1
		
	}//else if(RDYN == 0)	
	
}//transferACI()
void NRF::clearTxData(){
	for(int i = 0; i<32; i++) 
 282:	2f 5f       	subi	r18, 0xFF	; 255
 284:	3f 4f       	sbci	r19, 0xFF	; 255
 286:	20 32       	cpi	r18, 0x20	; 32
 288:	31 05       	cpc	r19, r1
 28a:	d1 f7       	brne	.-12     	; 0x280 <_ZN3NRF11clearTxDataEv+0x8>
		TxData[i] = 0x00;		
}
 28c:	08 95       	ret

0000028e <_ZN3NRF13PrepareTxDataEhPhh>:
///@brief Send data from uC to nRF8001
///@param command
///@param data
///@param length Length of data
///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::PrepareTxData(uint8_t command, uint8_t *data, uint8_t length){
 28e:	ef 92       	push	r14
 290:	ff 92       	push	r15
 292:	0f 93       	push	r16
 294:	1f 93       	push	r17
 296:	cf 93       	push	r28
 298:	df 93       	push	r29
 29a:	ec 01       	movw	r28, r24
 29c:	16 2f       	mov	r17, r22
 29e:	e4 2e       	mov	r14, r20
 2a0:	f5 2e       	mov	r15, r21
 2a2:	02 2f       	mov	r16, r18
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 2a4:	fc 01       	movw	r30, r24
 2a6:	ef 58       	subi	r30, 0x8F	; 143
 2a8:	ff 4f       	sbci	r31, 0xFF	; 255
///@param length Length of data
///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::PrepareTxData(uint8_t command, uint8_t *data, uint8_t length){
	//TODO: write this function
	int i;
	if (isInitializing())
 2aa:	80 81       	ld	r24, Z
 2ac:	82 30       	cpi	r24, 0x02	; 2
 2ae:	e1 f0       	breq	.+56     	; 0x2e8 <_ZN3NRF13PrepareTxDataEhPhh+0x5a>
		return 0x01;
	if (hasDataToSend())
 2b0:	ce 01       	movw	r24, r28
 2b2:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 2b6:	81 11       	cpse	r24, r1
 2b8:	19 c0       	rjmp	.+50     	; 0x2ec <_ZN3NRF13PrepareTxDataEhPhh+0x5e>
		return 0x02;
	if (waitingForResponse() && isSystemCommand(command))
 2ba:	ce 01       	movw	r24, r28
 2bc:	0e 94 04 01 	call	0x208	; 0x208 <_ZN3NRF18waitingForResponseEv>
 2c0:	88 23       	and	r24, r24
 2c2:	c1 f0       	breq	.+48     	; 0x2f4 <_ZN3NRF13PrepareTxDataEhPhh+0x66>
 2c4:	61 2f       	mov	r22, r17
 2c6:	ce 01       	movw	r24, r28
 2c8:	0e 94 1f 01 	call	0x23e	; 0x23e <_ZN3NRF15isSystemCommandEh>
 2cc:	81 11       	cpse	r24, r1
 2ce:	10 c0       	rjmp	.+32     	; 0x2f0 <_ZN3NRF13PrepareTxDataEhPhh+0x62>
 2d0:	11 c0       	rjmp	.+34     	; 0x2f4 <_ZN3NRF13PrepareTxDataEhPhh+0x66>
	
	//populate TxData with length and data
	TxData[0] = length + 1;
	TxData[1] = command;
	for(i = 0; i < length; i++)
		TxData[i+2] = data[i];	
 2d2:	41 91       	ld	r20, Z+
 2d4:	4d 93       	st	X+, r20
	clearTxData();
	
	//populate TxData with length and data
	TxData[0] = length + 1;
	TxData[1] = command;
	for(i = 0; i < length; i++)
 2d6:	01 96       	adiw	r24, 0x01	; 1
 2d8:	82 17       	cp	r24, r18
 2da:	93 07       	cpc	r25, r19
 2dc:	d4 f3       	brlt	.-12     	; 0x2d2 <_ZN3NRF13PrepareTxDataEhPhh+0x44>
		TxData[i+2] = data[i];	
		
	//data to send flag
	status |= (1<<NRF_TX_READY);
 2de:	8a 8d       	ldd	r24, Y+26	; 0x1a
 2e0:	80 64       	ori	r24, 0x40	; 64
 2e2:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;	//success
 2e4:	80 e0       	ldi	r24, 0x00	; 0
 2e6:	1d c0       	rjmp	.+58     	; 0x322 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::PrepareTxData(uint8_t command, uint8_t *data, uint8_t length){
	//TODO: write this function
	int i;
	if (isInitializing())
		return 0x01;
 2e8:	81 e0       	ldi	r24, 0x01	; 1
 2ea:	1b c0       	rjmp	.+54     	; 0x322 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
	if (hasDataToSend())
		return 0x02;
 2ec:	82 e0       	ldi	r24, 0x02	; 2
 2ee:	19 c0       	rjmp	.+50     	; 0x322 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
	if (waitingForResponse() && isSystemCommand(command))
		return 0x03;
 2f0:	83 e0       	ldi	r24, 0x03	; 3
 2f2:	17 c0       	rjmp	.+46     	; 0x322 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
	
	lastCommand = command;
 2f4:	fe 01       	movw	r30, r28
 2f6:	ed 58       	subi	r30, 0x8D	; 141
 2f8:	ff 4f       	sbci	r31, 0xFF	; 255
 2fa:	10 83       	st	Z, r17
	
	clearTxData();
 2fc:	ce 01       	movw	r24, r28
 2fe:	0e 94 3c 01 	call	0x278	; 0x278 <_ZN3NRF11clearTxDataEv>
	
	//populate TxData with length and data
	TxData[0] = length + 1;
 302:	81 e0       	ldi	r24, 0x01	; 1
 304:	80 0f       	add	r24, r16
 306:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = command;
 308:	1c af       	std	Y+60, r17	; 0x3c
	for(i = 0; i < length; i++)
 30a:	20 2f       	mov	r18, r16
 30c:	30 e0       	ldi	r19, 0x00	; 0
 30e:	12 16       	cp	r1, r18
 310:	13 06       	cpc	r1, r19
 312:	2c f7       	brge	.-54     	; 0x2de <_ZN3NRF13PrepareTxDataEhPhh+0x50>
 314:	ee 2d       	mov	r30, r14
 316:	ff 2d       	mov	r31, r15
 318:	de 01       	movw	r26, r28
 31a:	dd 96       	adiw	r26, 0x3d	; 61
 31c:	80 e0       	ldi	r24, 0x00	; 0
 31e:	90 e0       	ldi	r25, 0x00	; 0
 320:	d8 cf       	rjmp	.-80     	; 0x2d2 <_ZN3NRF13PrepareTxDataEhPhh+0x44>
		TxData[i+2] = data[i];	
		
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData
 322:	df 91       	pop	r29
 324:	cf 91       	pop	r28
 326:	1f 91       	pop	r17
 328:	0f 91       	pop	r16
 32a:	ff 90       	pop	r15
 32c:	ef 90       	pop	r14
 32e:	08 95       	ret

00000330 <_ZN3NRF10disconnectEh>:
	localData[2] = (advInterval&0x00FF);	//LSB
	localData[3] = (advInterval&0xFF00)>>8; //MSB
	return (PrepareTxData(NRF_CMD_BOND, localData, 4));
}//

uint8_t NRF::disconnect(uint8_t reason){
 330:	cf 93       	push	r28
 332:	df 93       	push	r29
 334:	1f 92       	push	r1
 336:	cd b7       	in	r28, 0x3d	; 61
 338:	de b7       	in	r29, 0x3e	; 62
 33a:	69 83       	std	Y+1, r22	; 0x01
	return (PrepareTxData(NRF_CMD_DISCONNECT, &reason, 1));
 33c:	21 e0       	ldi	r18, 0x01	; 1
 33e:	ae 01       	movw	r20, r28
 340:	4f 5f       	subi	r20, 0xFF	; 255
 342:	5f 4f       	sbci	r21, 0xFF	; 255
 344:	61 e1       	ldi	r22, 0x11	; 17
 346:	0e 94 47 01 	call	0x28e	; 0x28e <_ZN3NRF13PrepareTxDataEhPhh>
}//
 34a:	0f 90       	pop	r0
 34c:	df 91       	pop	r29
 34e:	cf 91       	pop	r28
 350:	08 95       	ret

00000352 <_ZN3NRF11requestDataEh>:
	if (retVal == 0x00)
		dataCredit-=1;
	return (retVal);
}//

uint8_t NRF::requestData(uint8_t servicePipeNumber){
 352:	0f 93       	push	r16
 354:	1f 93       	push	r17
 356:	cf 93       	push	r28
 358:	df 93       	push	r29
 35a:	1f 92       	push	r1
 35c:	cd b7       	in	r28, 0x3d	; 61
 35e:	de b7       	in	r29, 0x3e	; 62
 360:	8c 01       	movw	r16, r24
 362:	69 83       	std	Y+1, r22	; 0x01
	uint8_t retVal = PrepareTxData(NRF_CMD_REQUEST_DATA, &servicePipeNumber, 1);
 364:	21 e0       	ldi	r18, 0x01	; 1
 366:	ae 01       	movw	r20, r28
 368:	4f 5f       	subi	r20, 0xFF	; 255
 36a:	5f 4f       	sbci	r21, 0xFF	; 255
 36c:	67 e1       	ldi	r22, 0x17	; 23
 36e:	0e 94 47 01 	call	0x28e	; 0x28e <_ZN3NRF13PrepareTxDataEhPhh>
	if (retVal == 0x00)
 372:	81 11       	cpse	r24, r1
 374:	06 c0       	rjmp	.+12     	; 0x382 <_ZN3NRF11requestDataEh+0x30>
		dataCredit-=1;
 376:	f8 01       	movw	r30, r16
 378:	ee 58       	subi	r30, 0x8E	; 142
 37a:	ff 4f       	sbci	r31, 0xFF	; 255
 37c:	90 81       	ld	r25, Z
 37e:	91 50       	subi	r25, 0x01	; 1
 380:	90 83       	st	Z, r25
	return (retVal);
}//
 382:	0f 90       	pop	r0
 384:	df 91       	pop	r29
 386:	cf 91       	pop	r28
 388:	1f 91       	pop	r17
 38a:	0f 91       	pop	r16
 38c:	08 95       	ret

0000038e <_ZN3NRF13PrepareTxDataEhhPhh>:
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command, uint8_t content, uint8_t *data, uint8_t length){
 38e:	df 92       	push	r13
 390:	ef 92       	push	r14
 392:	ff 92       	push	r15
 394:	0f 93       	push	r16
 396:	1f 93       	push	r17
 398:	cf 93       	push	r28
 39a:	df 93       	push	r29
 39c:	ec 01       	movw	r28, r24
 39e:	16 2f       	mov	r17, r22
 3a0:	f4 2e       	mov	r15, r20
 3a2:	d2 2e       	mov	r13, r18
 3a4:	e3 2e       	mov	r14, r19
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 3a6:	fc 01       	movw	r30, r24
 3a8:	ef 58       	subi	r30, 0x8F	; 143
 3aa:	ff 4f       	sbci	r31, 0xFF	; 255
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command, uint8_t content, uint8_t *data, uint8_t length){
	
	int i;
	if (isInitializing())
 3ac:	80 81       	ld	r24, Z
 3ae:	82 30       	cpi	r24, 0x02	; 2
 3b0:	e1 f0       	breq	.+56     	; 0x3ea <_ZN3NRF13PrepareTxDataEhhPhh+0x5c>
		return 0x01;
	if (hasDataToSend())
 3b2:	ce 01       	movw	r24, r28
 3b4:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 3b8:	81 11       	cpse	r24, r1
 3ba:	19 c0       	rjmp	.+50     	; 0x3ee <_ZN3NRF13PrepareTxDataEhhPhh+0x60>
		return 0x02;
	if (waitingForResponse() && isSystemCommand(command))
 3bc:	ce 01       	movw	r24, r28
 3be:	0e 94 04 01 	call	0x208	; 0x208 <_ZN3NRF18waitingForResponseEv>
 3c2:	88 23       	and	r24, r24
 3c4:	c1 f0       	breq	.+48     	; 0x3f6 <_ZN3NRF13PrepareTxDataEhhPhh+0x68>
 3c6:	61 2f       	mov	r22, r17
 3c8:	ce 01       	movw	r24, r28
 3ca:	0e 94 1f 01 	call	0x23e	; 0x23e <_ZN3NRF15isSystemCommandEh>
 3ce:	81 11       	cpse	r24, r1
 3d0:	10 c0       	rjmp	.+32     	; 0x3f2 <_ZN3NRF13PrepareTxDataEhhPhh+0x64>
 3d2:	11 c0       	rjmp	.+34     	; 0x3f6 <_ZN3NRF13PrepareTxDataEhhPhh+0x68>
	//populate TxData with length and data
	TxData[0] = length + 2;
	TxData[1] = command;
	TxData[2] = content;
	for(i = 0; i < length; i++)
		TxData[i+3] = data[i];
 3d4:	21 91       	ld	r18, Z+
 3d6:	2d 93       	st	X+, r18
	clearTxData();
	//populate TxData with length and data
	TxData[0] = length + 2;
	TxData[1] = command;
	TxData[2] = content;
	for(i = 0; i < length; i++)
 3d8:	01 96       	adiw	r24, 0x01	; 1
 3da:	80 17       	cp	r24, r16
 3dc:	91 07       	cpc	r25, r17
 3de:	d4 f3       	brlt	.-12     	; 0x3d4 <_ZN3NRF13PrepareTxDataEhhPhh+0x46>
		TxData[i+3] = data[i];
	
	//data to send flag
	status |= (1<<NRF_TX_READY);
 3e0:	8a 8d       	ldd	r24, Y+26	; 0x1a
 3e2:	80 64       	ori	r24, 0x40	; 64
 3e4:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;	//success
 3e6:	80 e0       	ldi	r24, 0x00	; 0
 3e8:	1d c0       	rjmp	.+58     	; 0x424 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>

uint8_t NRF::PrepareTxData(uint8_t command, uint8_t content, uint8_t *data, uint8_t length){
	
	int i;
	if (isInitializing())
		return 0x01;
 3ea:	81 e0       	ldi	r24, 0x01	; 1
 3ec:	1b c0       	rjmp	.+54     	; 0x424 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>
	if (hasDataToSend())
		return 0x02;
 3ee:	82 e0       	ldi	r24, 0x02	; 2
 3f0:	19 c0       	rjmp	.+50     	; 0x424 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>
	if (waitingForResponse() && isSystemCommand(command))
		return 0x03;
 3f2:	83 e0       	ldi	r24, 0x03	; 3
 3f4:	17 c0       	rjmp	.+46     	; 0x424 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>
	
	lastCommand = command;
 3f6:	fe 01       	movw	r30, r28
 3f8:	ed 58       	subi	r30, 0x8D	; 141
 3fa:	ff 4f       	sbci	r31, 0xFF	; 255
 3fc:	10 83       	st	Z, r17
	
	clearTxData();
 3fe:	ce 01       	movw	r24, r28
 400:	0e 94 3c 01 	call	0x278	; 0x278 <_ZN3NRF11clearTxDataEv>
	//populate TxData with length and data
	TxData[0] = length + 2;
 404:	82 e0       	ldi	r24, 0x02	; 2
 406:	80 0f       	add	r24, r16
 408:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = command;
 40a:	1c af       	std	Y+60, r17	; 0x3c
	TxData[2] = content;
 40c:	fd ae       	std	Y+61, r15	; 0x3d
	for(i = 0; i < length; i++)
 40e:	10 e0       	ldi	r17, 0x00	; 0
 410:	10 16       	cp	r1, r16
 412:	11 06       	cpc	r1, r17
 414:	2c f7       	brge	.-54     	; 0x3e0 <_ZN3NRF13PrepareTxDataEhhPhh+0x52>
 416:	ed 2d       	mov	r30, r13
 418:	fe 2d       	mov	r31, r14
 41a:	de 01       	movw	r26, r28
 41c:	de 96       	adiw	r26, 0x3e	; 62
 41e:	80 e0       	ldi	r24, 0x00	; 0
 420:	90 e0       	ldi	r25, 0x00	; 0
 422:	d8 cf       	rjmp	.-80     	; 0x3d4 <_ZN3NRF13PrepareTxDataEhhPhh+0x46>
		TxData[i+3] = data[i];
	
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData
 424:	df 91       	pop	r29
 426:	cf 91       	pop	r28
 428:	1f 91       	pop	r17
 42a:	0f 91       	pop	r16
 42c:	ff 90       	pop	r15
 42e:	ef 90       	pop	r14
 430:	df 90       	pop	r13
 432:	08 95       	ret

00000434 <_ZN3NRF12setLocalDataEhPhh>:
return (PrepareTxData(NRF_CMD_CLOSE_REMOTE_PIPE, &servicePipeNumber, 1));
}//
#pragma endregion System Command Functions

#pragma region Data Command Functions
uint8_t NRF::setLocalData(uint8_t servicePipeNumber, uint8_t *data, uint8_t length){	
 434:	0f 93       	push	r16
	return (PrepareTxData(NRF_CMD_SET_LOCAL_DATA, servicePipeNumber, data, length));
 436:	02 2f       	mov	r16, r18
 438:	9a 01       	movw	r18, r20
 43a:	46 2f       	mov	r20, r22
 43c:	6d e0       	ldi	r22, 0x0D	; 13
 43e:	0e 94 c7 01 	call	0x38e	; 0x38e <_ZN3NRF13PrepareTxDataEhhPhh>
}//
 442:	0f 91       	pop	r16
 444:	08 95       	ret

00000446 <_ZN3NRF7connectEjj>:

uint8_t NRF::radioReset(){
	return (PrepareTxData(NRF_CMD_RADIO_RESET));
}//

uint8_t NRF::connect(uint16_t timeout, uint16_t advInterval){	
 446:	ef 92       	push	r14
 448:	ff 92       	push	r15
 44a:	0f 93       	push	r16
 44c:	1f 93       	push	r17
 44e:	cf 93       	push	r28
 450:	df 93       	push	r29
 452:	ec 01       	movw	r28, r24
 454:	e6 2e       	mov	r14, r22
 456:	f7 2e       	mov	r15, r23
 458:	04 2f       	mov	r16, r20
 45a:	15 2f       	mov	r17, r21
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 45c:	fc 01       	movw	r30, r24
 45e:	ef 58       	subi	r30, 0x8F	; 143
 460:	ff 4f       	sbci	r31, 0xFF	; 255
	//localData[1] = (timeout&0xFF00)>>8; //MSB
	//localData[2] = (advInterval&0x00FF);	//LSB
	//localData[3] = (advInterval&0xFF00)>>8; //MSB
	//return (PrepareTxData(NRF_CMD_CONNECT, localData, 4));
	
	if (isInitializing())
 462:	80 81       	ld	r24, Z
 464:	82 30       	cpi	r24, 0x02	; 2
 466:	11 f1       	breq	.+68     	; 0x4ac <_ZN3NRF7connectEjj+0x66>
	return 0x01;
	if (hasDataToSend())
 468:	ce 01       	movw	r24, r28
 46a:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 46e:	81 11       	cpse	r24, r1
 470:	1f c0       	rjmp	.+62     	; 0x4b0 <_ZN3NRF7connectEjj+0x6a>
	return 0x02;
	if (waitingForResponse())
 472:	ce 01       	movw	r24, r28
 474:	0e 94 04 01 	call	0x208	; 0x208 <_ZN3NRF18waitingForResponseEv>
 478:	81 11       	cpse	r24, r1
 47a:	1c c0       	rjmp	.+56     	; 0x4b4 <_ZN3NRF7connectEjj+0x6e>
	return 0x03;
	
	lastCommand = TxData[1];
 47c:	fe 01       	movw	r30, r28
 47e:	ed 58       	subi	r30, 0x8D	; 141
 480:	ff 4f       	sbci	r31, 0xFF	; 255
 482:	8c ad       	ldd	r24, Y+60	; 0x3c
 484:	80 83       	st	Z, r24
	
	clearTxData();
 486:	ce 01       	movw	r24, r28
 488:	0e 94 3c 01 	call	0x278	; 0x278 <_ZN3NRF11clearTxDataEv>
	TxData[0] = 0x05;	//length
 48c:	85 e0       	ldi	r24, 0x05	; 5
 48e:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = NRF_CMD_CONNECT;
 490:	8f e0       	ldi	r24, 0x0F	; 15
 492:	8c af       	std	Y+60, r24	; 0x3c
	TxData[2] = (timeout&0x00FF);	//LSB
 494:	ed ae       	std	Y+61, r14	; 0x3d
	TxData[3] = (timeout&0xFF00)>>8; //MSB
 496:	fe ae       	std	Y+62, r15	; 0x3e
	TxData[4] = (advInterval&0x00FF);	//LSB
 498:	0f af       	std	Y+63, r16	; 0x3f
	TxData[5] = (advInterval&0xFF00)>>8; //MSB
 49a:	fe 01       	movw	r30, r28
 49c:	e0 5c       	subi	r30, 0xC0	; 192
 49e:	ff 4f       	sbci	r31, 0xFF	; 255
 4a0:	10 83       	st	Z, r17
	status |= (1<<NRF_TX_READY);
 4a2:	8a 8d       	ldd	r24, Y+26	; 0x1a
 4a4:	80 64       	ori	r24, 0x40	; 64
 4a6:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;
 4a8:	80 e0       	ldi	r24, 0x00	; 0
 4aa:	05 c0       	rjmp	.+10     	; 0x4b6 <_ZN3NRF7connectEjj+0x70>
	//localData[2] = (advInterval&0x00FF);	//LSB
	//localData[3] = (advInterval&0xFF00)>>8; //MSB
	//return (PrepareTxData(NRF_CMD_CONNECT, localData, 4));
	
	if (isInitializing())
	return 0x01;
 4ac:	81 e0       	ldi	r24, 0x01	; 1
 4ae:	03 c0       	rjmp	.+6      	; 0x4b6 <_ZN3NRF7connectEjj+0x70>
	if (hasDataToSend())
	return 0x02;
 4b0:	82 e0       	ldi	r24, 0x02	; 2
 4b2:	01 c0       	rjmp	.+2      	; 0x4b6 <_ZN3NRF7connectEjj+0x70>
	if (waitingForResponse())
	return 0x03;
 4b4:	83 e0       	ldi	r24, 0x03	; 3
	TxData[3] = (timeout&0xFF00)>>8; //MSB
	TxData[4] = (advInterval&0x00FF);	//LSB
	TxData[5] = (advInterval&0xFF00)>>8; //MSB
	status |= (1<<NRF_TX_READY);
	return 0x00;
}//
 4b6:	df 91       	pop	r29
 4b8:	cf 91       	pop	r28
 4ba:	1f 91       	pop	r17
 4bc:	0f 91       	pop	r16
 4be:	ff 90       	pop	r15
 4c0:	ef 90       	pop	r14
 4c2:	08 95       	ret

000004c4 <_ZN3NRF11transferACIEv>:
nRF8001 is capable of receiving an ACI command simultaneously as it sends an ACI event to the
application controller.
The application controller shall always read the length byte from nRF8001 and check if the length is
greater than 0. If the length is greater than 0 the data on the MISO line shall be read
*/
void NRF::transferACI(void){
 4c4:	1f 93       	push	r17
 4c6:	cf 93       	push	r28
 4c8:	df 93       	push	r29
 4ca:	ec 01       	movw	r28, r24
	uint8_t length; 
	
	//transmit and receive
	if (hasDataToSend() && (TxData[0] > 0)){			
 4cc:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 4d0:	88 23       	and	r24, r24
 4d2:	09 f4       	brne	.+2      	; 0x4d6 <_ZN3NRF11transferACIEv+0x12>
 4d4:	40 c0       	rjmp	.+128    	; 0x556 <_ZN3NRF11transferACIEv+0x92>
 4d6:	8b ad       	ldd	r24, Y+59	; 0x3b
 4d8:	81 11       	cpse	r24, r1
 4da:	40 c0       	rjmp	.+128    	; 0x55c <_ZN3NRF11transferACIEv+0x98>
 4dc:	3c c0       	rjmp	.+120    	; 0x556 <_ZN3NRF11transferACIEv+0x92>
		SetREQN();
		
		//when data is received, clear the ready to receive flag until
		//the received data is handled by the process function
		if (RxData[0] != 0x00){
			status &= ~(1<<NRF_RX_READY);
 4de:	8a 8d       	ldd	r24, Y+26	; 0x1a
 4e0:	8f 77       	andi	r24, 0x7F	; 127
 4e2:	8a 8f       	std	Y+26, r24	; 0x1a
		}
		
		
		lastCommand = TxData[1];
 4e4:	6c ad       	ldd	r22, Y+60	; 0x3c
 4e6:	fe 01       	movw	r30, r28
 4e8:	ed 58       	subi	r30, 0x8D	; 141
 4ea:	ff 4f       	sbci	r31, 0xFF	; 255
 4ec:	60 83       	st	Z, r22
		
		//clear the NRF_TX_READY flag in the status register
		status &= ~(1<<NRF_TX_READY);
 4ee:	1a 8d       	ldd	r17, Y+26	; 0x1a
 4f0:	1f 7b       	andi	r17, 0xBF	; 191
		
		if (isSystemCommand(TxData[1]))
 4f2:	ce 01       	movw	r24, r28
 4f4:	0e 94 1f 01 	call	0x23e	; 0x23e <_ZN3NRF15isSystemCommandEh>
 4f8:	81 11       	cpse	r24, r1
 4fa:	02 c0       	rjmp	.+4      	; 0x500 <_ZN3NRF11transferACIEv+0x3c>
		
		
		lastCommand = TxData[1];
		
		//clear the NRF_TX_READY flag in the status register
		status &= ~(1<<NRF_TX_READY);
 4fc:	1a 8f       	std	Y+26, r17	; 0x1a
 4fe:	58 c0       	rjmp	.+176    	; 0x5b0 <_ZN3NRF11transferACIEv+0xec>
		
		if (isSystemCommand(TxData[1]))
			status |= (1<<NRF_WAIT_FOR_RESPONSE);
 500:	10 61       	ori	r17, 0x10	; 16
 502:	1a 8f       	std	Y+26, r17	; 0x1a
 504:	55 c0       	rjmp	.+170    	; 0x5b0 <_ZN3NRF11transferACIEv+0xec>
	}//if hasDataToSend
	
	//receive only
	else if(RDYN == 0)
	{
		clearTxData();
 506:	ce 01       	movw	r24, r28
 508:	0e 94 3c 01 	call	0x278	; 0x278 <_ZN3NRF11clearTxDataEv>
		//Request communication with nRF8001
		ClearREQN();
 50c:	29 98       	cbi	0x05, 1	; 5
		
		//transmit the DUMMY BYTE and receive the Rx DEBUG BYTE
		//the LENGTH BYTE is not counted as part of the length
		RxData[0] = spi.transfer1byte(0x00);
 50e:	60 e0       	ldi	r22, 0x00	; 0
 510:	85 e7       	ldi	r24, 0x75	; 117
 512:	93 e0       	ldi	r25, 0x03	; 3
 514:	0e 94 ef 00 	call	0x1de	; 0x1de <_ZN3SPI13transfer1byteEh>
 518:	8b 8f       	std	Y+27, r24	; 0x1b
		
		//Transmit a DUMMY BYTE and receive the LENGTH BYTE
		RxData[0] = spi.transfer1byte(0x00);
 51a:	60 e0       	ldi	r22, 0x00	; 0
 51c:	85 e7       	ldi	r24, 0x75	; 117
 51e:	93 e0       	ldi	r25, 0x03	; 3
 520:	0e 94 ef 00 	call	0x1de	; 0x1de <_ZN3SPI13transfer1byteEh>
 524:	8b 8f       	std	Y+27, r24	; 0x1b
 526:	28 2f       	mov	r18, r24
 528:	80 32       	cpi	r24, 0x20	; 32
 52a:	08 f0       	brcs	.+2      	; 0x52e <_ZN3NRF11transferACIEv+0x6a>
 52c:	2f e1       	ldi	r18, 0x1F	; 31
		
		length = RxData[0];
		if (length>HAL_ACI_MAX_LENGTH)
			length = HAL_ACI_MAX_LENGTH;
		if (length>0)
 52e:	22 23       	and	r18, r18
 530:	51 f0       	breq	.+20     	; 0x546 <_ZN3NRF11transferACIEv+0x82>
		{
			
			spi.transfer(&TxData[2],&RxData[1],length);
 532:	ae 01       	movw	r20, r28
 534:	44 5e       	subi	r20, 0xE4	; 228
 536:	5f 4f       	sbci	r21, 0xFF	; 255
 538:	be 01       	movw	r22, r28
 53a:	63 5c       	subi	r22, 0xC3	; 195
 53c:	7f 4f       	sbci	r23, 0xFF	; 255
 53e:	85 e7       	ldi	r24, 0x75	; 117
 540:	93 e0       	ldi	r25, 0x03	; 3
 542:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN3SPI8transferEPhS0_h>
		}//if length>0
		
		//Set REQN high to terminate the transfer
		SetREQN();
 546:	29 9a       	sbi	0x05, 1	; 5
		
		//when data is received, clear the ready to receive flag until
		//the received data is handled by the process function
		if (RxData[0] != 0x00){
 548:	8b 8d       	ldd	r24, Y+27	; 0x1b
 54a:	88 23       	and	r24, r24
 54c:	89 f1       	breq	.+98     	; 0x5b0 <_ZN3NRF11transferACIEv+0xec>
			status &= ~(1<<NRF_RX_READY);
 54e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 550:	8f 77       	andi	r24, 0x7F	; 127
 552:	8a 8f       	std	Y+26, r24	; 0x1a
 554:	2d c0       	rjmp	.+90     	; 0x5b0 <_ZN3NRF11transferACIEv+0xec>
			status |= (1<<NRF_WAIT_FOR_RESPONSE);
				
	}//if hasDataToSend
	
	//receive only
	else if(RDYN == 0)
 556:	2a 99       	sbic	0x05, 2	; 5
 558:	2b c0       	rjmp	.+86     	; 0x5b0 <_ZN3NRF11transferACIEv+0xec>
 55a:	d5 cf       	rjmp	.-86     	; 0x506 <_ZN3NRF11transferACIEv+0x42>
	//transmit and receive
	if (hasDataToSend() && (TxData[0] > 0)){			
		length = TxData[0];
	
		//Request communication with nRF8001
		ClearREQN();
 55c:	29 98       	cbi	0x05, 1	; 5
	
		//Wait for nRF8001 to clear RDYN pin indicating it is ready to receive
		while (RDYN == 1);
 55e:	85 b1       	in	r24, 0x05	; 5
	
		//transmit the Tx LENGTH BYTE and receive the Rx DEBUG BYTE
		//the LENGTH BYTE is not counted as part of the length
		RxData[0] = spi.transfer1byte(TxData[0]);
 560:	6b ad       	ldd	r22, Y+59	; 0x3b
 562:	85 e7       	ldi	r24, 0x75	; 117
 564:	93 e0       	ldi	r25, 0x03	; 3
 566:	0e 94 ef 00 	call	0x1de	; 0x1de <_ZN3SPI13transfer1byteEh>
 56a:	8b 8f       	std	Y+27, r24	; 0x1b
	
	
		//transmit the first byte of data while receiving the length byte
		//we are discarding the Rx DEBUG BYTE
		RxData[0] = spi.transfer1byte(TxData[1]);
 56c:	6c ad       	ldd	r22, Y+60	; 0x3c
 56e:	85 e7       	ldi	r24, 0x75	; 117
 570:	93 e0       	ldi	r25, 0x03	; 3
 572:	0e 94 ef 00 	call	0x1de	; 0x1de <_ZN3SPI13transfer1byteEh>
 576:	8b 8f       	std	Y+27, r24	; 0x1b
	
		////set length to the greater of TxData less the byte we already sent or 
		////RxData length
		length = (RxData[0]>(TxData[0] -1))?RxData[0]:(TxData[0]-1);
 578:	4b ad       	ldd	r20, Y+59	; 0x3b
 57a:	50 e0       	ldi	r21, 0x00	; 0
 57c:	41 50       	subi	r20, 0x01	; 1
 57e:	51 09       	sbc	r21, r1
 580:	28 2f       	mov	r18, r24
 582:	30 e0       	ldi	r19, 0x00	; 0
 584:	24 17       	cp	r18, r20
 586:	35 07       	cpc	r19, r21
 588:	0c f4       	brge	.+2      	; 0x58c <_ZN3NRF11transferACIEv+0xc8>
 58a:	9a 01       	movw	r18, r20
 58c:	20 32       	cpi	r18, 0x20	; 32
 58e:	08 f0       	brcs	.+2      	; 0x592 <_ZN3NRF11transferACIEv+0xce>
 590:	2f e1       	ldi	r18, 0x1F	; 31
		if (length>HAL_ACI_MAX_LENGTH) 
			length = HAL_ACI_MAX_LENGTH;
			
		//if (length>0)
		spi.transfer(&TxData[2],&RxData[1],length);
 592:	ae 01       	movw	r20, r28
 594:	44 5e       	subi	r20, 0xE4	; 228
 596:	5f 4f       	sbci	r21, 0xFF	; 255
 598:	be 01       	movw	r22, r28
 59a:	63 5c       	subi	r22, 0xC3	; 195
 59c:	7f 4f       	sbci	r23, 0xFF	; 255
 59e:	85 e7       	ldi	r24, 0x75	; 117
 5a0:	93 e0       	ldi	r25, 0x03	; 3
 5a2:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN3SPI8transferEPhS0_h>
		//for (uint8_t i = 0; i< length; i++){
			//RxData[i+1] = spi.transfer1byte(TxData[i+2]); 
		//}
	
		//Set REQN high to terminate the transfer
		SetREQN();
 5a6:	29 9a       	sbi	0x05, 1	; 5
		
		//when data is received, clear the ready to receive flag until
		//the received data is handled by the process function
		if (RxData[0] != 0x00){
 5a8:	8b 8d       	ldd	r24, Y+27	; 0x1b
 5aa:	81 11       	cpse	r24, r1
 5ac:	98 cf       	rjmp	.-208    	; 0x4de <_ZN3NRF11transferACIEv+0x1a>
 5ae:	9a cf       	rjmp	.-204    	; 0x4e4 <_ZN3NRF11transferACIEv+0x20>
			status &= ~(1<<NRF_RX_READY);
		}
		
	}//else if(RDYN == 0)	
	
}//transferACI()
 5b0:	df 91       	pop	r29
 5b2:	cf 91       	pop	r28
 5b4:	1f 91       	pop	r17
 5b6:	08 95       	ret

000005b8 <_ZN3NRF11clearRxDataEv>:
void NRF::clearTxData(){
	for(int i = 0; i<32; i++) 
		TxData[i] = 0x00;		
}
void NRF::clearRxData(){
 5b8:	fc 01       	movw	r30, r24
 5ba:	7b 96       	adiw	r30, 0x1b	; 27
	for(int i = 0; i<32; i++)
 5bc:	20 e0       	ldi	r18, 0x00	; 0
 5be:	30 e0       	ldi	r19, 0x00	; 0
		RxData[i] = 0x00;
 5c0:	11 92       	st	Z+, r1
void NRF::clearTxData(){
	for(int i = 0; i<32; i++) 
		TxData[i] = 0x00;		
}
void NRF::clearRxData(){
	for(int i = 0; i<32; i++)
 5c2:	2f 5f       	subi	r18, 0xFF	; 255
 5c4:	3f 4f       	sbci	r19, 0xFF	; 255
 5c6:	20 32       	cpi	r18, 0x20	; 32
 5c8:	31 05       	cpc	r19, r1
 5ca:	d1 f7       	brne	.-12     	; 0x5c0 <_ZN3NRF11clearRxDataEv+0x8>
		RxData[i] = 0x00;
}
 5cc:	08 95       	ret

000005ce <_ZN3NRF22processCommandResponseEv>:
			
		}
	}//else RxData
}//process

void NRF::processCommandResponse(){
 5ce:	cf 93       	push	r28
 5d0:	df 93       	push	r29
 5d2:	ec 01       	movw	r28, r24
	//	2		CommandOpCode (see switch statement below)
	//	3		Status of command execution
	//	4..31	Command specific data
	
	
	switch (RxData[2]){	//CommandOpCode
 5d4:	4d 8d       	ldd	r20, Y+29	; 0x1d
 5d6:	50 e0       	ldi	r21, 0x00	; 0
 5d8:	fa 01       	movw	r30, r20
 5da:	31 97       	sbiw	r30, 0x01	; 1
 5dc:	ee 31       	cpi	r30, 0x1E	; 30
 5de:	f1 05       	cpc	r31, r1
 5e0:	08 f0       	brcs	.+2      	; 0x5e4 <_ZN3NRF22processCommandResponseEv+0x16>
 5e2:	6c c0       	rjmp	.+216    	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
 5e4:	ec 5c       	subi	r30, 0xCC	; 204
 5e6:	ff 4f       	sbci	r31, 0xFF	; 255
 5e8:	0c 94 4d 06 	jmp	0xc9a	; 0xc9a <__tablejump2__>
			//RxData[3]	:	Status
			//					ACI_STATUS_ERROR_DEVICE_STATE_INVALID when used in incorrect mode
			//						can only be used in NRF_MODE_TEST, NRF_MODE_SETUP, NRF_MODE_STANDBY
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 5ec:	8a 8d       	ldd	r24, Y+26	; 0x1a
 5ee:	8f 7e       	andi	r24, 0xEF	; 239
 5f0:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 5f2:	64 c0       	rjmp	.+200    	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[3]	:	Status
			//					ACI_STATUS_ERROR_DEVICE_STATE_INVALID when used in incorrect mode
			//						can only be used in NRF_MODE_TEST
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 5f4:	8a 8d       	ldd	r24, Y+26	; 0x1a
 5f6:	8f 7e       	andi	r24, 0xEF	; 239
 5f8:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 5fa:	60 c0       	rjmp	.+192    	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[4-5]	:	DTM Event (2 bytes MSB/LSB)
			//Refer to Bluetooth Core specification v4.0, Volume 6, Part F, Direct Test Mode,
			//Sect.3.4, ‘Events’, for description of DTM event format and content
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 5fc:	8a 8d       	ldd	r24, Y+26	; 0x1a
 5fe:	8f 7e       	andi	r24, 0xEF	; 239
 600:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 602:	5c c0       	rjmp	.+184    	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[3]	:	Status
			//					ACI_STATUS_ERROR_DEVICE_STATE_INVALID when used in incorrect mode
			//						can only be used in NRF_MODE_STANDBY
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 604:	8a 8d       	ldd	r24, Y+26	; 0x1a
 606:	8f 7e       	andi	r24, 0xEF	; 239
 608:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 60a:	58 c0       	rjmp	.+176    	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[4]		: none
			
			status &= ~(1<<NRF_SLEEPING);
			
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 60c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 60e:	8d 7e       	andi	r24, 0xED	; 237
 610:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 612:	54 c0       	rjmp	.+168    	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
			
				
			//on the last run of CMD_SETUP
			//do NOT clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			//the NRF_CMD_SETUP will be followed by NRF_EVT_DEVICE_STARTED			
			if (RxData[3] == ACI_STATUS_TRANSACTION_CONTINUE){
 614:	8e 8d       	ldd	r24, Y+30	; 0x1e
 616:	81 30       	cpi	r24, 0x01	; 1
 618:	19 f4       	brne	.+6      	; 0x620 <_ZN3NRF22processCommandResponseEv+0x52>
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 61a:	8a 8d       	ldd	r24, Y+26	; 0x1a
 61c:	8f 7e       	andi	r24, 0xEF	; 239
 61e:	8a 8f       	std	Y+26, r24	; 0x1a
			}
			
			//set the NRF_RX_READY bit in the status register
			status |= (1<<NRF_RX_READY);
 620:	8a 8d       	ldd	r24, Y+26	; 0x1a
 622:	80 68       	ori	r24, 0x80	; 128
 624:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 626:	4a c0       	rjmp	.+148    	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_READ_DYNAMIC_DATA:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 628:	8a 8d       	ldd	r24, Y+26	; 0x1a
 62a:	8f 7e       	andi	r24, 0xEF	; 239
 62c:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 62e:	46 c0       	rjmp	.+140    	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_WRITE_DYNAMIC_DATA:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 630:	8a 8d       	ldd	r24, Y+26	; 0x1a
 632:	8f 7e       	andi	r24, 0xEF	; 239
 634:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 636:	42 c0       	rjmp	.+132    	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[4-5]	:	Config ID - (LSB/MSB)
			//RxData[6]		:	ACI Protocol version
			//
		
			//TODO: finish this
			version = RxData[6];
 638:	89 a1       	ldd	r24, Y+33	; 0x21
 63a:	90 e0       	ldi	r25, 0x00	; 0
 63c:	99 8f       	std	Y+25, r25	; 0x19
 63e:	88 8f       	std	Y+24, r24	; 0x18
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 640:	8a 8d       	ldd	r24, Y+26	; 0x1a
 642:	8f 7e       	andi	r24, 0xEF	; 239
 644:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 646:	3a c0       	rjmp	.+116    	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_GET_DEVICE_ADDRESS:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 648:	8a 8d       	ldd	r24, Y+26	; 0x1a
 64a:	8f 7e       	andi	r24, 0xEF	; 239
 64c:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 64e:	36 c0       	rjmp	.+108    	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_GET_BATTERY_LEVEL:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 650:	8a 8d       	ldd	r24, Y+26	; 0x1a
 652:	8f 7e       	andi	r24, 0xEF	; 239
 654:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 656:	32 c0       	rjmp	.+100    	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
			// RxData[5] : temperature MSB
		
			//data[0] = NRF_CMD_GET_TEMPERATURE;
			//data[1] = RxData[4];
			//data[2] = RxData[3];
			if (RxData[3] == ACI_STATUS_SUCCESS)
 658:	8e 8d       	ldd	r24, Y+30	; 0x1e
 65a:	81 11       	cpse	r24, r1
 65c:	09 c0       	rjmp	.+18     	; 0x670 <_ZN3NRF22processCommandResponseEv+0xa2>
			temperature = (RxData[5]<<4 | RxData[4]);
 65e:	88 a1       	ldd	r24, Y+32	; 0x20
 660:	20 e1       	ldi	r18, 0x10	; 16
 662:	82 9f       	mul	r24, r18
 664:	c0 01       	movw	r24, r0
 666:	11 24       	eor	r1, r1
 668:	2f 8d       	ldd	r18, Y+31	; 0x1f
 66a:	82 2b       	or	r24, r18
 66c:	9f 8b       	std	Y+23, r25	; 0x17
 66e:	8e 8b       	std	Y+22, r24	; 0x16
			clearRxData();
 670:	ce 01       	movw	r24, r28
 672:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <_ZN3NRF11clearRxDataEv>
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 676:	8a 8d       	ldd	r24, Y+26	; 0x1a
 678:	8f 7e       	andi	r24, 0xEF	; 239
 67a:	8a 8f       	std	Y+26, r24	; 0x1a
		break;
 67c:	1f c0       	rjmp	.+62     	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
			case NRF_CMD_RADIO_RESET:
			//will initialization have to be redone upon reset?
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 67e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 680:	8f 7e       	andi	r24, 0xEF	; 239
 682:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 684:	1b c0       	rjmp	.+54     	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
			//status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
			break;
		case NRF_CMD_SET_TX_POWER:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 686:	8a 8d       	ldd	r24, Y+26	; 0x1a
 688:	8f 7e       	andi	r24, 0xEF	; 239
 68a:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 68c:	17 c0       	rjmp	.+46     	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
			//or by NRF_EVT_PIPE_ERROR(failure)
			break;
		case NRF_CMD_SET_APP_LATENCY:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 68e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 690:	8f 7e       	andi	r24, 0xEF	; 239
 692:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 694:	13 c0       	rjmp	.+38     	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_SET_KEY:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 696:	8a 8d       	ldd	r24, Y+26	; 0x1a
 698:	8f 7e       	andi	r24, 0xEF	; 239
 69a:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 69c:	0f c0       	rjmp	.+30     	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_OPEN_ADV_PIPE:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 69e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6a0:	8f 7e       	andi	r24, 0xEF	; 239
 6a2:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6a4:	0b c0       	rjmp	.+22     	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_BROADCAST:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6a6:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6a8:	8f 7e       	andi	r24, 0xEF	; 239
 6aa:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6ac:	07 c0       	rjmp	.+14     	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_BOND_SEC_REQUEST:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6ae:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6b0:	8f 7e       	andi	r24, 0xEF	; 239
 6b2:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6b4:	03 c0       	rjmp	.+6      	; 0x6bc <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_DIRECT_CONNECT:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6b6:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6b8:	8f 7e       	andi	r24, 0xEF	; 239
 6ba:	8a 8f       	std	Y+26, r24	; 0x1a
		default:
			break;
		
	}//end switch RxData[2]
	
}//processCommandResponse()
 6bc:	df 91       	pop	r29
 6be:	cf 91       	pop	r28
 6c0:	08 95       	ret

000006c2 <_ZN3NRF7processEv>:
	//set to INIT_MODE and RX_READY
	//we are waiting for a NRF_EVT_DEVICE_STARTED in NRF_MODE_SETUP
	//status |= (1<<NRF_RX_READY | 1<<NRF_INIT_MODE | 1<<NRF_WAIT_FOR_RESPONSE);
	status |= (1<<NRF_RX_READY | 1<<NRF_WAIT_FOR_RESPONSE);
}
void NRF::process(void){	
 6c2:	1f 93       	push	r17
 6c4:	cf 93       	push	r28
 6c6:	df 93       	push	r29
 6c8:	ec 01       	movw	r28, r24
	uint8_t i;
	if (isReadyToReceiveData()){
 6ca:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6cc:	88 23       	and	r24, r24
 6ce:	1c f4       	brge	.+6      	; 0x6d6 <_ZN3NRF7processEv+0x14>
		clearRxData();
 6d0:	ce 01       	movw	r24, r28
 6d2:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <_ZN3NRF11clearRxDataEv>
	}
		
	
	//setup message from services.h file loaded onto nRF8001
	if( (mode == NRF_MODE_SETUP)  && !hasDataToSend() && !waitingForResponse() ) {
 6d6:	fe 01       	movw	r30, r28
 6d8:	ef 58       	subi	r30, 0x8F	; 143
 6da:	ff 4f       	sbci	r31, 0xFF	; 255
 6dc:	80 81       	ld	r24, Z
 6de:	82 30       	cpi	r24, 0x02	; 2
 6e0:	31 f5       	brne	.+76     	; 0x72e <_ZN3NRF7processEv+0x6c>
 6e2:	ce 01       	movw	r24, r28
 6e4:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 6e8:	81 11       	cpse	r24, r1
 6ea:	21 c0       	rjmp	.+66     	; 0x72e <_ZN3NRF7processEv+0x6c>
 6ec:	ce 01       	movw	r24, r28
 6ee:	0e 94 04 01 	call	0x208	; 0x208 <_ZN3NRF18waitingForResponseEv>
 6f2:	88 23       	and	r24, r24
 6f4:	09 f4       	brne	.+2      	; 0x6f8 <_ZN3NRF7processEv+0x36>
 6f6:	ca c0       	rjmp	.+404    	; 0x88c <_ZN3NRF7processEv+0x1ca>
 6f8:	1a c0       	rjmp	.+52     	; 0x72e <_ZN3NRF7processEv+0x6c>
		//load current line of setup msg into TX buffer
		for(int i = 0; i <= setup_msgs[initCount].buffer[0]; i++){
#ifdef PROGRAMSPACE			
			TxData[i] = pgm_read_byte(&setup_msgs[initCount].buffer[i]);
#else
			TxData[i] = setup_msgs[initCount].buffer[i];
 6fa:	dc 01       	movw	r26, r24
 6fc:	a2 0f       	add	r26, r18
 6fe:	b3 1f       	adc	r27, r19
 700:	11 96       	adiw	r26, 0x01	; 1
 702:	6c 91       	ld	r22, X
 704:	61 93       	st	Z+, r22
		
	
	//setup message from services.h file loaded onto nRF8001
	if( (mode == NRF_MODE_SETUP)  && !hasDataToSend() && !waitingForResponse() ) {
		//load current line of setup msg into TX buffer
		for(int i = 0; i <= setup_msgs[initCount].buffer[0]; i++){
 706:	2f 5f       	subi	r18, 0xFF	; 255
 708:	3f 4f       	sbci	r19, 0xFF	; 255
 70a:	42 17       	cp	r20, r18
 70c:	53 07       	cpc	r21, r19
 70e:	ac f7       	brge	.-22     	; 0x6fa <_ZN3NRF7processEv+0x38>
			TxData[i] = setup_msgs[initCount].buffer[i];
#endif
		}
		
		//set transmit ready and wait for response flags in status register
		status |= ((1<<NRF_TX_READY));
 710:	9a 8d       	ldd	r25, Y+26	; 0x1a
 712:	90 64       	ori	r25, 0x40	; 64
 714:	9a 8f       	std	Y+26, r25	; 0x1a
		
		initCount++;
 716:	81 e0       	ldi	r24, 0x01	; 1
 718:	87 0f       	add	r24, r23
		////after the last setup message
		if (initCount > NB_SETUP_MESSAGES) 
 71a:	84 31       	cpi	r24, 0x14	; 20
 71c:	18 f4       	brcc	.+6      	; 0x724 <_ZN3NRF7processEv+0x62>
		}
		
		//set transmit ready and wait for response flags in status register
		status |= ((1<<NRF_TX_READY));
		
		initCount++;
 71e:	80 93 74 03 	sts	0x0374, r24
 722:	05 c0       	rjmp	.+10     	; 0x72e <_ZN3NRF7processEv+0x6c>
		////after the last setup message
		if (initCount > NB_SETUP_MESSAGES) 
		{
			initCount = 0;
 724:	10 92 74 03 	sts	0x0374, r1
			
			clearTxData();
 728:	ce 01       	movw	r24, r28
 72a:	0e 94 3c 01 	call	0x278	; 0x278 <_ZN3NRF11clearTxDataEv>
}
uint8_t NRF::hasDataToSend(void){
	return ((status & (1<<NRF_TX_READY))?TRUE:FALSE);
}
uint8_t NRF::isReadyToReceiveData(){
	return ((status & (1<<NRF_RX_READY))?TRUE:FALSE);
 72e:	1a 8d       	ldd	r17, Y+26	; 0x1a
	}//setup message
	
	
	//handle messages received from nRF8001
	//else //testing**************************************************************************************
	if (!isReadyToReceiveData()){
 730:	11 23       	and	r17, r17
 732:	0c f4       	brge	.+2      	; 0x736 <_ZN3NRF7processEv+0x74>
 734:	a0 c0       	rjmp	.+320    	; 0x876 <_ZN3NRF7processEv+0x1b4>
		RxCount++;
 736:	8d 89       	ldd	r24, Y+21	; 0x15
 738:	91 e0       	ldi	r25, 0x01	; 1
 73a:	98 0f       	add	r25, r24
 73c:	9d 8b       	std	Y+21, r25	; 0x15
				
		switch (RxData[1]){
 73e:	4c 8d       	ldd	r20, Y+28	; 0x1c
 740:	50 e0       	ldi	r21, 0x00	; 0
 742:	fa 01       	movw	r30, r20
 744:	e1 58       	subi	r30, 0x81	; 129
 746:	f1 09       	sbc	r31, r1
 748:	ef 30       	cpi	r30, 0x0F	; 15
 74a:	f1 05       	cpc	r31, r1
 74c:	08 f0       	brcs	.+2      	; 0x750 <_ZN3NRF7processEv+0x8e>
 74e:	8e c0       	rjmp	.+284    	; 0x86c <_ZN3NRF7processEv+0x1aa>
 750:	ee 5a       	subi	r30, 0xAE	; 174
 752:	ff 4f       	sbci	r31, 0xFF	; 255
 754:	0c 94 4d 06 	jmp	0xc9a	; 0xc9a <__tablejump2__>
				//RxData[2]		:	service pipe number
				//RxData[3..23]	:	Data
				
				// Fill data with RxData values
				
				for (i = 0; i< RxData[0] - 1;i++){
 758:	5b 8d       	ldd	r21, Y+27	; 0x1b
 75a:	25 2f       	mov	r18, r21
 75c:	30 e0       	ldi	r19, 0x00	; 0
 75e:	21 50       	subi	r18, 0x01	; 1
 760:	31 09       	sbc	r19, r1
 762:	12 16       	cp	r1, r18
 764:	13 06       	cpc	r1, r19
 766:	0c f4       	brge	.+2      	; 0x76a <_ZN3NRF7processEv+0xa8>
 768:	6b c0       	rjmp	.+214    	; 0x840 <_ZN3NRF7processEv+0x17e>
 76a:	78 c0       	rjmp	.+240    	; 0x85c <_ZN3NRF7processEv+0x19a>
				//					0x02	Setup
				//					0x03	Standby
				//RxData[3]	:	HWError 0x01 = error, 0x00 = no error
				//RxData[4]	:	DataCreditAvailable - Number of DataCommand buffers available
				
				if (RxData[2]>0)
 76c:	8d 8d       	ldd	r24, Y+29	; 0x1d
 76e:	88 23       	and	r24, r24
 770:	21 f0       	breq	.+8      	; 0x77a <_ZN3NRF7processEv+0xb8>
					mode = RxData[2];
 772:	fe 01       	movw	r30, r28
 774:	ef 58       	subi	r30, 0x8F	; 143
 776:	ff 4f       	sbci	r31, 0xFF	; 255
 778:	80 83       	st	Z, r24
				
				status &= ~(1<<NRF_SLEEPING);
 77a:	81 2f       	mov	r24, r17
 77c:	8d 7f       	andi	r24, 0xFD	; 253
 77e:	8a 8f       	std	Y+26, r24	; 0x1a
				
				//when NRF_CMD_WAKEUP has been called, the NRF_WAIT_FOR_RESPONSE bit in the status register should NOT be cleared
				//when finishing a NRF_CMD_SETUP, the NRF_WAIT_FOR_RESPONSE bit in the status register SHOULD be cleared
				if (mode == NRF_MODE_SETUP){
 780:	fe 01       	movw	r30, r28
 782:	ef 58       	subi	r30, 0x8F	; 143
 784:	ff 4f       	sbci	r31, 0xFF	; 255
 786:	80 81       	ld	r24, Z
 788:	82 30       	cpi	r24, 0x02	; 2
 78a:	19 f4       	brne	.+6      	; 0x792 <_ZN3NRF7processEv+0xd0>
				//if (isInitializing()){
					//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
					status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 78c:	1d 7e       	andi	r17, 0xED	; 237
 78e:	1a 8f       	std	Y+26, r17	; 0x1a
 790:	0a c0       	rjmp	.+20     	; 0x7a6 <_ZN3NRF7processEv+0xe4>
					
				}
				
				
				if (mode == NRF_MODE_STANDBY){
 792:	83 30       	cpi	r24, 0x03	; 3
 794:	41 f4       	brne	.+16     	; 0x7a6 <_ZN3NRF7processEv+0xe4>
					//clear the NRF_INIT_MODE bit in the status register when SETUP finishes
					//status &= ~(1<<NRF_INIT_MODE);
					dataCredit = RxData[4];
 796:	8f 8d       	ldd	r24, Y+31	; 0x1f
 798:	fe 01       	movw	r30, r28
 79a:	ee 58       	subi	r30, 0x8E	; 142
 79c:	ff 4f       	sbci	r31, 0xFF	; 255
 79e:	80 83       	st	Z, r24
					status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 7a0:	8a 8d       	ldd	r24, Y+26	; 0x1a
 7a2:	8f 7e       	andi	r24, 0xEF	; 239
 7a4:	8a 8f       	std	Y+26, r24	; 0x1a
				}
				
				
				
				//set the NRF_RX_READY bit in the status register
				status |= (1<<NRF_RX_READY);
 7a6:	8a 8d       	ldd	r24, Y+26	; 0x1a
 7a8:	80 68       	ori	r24, 0x80	; 128
 7aa:	8a 8f       	std	Y+26, r24	; 0x1a
				
				//TODO: error handling
				break;
 7ac:	60 c0       	rjmp	.+192    	; 0x86e <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_ECHO:				//0x82
				//returns an identical copy of the PDU sent using the echo command in Test Mode
				//RxData[0]	:	length
				//RxData[1]	:	NRF_EVT_ECHO (0x82)
				//RxData[2..31]	:	Identical message to one sent with NRF_CMD_ECHO
				data[0] = RxData[0];
 7ae:	8b 8d       	ldd	r24, Y+27	; 0x1b
 7b0:	88 83       	st	Y, r24
				data[1] = RxData[1];
 7b2:	82 e8       	ldi	r24, 0x82	; 130
 7b4:	89 83       	std	Y+1, r24	; 0x01
				data[2] = RxData[2];
 7b6:	8d 8d       	ldd	r24, Y+29	; 0x1d
 7b8:	8a 83       	std	Y+2, r24	; 0x02
				data[3] = RxData[3];
 7ba:	8e 8d       	ldd	r24, Y+30	; 0x1e
 7bc:	8b 83       	std	Y+3, r24	; 0x03
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 7be:	1f 7e       	andi	r17, 0xEF	; 239
 7c0:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 7c2:	55 c0       	rjmp	.+170    	; 0x86e <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_HARDWARE_ERROR:	//0x83
				//provides debug information
				//in case of firmware failure, this event follows NRF_EVT_DEVICE_STARTED
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 7c4:	1f 7e       	andi	r17, 0xEF	; 239
 7c6:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 7c8:	52 c0       	rjmp	.+164    	; 0x86e <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_COMMAND_RESPONSE:	//0x84
				//confirms reception or execution of an ACI command
				processCommandResponse();				
 7ca:	ce 01       	movw	r24, r28
 7cc:	0e 94 e7 02 	call	0x5ce	; 0x5ce <_ZN3NRF22processCommandResponseEv>
				break;
 7d0:	4e c0       	rjmp	.+156    	; 0x86e <_ZN3NRF7processEv+0x1ac>
				status |= (1<<NRF_CONNECTED);
				
							//do NOT clear the NRF_WAIT_FOR_RESPONSE bit of the status register here
							//there will be either a NRF_EVT_BOND_STATUS or a NRF_EVT_PIPE_STATUS following NRF_EVT_CONNECTED
				//actually it seems to need to be cleared here
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 7d2:	81 2f       	mov	r24, r17
 7d4:	8f 7e       	andi	r24, 0xEF	; 239
 7d6:	88 60       	ori	r24, 0x08	; 8
 7d8:	8a 8f       	std	Y+26, r24	; 0x1a
				
				break;
 7da:	49 c0       	rjmp	.+146    	; 0x86e <_ZN3NRF7processEv+0x1ac>
				
				//TODO: can we be still connected if we get here through a failure to bond
				status &= ~(1<<NRF_CONNECTED | 1<<NRF_BONDED);
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 7dc:	13 7e       	andi	r17, 0xE3	; 227
 7de:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 7e0:	46 c0       	rjmp	.+140    	; 0x86e <_ZN3NRF7processEv+0x1ac>
				//					0x02		: generated by the remote peer.
				//	4		:	BondStatus-SecMode1 - LE Security Mode 1
				//	5		:	LE Security Mode 2
				//	6		:	Keys Exchanged (slave)
				//	7		:	Keys Exchanged (master)
				if (RxData[2] == 0x00){ // successful bond
 7e2:	8d 8d       	ldd	r24, Y+29	; 0x1d
 7e4:	81 11       	cpse	r24, r1
 7e6:	02 c0       	rjmp	.+4      	; 0x7ec <_ZN3NRF7processEv+0x12a>
					status |= (1<<NRF_BONDED);
 7e8:	14 60       	ori	r17, 0x04	; 4
 7ea:	1a 8f       	std	Y+26, r17	; 0x1a
				}
				
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 7ec:	8a 8d       	ldd	r24, Y+26	; 0x1a
 7ee:	8f 7e       	andi	r24, 0xEF	; 239
 7f0:	8a 8f       	std	Y+26, r24	; 0x1a
				break;
 7f2:	3d c0       	rjmp	.+122    	; 0x86e <_ZN3NRF7processEv+0x1ac>
 7f4:	fe 01       	movw	r30, r28
 7f6:	ed 59       	subi	r30, 0x9D	; 157
 7f8:	ff 4f       	sbci	r31, 0xFF	; 255
	//handle messages received from nRF8001
	//else //testing**************************************************************************************
	if (!isReadyToReceiveData()){
		RxCount++;
				
		switch (RxData[1]){
 7fa:	80 e0       	ldi	r24, 0x00	; 0
 7fc:	df 01       	movw	r26, r30
 7fe:	a6 54       	subi	r26, 0x46	; 70
 800:	b1 09       	sbc	r27, r1
				//this event is sent when there is a change in service pipe availability
				//RxData[2..9]		: 64-bit PipesOpen bitmap
				//RxData[10..17]	: 64-bit PipesClosed bitmap
				//see pg 148 of datasheet for details
				for (i = 0 ; i<8; i++){
					pipesOpen[i] = RxData[i+2];
 802:	9c 91       	ld	r25, X
 804:	de 96       	adiw	r26, 0x3e	; 62
 806:	9c 93       	st	X, r25
 808:	d6 97       	sbiw	r26, 0x36	; 54
					pipesClosed[i] = RxData[i+10];
 80a:	9c 91       	ld	r25, X
 80c:	91 93       	st	Z+, r25
			case NRF_EVT_PIPE_STATUS:
				//this event is sent when there is a change in service pipe availability
				//RxData[2..9]		: 64-bit PipesOpen bitmap
				//RxData[10..17]	: 64-bit PipesClosed bitmap
				//see pg 148 of datasheet for details
				for (i = 0 ; i<8; i++){
 80e:	8f 5f       	subi	r24, 0xFF	; 255
 810:	88 30       	cpi	r24, 0x08	; 8
 812:	a1 f7       	brne	.-24     	; 0x7fc <_ZN3NRF7processEv+0x13a>
					pipesOpen[i] = RxData[i+2];
					pipesClosed[i] = RxData[i+10];
				}
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 814:	1f 7e       	andi	r17, 0xEF	; 239
 816:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 818:	2a c0       	rjmp	.+84     	; 0x86e <_ZN3NRF7processEv+0x1ac>
				//RxData[2-3]	: ConnectionInterval (MSB first)
				//RxData[4-5]	: SlaveLatency (LSB/MSB)
				//RxData[6-7]	: SupervisionTimeout (x10ms)
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 81a:	1f 7e       	andi	r17, 0xEF	; 239
 81c:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 81e:	27 c0       	rjmp	.+78     	; 0x86e <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_DISPLAY_KEY:
				//RxData[2..7] A fixed 6-byte ASCII string representing the passkey
				//padded with zeros if shorter than 6 digits
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 820:	1f 7e       	andi	r17, 0xEF	; 239
 822:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 824:	24 c0       	rjmp	.+72     	; 0x86e <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_KEY_REQUEST:
				//RxData[2] : key requested
				//must send the SetKey command within 30 seconds after receiving this command
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 826:	1f 7e       	andi	r17, 0xEF	; 239
 828:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 82a:	21 c0       	rjmp	.+66     	; 0x86e <_ZN3NRF7processEv+0x1ac>
			//Data Events:
			case NRF_EVT_DATA_CREDIT:		//0x8A
				//RxData[2]	:	number of data credits returned to the application controller
				dataCredit += RxData[2];	
 82c:	fe 01       	movw	r30, r28
 82e:	ee 58       	subi	r30, 0x8E	; 142
 830:	ff 4f       	sbci	r31, 0xFF	; 255
 832:	9d 8d       	ldd	r25, Y+29	; 0x1d
 834:	80 81       	ld	r24, Z
 836:	89 0f       	add	r24, r25
 838:	80 83       	st	Z, r24
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);			
 83a:	1f 7e       	andi	r17, 0xEF	; 239
 83c:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 83e:	17 c0       	rjmp	.+46     	; 0x86e <_ZN3NRF7processEv+0x1ac>
				//RxData[2]		:	service pipe number
				//RxData[3..23]	:	Data
				
				// Fill data with RxData values
				
				for (i = 0; i< RxData[0] - 1;i++){
 840:	80 e0       	ldi	r24, 0x00	; 0
 842:	90 e0       	ldi	r25, 0x00	; 0
 844:	40 e0       	ldi	r20, 0x00	; 0
					data[i] = RxData[0] + 2;
 846:	5e 5f       	subi	r21, 0xFE	; 254
 848:	fe 01       	movw	r30, r28
 84a:	e8 0f       	add	r30, r24
 84c:	f9 1f       	adc	r31, r25
 84e:	50 83       	st	Z, r21
				//RxData[2]		:	service pipe number
				//RxData[3..23]	:	Data
				
				// Fill data with RxData values
				
				for (i = 0; i< RxData[0] - 1;i++){
 850:	4f 5f       	subi	r20, 0xFF	; 255
 852:	84 2f       	mov	r24, r20
 854:	90 e0       	ldi	r25, 0x00	; 0
 856:	82 17       	cp	r24, r18
 858:	93 07       	cpc	r25, r19
 85a:	b4 f3       	brlt	.-20     	; 0x848 <_ZN3NRF7processEv+0x186>
				
				//set data flag in status
				status |= (1<<NRF_DATA_TO_PROCESS);
								
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 85c:	81 2f       	mov	r24, r17
 85e:	8f 7e       	andi	r24, 0xEF	; 239
 860:	80 62       	ori	r24, 0x20	; 32
 862:	8a 8f       	std	Y+26, r24	; 0x1a
				break;
 864:	04 c0       	rjmp	.+8      	; 0x86e <_ZN3NRF7processEv+0x1ac>
			case NRF_EVT_PIPE_ERROR:
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 866:	1f 7e       	andi	r17, 0xEF	; 239
 868:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 86a:	01 c0       	rjmp	.+2      	; 0x86e <_ZN3NRF7processEv+0x1ac>
			default:			
				RxCount--;
 86c:	8d 8b       	std	Y+21, r24	; 0x15
				//RxData[0] = 0x00;					
				break;
		}//end switch		
		
		//set the NRF_RX_READY bit in the status register
		status |= (1<<NRF_RX_READY);
 86e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 870:	80 68       	ori	r24, 0x80	; 128
 872:	8a 8f       	std	Y+26, r24	; 0x1a
 874:	20 c0       	rjmp	.+64     	; 0x8b6 <_ZN3NRF7processEv+0x1f4>
	else{
		//Receive Buffer doesn't contain useful data
		
		//if nRF8001 is requesting transfer, receive it
		//if we have data to send, send it
		if ((RDYN == 0) || (hasDataToSend())) {			
 876:	2a 9b       	sbis	0x05, 2	; 5
 878:	05 c0       	rjmp	.+10     	; 0x884 <_ZN3NRF7processEv+0x1c2>
 87a:	ce 01       	movw	r24, r28
 87c:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 880:	88 23       	and	r24, r24
 882:	c9 f0       	breq	.+50     	; 0x8b6 <_ZN3NRF7processEv+0x1f4>
			transferACI();
 884:	ce 01       	movw	r24, r28
 886:	0e 94 62 02 	call	0x4c4	; 0x4c4 <_ZN3NRF11transferACIEv>
 88a:	15 c0       	rjmp	.+42     	; 0x8b6 <_ZN3NRF7processEv+0x1f4>
		
	
	//setup message from services.h file loaded onto nRF8001
	if( (mode == NRF_MODE_SETUP)  && !hasDataToSend() && !waitingForResponse() ) {
		//load current line of setup msg into TX buffer
		for(int i = 0; i <= setup_msgs[initCount].buffer[0]; i++){
 88c:	70 91 74 03 	lds	r23, 0x0374
 890:	61 e2       	ldi	r22, 0x21	; 33
 892:	76 9f       	mul	r23, r22
 894:	f0 01       	movw	r30, r0
 896:	11 24       	eor	r1, r1
 898:	e0 50       	subi	r30, 0x00	; 0
 89a:	ff 4f       	sbci	r31, 0xFF	; 255
 89c:	41 81       	ldd	r20, Z+1	; 0x01
 89e:	50 e0       	ldi	r21, 0x00	; 0
 8a0:	fe 01       	movw	r30, r28
 8a2:	fb 96       	adiw	r30, 0x3b	; 59
 8a4:	20 e0       	ldi	r18, 0x00	; 0
 8a6:	30 e0       	ldi	r19, 0x00	; 0
#ifdef PROGRAMSPACE			
			TxData[i] = pgm_read_byte(&setup_msgs[initCount].buffer[i]);
#else
			TxData[i] = setup_msgs[initCount].buffer[i];
 8a8:	61 e2       	ldi	r22, 0x21	; 33
 8aa:	76 9f       	mul	r23, r22
 8ac:	c0 01       	movw	r24, r0
 8ae:	11 24       	eor	r1, r1
 8b0:	80 50       	subi	r24, 0x00	; 0
 8b2:	9f 4f       	sbci	r25, 0xFF	; 255
 8b4:	22 cf       	rjmp	.-444    	; 0x6fa <_ZN3NRF7processEv+0x38>
		if ((RDYN == 0) || (hasDataToSend())) {			
			transferACI();
			
		}
	}//else RxData
}//process
 8b6:	df 91       	pop	r29
 8b8:	cf 91       	pop	r28
 8ba:	1f 91       	pop	r17
 8bc:	08 95       	ret

000008be <_GLOBAL__sub_I_spi>:
	//(1<<MSTR)|             // Master/Slave select
	//(0<<SPR1)|(1<<SPR0)|   // SPI Clock Rate
	//(0<<CPOL)|             // Clock Polarity (0:SCK low / 1:SCK hi when idle)
	//(0<<CPHA))             // Clock Phase (0:leading / 1:trailing edge sampling)

SPI spi(SPI_SETTING);
 8be:	63 e7       	ldi	r22, 0x73	; 115
 8c0:	85 e7       	ldi	r24, 0x75	; 117
 8c2:	93 e0       	ldi	r25, 0x03	; 3
 8c4:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <_ZN3SPIC1Eh>
 8c8:	08 95       	ret

000008ca <_ZN6TIMER1C1Ehhj>:
TIMER1::TIMER1(){
	TIMER1(TIMER_DIV1, 0, 0);
}

///@brief initialize AD converter on Atmega168 for
TIMER1::TIMER1(uint8_t pscalar, uint8_t WGMmode, uint16_t rload){
 8ca:	fc 01       	movw	r30, r24
	reload = rload;
 8cc:	33 83       	std	Z+3, r19	; 0x03
 8ce:	22 83       	std	Z+2, r18	; 0x02
	mode = WGMmode;
 8d0:	41 83       	std	Z+1, r20	; 0x01
	prescalar = pscalar;
 8d2:	60 83       	st	Z, r22
	
	// The PRTIM1 bit in the Power reduction register must be written to zero to enable Timer/Counter1 module.
	PRR &= ~(1<<PRTIM1);
 8d4:	a4 e6       	ldi	r26, 0x64	; 100
 8d6:	b0 e0       	ldi	r27, 0x00	; 0
 8d8:	8c 91       	ld	r24, X
 8da:	87 7f       	andi	r24, 0xF7	; 247
 8dc:	8c 93       	st	X, r24
	
	//disable timer1
	TCCR1B = 0x00;
 8de:	10 92 81 00 	sts	0x0081, r1
	
	//clear counter	
	TCNT1 = 0;
 8e2:	10 92 85 00 	sts	0x0085, r1
 8e6:	10 92 84 00 	sts	0x0084, r1
	
	//set reload value
	if (mode == 4) OCR1A = reload;
 8ea:	81 81       	ldd	r24, Z+1	; 0x01
 8ec:	84 30       	cpi	r24, 0x04	; 4
 8ee:	31 f4       	brne	.+12     	; 0x8fc <_ZN6TIMER1C1Ehhj+0x32>
 8f0:	82 81       	ldd	r24, Z+2	; 0x02
 8f2:	93 81       	ldd	r25, Z+3	; 0x03
 8f4:	90 93 89 00 	sts	0x0089, r25
 8f8:	80 93 88 00 	sts	0x0088, r24
	if (mode == 12) ICR1 = reload;
 8fc:	81 81       	ldd	r24, Z+1	; 0x01
 8fe:	8c 30       	cpi	r24, 0x0C	; 12
 900:	31 f4       	brne	.+12     	; 0x90e <__stack+0xf>
 902:	82 81       	ldd	r24, Z+2	; 0x02
 904:	93 81       	ldd	r25, Z+3	; 0x03
 906:	90 93 87 00 	sts	0x0087, r25
 90a:	80 93 86 00 	sts	0x0086, r24
	if (mode == 0) TCNT1 = reload;
 90e:	81 81       	ldd	r24, Z+1	; 0x01
 910:	81 11       	cpse	r24, r1
 912:	06 c0       	rjmp	.+12     	; 0x920 <__stack+0x21>
 914:	82 81       	ldd	r24, Z+2	; 0x02
 916:	93 81       	ldd	r25, Z+3	; 0x03
 918:	90 93 85 00 	sts	0x0085, r25
 91c:	80 93 84 00 	sts	0x0084, r24
	
	//setup and enable timer
	TCCR1A = (mode & 0x03);		//normal timer operation, no PWM, etc
 920:	81 81       	ldd	r24, Z+1	; 0x01
 922:	83 70       	andi	r24, 0x03	; 3
 924:	80 93 80 00 	sts	0x0080, r24
	//TCCR1B = ((mode & 0x0C)<<WGM12) | (prescalar << CS10);
	TCCR1C = 0x00;		//force output compare off	
 928:	10 92 82 00 	sts	0x0082, r1
 92c:	08 95       	ret

0000092e <_ZN6TIMER15startEv>:
	//sei();
}

void	TIMER1::start(void)
{
	TCCR1B = ((mode & 0x0C)<<WGM12) | (prescalar << CS10);
 92e:	fc 01       	movw	r30, r24
 930:	21 81       	ldd	r18, Z+1	; 0x01
 932:	2c 70       	andi	r18, 0x0C	; 12
 934:	22 0f       	add	r18, r18
 936:	22 0f       	add	r18, r18
 938:	22 0f       	add	r18, r18
 93a:	90 81       	ld	r25, Z
 93c:	82 2f       	mov	r24, r18
 93e:	89 2b       	or	r24, r25
 940:	80 93 81 00 	sts	0x0081, r24
 944:	08 95       	ret

00000946 <_ZN6TIMER117isCompareAFlagSetEv>:
	return ((TIFR1 & 1<<TOV1)? 1:0);
	//return ((EIFR & 1<< INTF0)?1:0);
}

uint8_t TIMER1::isCompareAFlagSet(){
	return ((TIFR1 & 1<<OCF1A)? 1:0);
 946:	86 b3       	in	r24, 0x16	; 22
	
}
 948:	86 95       	lsr	r24
 94a:	81 70       	andi	r24, 0x01	; 1
 94c:	08 95       	ret

0000094e <_ZN6TIMER117clearCompareAFlagEv>:
	
	//EIFR = (1<<INTF0);		//Reset flag
}

void	TIMER1::clearCompareAFlag(){
	TIFR1 |= (1<<OCF1A);
 94e:	b1 9a       	sbi	0x16, 1	; 22
 950:	08 95       	ret

00000952 <_ZN6TIMER18setCountEj>:
	
	//EIFR = (1<<INTF0);		//Reset flag
}

void	TIMER1::setCount(uint16_t count){
	TCNT1 = count;
 952:	70 93 85 00 	sts	0x0085, r23
 956:	60 93 84 00 	sts	0x0084, r22
 95a:	08 95       	ret

0000095c <main>:
//  3. SLEEP;
//	4. After waking, DisableSleep()

#pragma endregion sleep

int main(void){	
 95c:	cf 93       	push	r28
 95e:	df 93       	push	r29
 960:	cd b7       	in	r28, 0x3d	; 61
 962:	de b7       	in	r29, 0x3e	; 62
 964:	2d 97       	sbiw	r28, 0x0d	; 13
 966:	0f b6       	in	r0, 0x3f	; 63
 968:	f8 94       	cli
 96a:	de bf       	out	0x3e, r29	; 62
 96c:	0f be       	out	0x3f, r0	; 63
 96e:	cd bf       	out	0x3d, r28	; 61
	//timer
	// 8MHz/90Hz			= 88,888.8888 cycles to count
	// 88,888.888 / 8 (div8)	= 11,111 = 0x2B67
	
	//prescalar, mode, reload
	TIMER1 timer(TIMER_DIV8, 4, 0x2B67);
 970:	27 e6       	ldi	r18, 0x67	; 103
 972:	3b e2       	ldi	r19, 0x2B	; 43
 974:	44 e0       	ldi	r20, 0x04	; 4
 976:	62 e0       	ldi	r22, 0x02	; 2
 978:	ce 01       	movw	r24, r28
 97a:	08 96       	adiw	r24, 0x08	; 8
 97c:	0e 94 65 04 	call	0x8ca	; 0x8ca <_ZN6TIMER1C1Ehhj>
	
	//pin, prescalar
	ANALOG sensor(ADC_PIN, ADC_DIV64);
 980:	46 e0       	ldi	r20, 0x06	; 6
 982:	60 e0       	ldi	r22, 0x00	; 0
 984:	ce 01       	movw	r24, r28
 986:	0c 96       	adiw	r24, 0x0c	; 12
 988:	0e 94 b1 00 	call	0x162	; 0x162 <_ZN6ANALOGC1Ehh>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 98c:	2f ef       	ldi	r18, 0xFF	; 255
 98e:	84 e3       	ldi	r24, 0x34	; 52
 990:	9c e0       	ldi	r25, 0x0C	; 12
 992:	21 50       	subi	r18, 0x01	; 1
 994:	80 40       	sbci	r24, 0x00	; 0
 996:	90 40       	sbci	r25, 0x00	; 0
 998:	e1 f7       	brne	.-8      	; 0x992 <main+0x36>
 99a:	00 c0       	rjmp	.+0      	; 0x99c <main+0x40>
 99c:	00 00       	nop
#endif
	
	_delay_ms(500);
	
	//d6,d7 - LEDs
	DDRD = 0xC0;			//set PD7:6 to outputs for LEDs
 99e:	80 ec       	ldi	r24, 0xC0	; 192
 9a0:	8a b9       	out	0x0a, r24	; 10
	//PD2 as an input for switch
	RED_ON;					//Set PD7 high and PD6 low
 9a2:	55 98       	cbi	0x0a, 5	; 10
 9a4:	8b b1       	in	r24, 0x0b	; 11
 9a6:	8f 73       	andi	r24, 0x3F	; 63
 9a8:	80 68       	ori	r24, 0x80	; 128
 9aa:	8b b9       	out	0x0b, r24	; 11
	
	//Switch
	PORTD |= (1<<PD2);		//set PD2 to high(pullup resistor) for switch
 9ac:	5a 9a       	sbi	0x0b, 2	; 11
	
	//External Interrupt Mask Register
	EIMSK |= (1<<INT0);	//turn on interrupt 0 (PD2)
 9ae:	e8 9a       	sbi	0x1d, 0	; 29
	
	////External Interrupt Control Register A
	//EICRA = 0x02;		//Interrupt on falling edge of INT0
	EICRA = 0x00;		//Interrupt on low level of INT0
 9b0:	10 92 69 00 	sts	0x0069, r1
	
	//opamp is Powered Down when PD is low, initialize HIGH?
	//250nS delay when powering up, 50nS delay when powering down (1/8MHz = 125nS)
	WakeOpAmp();
 9b4:	41 9a       	sbi	0x08, 1	; 8
	sensor.clearFlag();
 9b6:	ce 01       	movw	r24, r28
 9b8:	0c 96       	adiw	r24, 0x0c	; 12
 9ba:	0e 94 c6 00 	call	0x18c	; 0x18c <_ZN6ANALOG9clearFlagEv>
 9be:	ef ef       	ldi	r30, 0xFF	; 255
 9c0:	f4 e3       	ldi	r31, 0x34	; 52
 9c2:	2c e0       	ldi	r18, 0x0C	; 12
 9c4:	e1 50       	subi	r30, 0x01	; 1
 9c6:	f0 40       	sbci	r31, 0x00	; 0
 9c8:	20 40       	sbci	r18, 0x00	; 0
 9ca:	e1 f7       	brne	.-8      	; 0x9c4 <main+0x68>
 9cc:	00 c0       	rjmp	.+0      	; 0x9ce <main+0x72>
 9ce:	00 00       	nop
	enum lights_t {I,R,O} led_state = R;
		 
	state_t state = INIT;
	uint8_t oxygenSaturationData[PIPE_OXYGEN_SATURATION_O2_SET_MAX_SIZE];// = {0,1,2,3,4,5,6};
	uint8_t count = 0;
	uint8_t settings = 0x00;
 9d0:	91 2c       	mov	r9, r1
	ANALOG sensor(ADC_PIN, ADC_DIV64);
	
	enum state_t {INIT = 0x00, CONNECT, CONNECTING, SEND, RECEIVE, IDLE, GO2SLEEP, WAKEUP};
	enum lights_t {I,R,O} led_state = R;
		 
	state_t state = INIT;
 9d2:	81 2c       	mov	r8, r1
	
	//pin, prescalar
	ANALOG sensor(ADC_PIN, ADC_DIV64);
	
	enum state_t {INIT = 0x00, CONNECT, CONNECTING, SEND, RECEIVE, IDLE, GO2SLEEP, WAKEUP};
	enum lights_t {I,R,O} led_state = R;
 9d4:	22 24       	eor	r2, r2
 9d6:	23 94       	inc	r2
			if (nrf.data[0] == PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX){
				settings = nrf.data[1];				
			}
			nrf.dataHasBeenProcessed();
			if (settings == PULSEOX_GO_TO_SLEEP)
				state = GO2SLEEP;
 9d8:	0f 2e       	mov	r0, r31
 9da:	f6 e0       	ldi	r31, 0x06	; 6
 9dc:	7f 2e       	mov	r7, r31
 9de:	f0 2d       	mov	r31, r0
#endif	
	
	while(1){		
		if (nrf.hasDataToProcess()){
			if (nrf.data[0] == PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX){
				settings = nrf.data[1];				
 9e0:	0f 2e       	mov	r0, r31
 9e2:	f8 e7       	ldi	r31, 0x78	; 120
 9e4:	ef 2e       	mov	r14, r31
 9e6:	f3 e0       	ldi	r31, 0x03	; 3
 9e8:	ff 2e       	mov	r15, r31
 9ea:	f0 2d       	mov	r31, r0
			nrf.dataHasBeenProcessed();
			if (settings == PULSEOX_GO_TO_SLEEP)
				state = GO2SLEEP;
		}
		
		if (nrf.mode == NRF_MODE_STANDBY){			
 9ec:	08 ee       	ldi	r16, 0xE8	; 232
 9ee:	13 e0       	ldi	r17, 0x03	; 3
 9f0:	0f 2e       	mov	r0, r31
 9f2:	f7 e0       	ldi	r31, 0x07	; 7
 9f4:	4f 2e       	mov	r4, r31
 9f6:	f0 2d       	mov	r31, r0
						//nrf.wakeup();
					//}
					
					if (!nrf.isSleeping() && !nrf.hasDataToSend()){
						RED_ON;
						state = CONNECT;
 9f8:	55 24       	eor	r5, r5
 9fa:	53 94       	inc	r5
#define SLEEP_MODE_STANDBY		0b110
#define EnableSleep() 			SMCR |= (1<<SE)
#define DisableSleep()			SMCR &= ~(1<<SE)
void SetSleepMode(uint8_t mode){
	if((mode == SLEEP_MODE_STANDBY) | (mode<=SLEEP_MODE_POWER_SAVE))
	SMCR = (mode<<SM0);
 9fc:	68 94       	set
 9fe:	33 24       	eor	r3, r3
 a00:	32 f8       	bld	r3, 2
									oxygenSaturationData[6*count+5] = ADCH;
									RED_ON;
									led_state = R;
									break;
								case R:
									oxygenSaturationData[6*count+2] = ADCL;
 a02:	0f 2e       	mov	r0, r31
 a04:	f8 e7       	ldi	r31, 0x78	; 120
 a06:	af 2e       	mov	r10, r31
 a08:	b1 2c       	mov	r11, r1
 a0a:	f0 2d       	mov	r31, r0
									oxygenSaturationData[6*count+1] = ADCH;
 a0c:	0f 2e       	mov	r0, r31
 a0e:	f9 e7       	ldi	r31, 0x79	; 121
 a10:	cf 2e       	mov	r12, r31
 a12:	d1 2c       	mov	r13, r1
 a14:	f0 2d       	mov	r31, r0
									IR_ON;
									led_state = I;
 a16:	61 2c       	mov	r6, r1
#ifdef TESTMODE	
	lcdClearDisplay();
#endif	
	
	while(1){		
		if (nrf.hasDataToProcess()){
 a18:	87 e7       	ldi	r24, 0x77	; 119
 a1a:	93 e0       	ldi	r25, 0x03	; 3
 a1c:	0e 94 0f 01 	call	0x21e	; 0x21e <_ZN3NRF16hasDataToProcessEv>
 a20:	88 23       	and	r24, r24
 a22:	71 f0       	breq	.+28     	; 0xa40 <main+0xe4>
			if (nrf.data[0] == PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX){
 a24:	80 91 77 03 	lds	r24, 0x0377
 a28:	82 30       	cpi	r24, 0x02	; 2
 a2a:	11 f4       	brne	.+4      	; 0xa30 <main+0xd4>
				settings = nrf.data[1];				
 a2c:	f7 01       	movw	r30, r14
 a2e:	90 80       	ld	r9, Z
			}
			nrf.dataHasBeenProcessed();
 a30:	87 e7       	ldi	r24, 0x77	; 119
 a32:	93 e0       	ldi	r25, 0x03	; 3
 a34:	0e 94 15 01 	call	0x22a	; 0x22a <_ZN3NRF20dataHasBeenProcessedEv>
			if (settings == PULSEOX_GO_TO_SLEEP)
 a38:	f1 e0       	ldi	r31, 0x01	; 1
 a3a:	9f 12       	cpse	r9, r31
 a3c:	01 c0       	rjmp	.+2      	; 0xa40 <main+0xe4>
				state = GO2SLEEP;
 a3e:	87 2c       	mov	r8, r7
		}
		
		if (nrf.mode == NRF_MODE_STANDBY){			
 a40:	f8 01       	movw	r30, r16
 a42:	80 81       	ld	r24, Z
 a44:	83 30       	cpi	r24, 0x03	; 3
 a46:	09 f0       	breq	.+2      	; 0xa4a <main+0xee>
 a48:	fb c0       	rjmp	.+502    	; 0xc40 <main+0x2e4>
			if(buttonWasPressed){
 a4a:	80 91 76 03 	lds	r24, 0x0376
 a4e:	88 23       	and	r24, r24
 a50:	89 f0       	breq	.+34     	; 0xa74 <main+0x118>
				buttonWasPressed = false;
 a52:	60 92 76 03 	sts	0x0376, r6
				if (state == GO2SLEEP){
 a56:	f6 e0       	ldi	r31, 0x06	; 6
 a58:	8f 12       	cpse	r8, r31
 a5a:	06 c0       	rjmp	.+12     	; 0xa68 <main+0x10c>
					RED_ON; //testing
 a5c:	55 98       	cbi	0x0a, 5	; 10
 a5e:	8b b1       	in	r24, 0x0b	; 11
 a60:	8f 73       	andi	r24, 0x3F	; 63
 a62:	80 68       	ori	r24, 0x80	; 128
 a64:	8b b9       	out	0x0b, r24	; 11
 a66:	c5 c0       	rjmp	.+394    	; 0xbf2 <main+0x296>
					state = WAKEUP;
				}else{
					RED_ON;
 a68:	55 98       	cbi	0x0a, 5	; 10
 a6a:	8b b1       	in	r24, 0x0b	; 11
 a6c:	8f 73       	andi	r24, 0x3F	; 63
 a6e:	80 68       	ori	r24, 0x80	; 128
 a70:	8b b9       	out	0x0b, r24	; 11
 a72:	a3 c0       	rjmp	.+326    	; 0xbba <main+0x25e>
					state = GO2SLEEP;
				}
			}
			
			switch (state){
 a74:	88 2d       	mov	r24, r8
 a76:	90 e0       	ldi	r25, 0x00	; 0
 a78:	fc 01       	movw	r30, r24
 a7a:	ef 59       	subi	r30, 0x9F	; 159
 a7c:	ff 4f       	sbci	r31, 0xFF	; 255
 a7e:	0c 94 4d 06 	jmp	0xc9a	; 0xc9a <__tablejump2__>
				case INIT:	//initializing
					if (!nrf.isInitializing()){
 a82:	87 e7       	ldi	r24, 0x77	; 119
 a84:	93 e0       	ldi	r25, 0x03	; 3
 a86:	0e 94 f5 00 	call	0x1ea	; 0x1ea <_ZN3NRF14isInitializingEv>
 a8a:	81 11       	cpse	r24, r1
 a8c:	d9 c0       	rjmp	.+434    	; 0xc40 <main+0x2e4>
						timer.start();
 a8e:	ce 01       	movw	r24, r28
 a90:	08 96       	adiw	r24, 0x08	; 8
 a92:	0e 94 97 04 	call	0x92e	; 0x92e <_ZN6TIMER15startEv>
						sei();	
 a96:	78 94       	sei
						RED_ON;			
 a98:	55 98       	cbi	0x0a, 5	; 10
 a9a:	8b b1       	in	r24, 0x0b	; 11
 a9c:	8f 73       	andi	r24, 0x3F	; 63
 a9e:	80 68       	ori	r24, 0x80	; 128
 aa0:	8b b9       	out	0x0b, r24	; 11
						state = GO2SLEEP;
 aa2:	87 2c       	mov	r8, r7
 aa4:	cd c0       	rjmp	.+410    	; 0xc40 <main+0x2e4>
					//_delay_ms(25);
#endif
					break;				
					
				case CONNECT:	//connect
					if (nrf.connect(180,0x0100) == 0x00)
 aa6:	40 e0       	ldi	r20, 0x00	; 0
 aa8:	51 e0       	ldi	r21, 0x01	; 1
 aaa:	64 eb       	ldi	r22, 0xB4	; 180
 aac:	70 e0       	ldi	r23, 0x00	; 0
 aae:	87 e7       	ldi	r24, 0x77	; 119
 ab0:	93 e0       	ldi	r25, 0x03	; 3
 ab2:	0e 94 23 02 	call	0x446	; 0x446 <_ZN3NRF7connectEjj>
 ab6:	88 23       	and	r24, r24
 ab8:	09 f4       	brne	.+2      	; 0xabc <main+0x160>
 aba:	b2 c0       	rjmp	.+356    	; 0xc20 <main+0x2c4>
 abc:	c1 c0       	rjmp	.+386    	; 0xc40 <main+0x2e4>
						state = CONNECTING;
					break;				
				
				case CONNECTING:	
					if (nrf.isConnected())
 abe:	87 e7       	ldi	r24, 0x77	; 119
 ac0:	93 e0       	ldi	r25, 0x03	; 3
 ac2:	0e 94 09 01 	call	0x212	; 0x212 <_ZN3NRF11isConnectedEv>
 ac6:	81 11       	cpse	r24, r1
 ac8:	af c0       	rjmp	.+350    	; 0xc28 <main+0x2cc>
 aca:	ba c0       	rjmp	.+372    	; 0xc40 <main+0x2e4>
						state = IDLE;
					break;
					
				case SEND:					
					if (0x00 == nrf.setLocalData(PIPE_OXYGEN_SATURATION_O2_SET, oxygenSaturationData, PIPE_OXYGEN_SATURATION_O2_SET_MAX_SIZE)){						
 acc:	24 2d       	mov	r18, r4
 ace:	ae 01       	movw	r20, r28
 ad0:	4f 5f       	subi	r20, 0xFF	; 255
 ad2:	5f 4f       	sbci	r21, 0xFF	; 255
 ad4:	65 2d       	mov	r22, r5
 ad6:	87 e7       	ldi	r24, 0x77	; 119
 ad8:	93 e0       	ldi	r25, 0x03	; 3
 ada:	0e 94 1a 02 	call	0x434	; 0x434 <_ZN3NRF12setLocalDataEhPhh>
 ade:	81 11       	cpse	r24, r1
 ae0:	af c0       	rjmp	.+350    	; 0xc40 <main+0x2e4>
						oxygenSaturationData[0]++;									
 ae2:	89 81       	ldd	r24, Y+1	; 0x01
 ae4:	8f 5f       	subi	r24, 0xFF	; 255
 ae6:	89 83       	std	Y+1, r24	; 0x01
						state = IDLE;	
 ae8:	0f 2e       	mov	r0, r31
 aea:	f5 e0       	ldi	r31, 0x05	; 5
 aec:	8f 2e       	mov	r8, r31
 aee:	f0 2d       	mov	r31, r0
 af0:	a7 c0       	rjmp	.+334    	; 0xc40 <main+0x2e4>
					}					
					break;
				
				case RECEIVE:
					nrf.requestData(PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX);
 af2:	62 e0       	ldi	r22, 0x02	; 2
 af4:	87 e7       	ldi	r24, 0x77	; 119
 af6:	93 e0       	ldi	r25, 0x03	; 3
 af8:	0e 94 a9 01 	call	0x352	; 0x352 <_ZN3NRF11requestDataEh>
					state = IDLE;
 afc:	0f 2e       	mov	r0, r31
 afe:	f5 e0       	ldi	r31, 0x05	; 5
 b00:	8f 2e       	mov	r8, r31
 b02:	f0 2d       	mov	r31, r0
					break;				
 b04:	9d c0       	rjmp	.+314    	; 0xc40 <main+0x2e4>
																
				case IDLE:		//idle
					if(!nrf.isConnected()){
 b06:	87 e7       	ldi	r24, 0x77	; 119
 b08:	93 e0       	ldi	r25, 0x03	; 3
 b0a:	0e 94 09 01 	call	0x212	; 0x212 <_ZN3NRF11isConnectedEv>
 b0e:	88 23       	and	r24, r24
 b10:	09 f4       	brne	.+2      	; 0xb14 <main+0x1b8>
 b12:	8f c0       	rjmp	.+286    	; 0xc32 <main+0x2d6>
						state = GO2SLEEP;
					}else {
						if (timer.isCompareAFlagSet()){
 b14:	ce 01       	movw	r24, r28
 b16:	08 96       	adiw	r24, 0x08	; 8
 b18:	0e 94 a3 04 	call	0x946	; 0x946 <_ZN6TIMER117isCompareAFlagSetEv>
 b1c:	88 23       	and	r24, r24
 b1e:	71 f0       	breq	.+28     	; 0xb3c <main+0x1e0>
							timer.clearCompareAFlag();
 b20:	ce 01       	movw	r24, r28
 b22:	08 96       	adiw	r24, 0x08	; 8
 b24:	0e 94 a7 04 	call	0x94e	; 0x94e <_ZN6TIMER117clearCompareAFlagEv>
							timer.setCount(0);
 b28:	60 e0       	ldi	r22, 0x00	; 0
 b2a:	70 e0       	ldi	r23, 0x00	; 0
 b2c:	ce 01       	movw	r24, r28
 b2e:	08 96       	adiw	r24, 0x08	; 8
 b30:	0e 94 a9 04 	call	0x952	; 0x952 <_ZN6TIMER18setCountEj>
							sensor.start();
 b34:	ce 01       	movw	r24, r28
 b36:	0c 96       	adiw	r24, 0x0c	; 12
 b38:	0e 94 b7 00 	call	0x16e	; 0x16e <_ZN6ANALOG5startEv>
 						}//if
 					
 						if (sensor.isInterruptFlagSet()){
 b3c:	ce 01       	movw	r24, r28
 b3e:	0c 96       	adiw	r24, 0x0c	; 12
 b40:	0e 94 c2 00 	call	0x184	; 0x184 <_ZN6ANALOG18isInterruptFlagSetEv>
 b44:	88 23       	and	r24, r24
 b46:	09 f4       	brne	.+2      	; 0xb4a <main+0x1ee>
 b48:	7b c0       	rjmp	.+246    	; 0xc40 <main+0x2e4>
							sensor.clearFlag();
 b4a:	ce 01       	movw	r24, r28
 b4c:	0c 96       	adiw	r24, 0x0c	; 12
 b4e:	0e 94 c6 00 	call	0x18c	; 0x18c <_ZN6ANALOG9clearFlagEv>
							switch(led_state){
 b52:	21 e0       	ldi	r18, 0x01	; 1
 b54:	22 16       	cp	r2, r18
 b56:	01 f1       	breq	.+64     	; 0xb98 <main+0x23c>
 b58:	22 16       	cp	r2, r18
 b5a:	20 f0       	brcs	.+8      	; 0xb64 <main+0x208>
 b5c:	82 e0       	ldi	r24, 0x02	; 2
 b5e:	28 16       	cp	r2, r24
 b60:	71 f0       	breq	.+28     	; 0xb7e <main+0x222>
 b62:	6e c0       	rjmp	.+220    	; 0xc40 <main+0x2e4>
								case I:
									oxygenSaturationData[6*count+4] = ADCL;
 b64:	f5 01       	movw	r30, r10
 b66:	80 81       	ld	r24, Z
 b68:	8d 83       	std	Y+5, r24	; 0x05
									oxygenSaturationData[6*count+3] = ADCH;
 b6a:	f6 01       	movw	r30, r12
 b6c:	80 81       	ld	r24, Z
 b6e:	8c 83       	std	Y+4, r24	; 0x04
									LEDS_OFF;
 b70:	8b b1       	in	r24, 0x0b	; 11
 b72:	8f 71       	andi	r24, 0x1F	; 31
 b74:	8b b9       	out	0x0b, r24	; 11
									led_state = O;
 b76:	68 94       	set
 b78:	22 24       	eor	r2, r2
 b7a:	21 f8       	bld	r2, 1
									break;
 b7c:	61 c0       	rjmp	.+194    	; 0xc40 <main+0x2e4>
								case O:
									oxygenSaturationData[6*count+6] = ADCL;
 b7e:	f5 01       	movw	r30, r10
 b80:	80 81       	ld	r24, Z
 b82:	8f 83       	std	Y+7, r24	; 0x07
									oxygenSaturationData[6*count+5] = ADCH;
 b84:	f6 01       	movw	r30, r12
 b86:	80 81       	ld	r24, Z
 b88:	8e 83       	std	Y+6, r24	; 0x06
									RED_ON;
 b8a:	55 98       	cbi	0x0a, 5	; 10
 b8c:	8b b1       	in	r24, 0x0b	; 11
 b8e:	8f 73       	andi	r24, 0x3F	; 63
 b90:	80 68       	ori	r24, 0x80	; 128
 b92:	8b b9       	out	0x0b, r24	; 11
									led_state = R;
 b94:	25 2c       	mov	r2, r5
									break;
 b96:	54 c0       	rjmp	.+168    	; 0xc40 <main+0x2e4>
								case R:
									oxygenSaturationData[6*count+2] = ADCL;
 b98:	f5 01       	movw	r30, r10
 b9a:	80 81       	ld	r24, Z
 b9c:	8b 83       	std	Y+3, r24	; 0x03
									oxygenSaturationData[6*count+1] = ADCH;
 b9e:	f6 01       	movw	r30, r12
 ba0:	80 81       	ld	r24, Z
 ba2:	8a 83       	std	Y+2, r24	; 0x02
									IR_ON;
 ba4:	55 9a       	sbi	0x0a, 5	; 10
 ba6:	8b b1       	in	r24, 0x0b	; 11
 ba8:	8f 71       	andi	r24, 0x1F	; 31
 baa:	80 66       	ori	r24, 0x60	; 96
 bac:	8b b9       	out	0x0b, r24	; 11
									led_state = I;
									if (++count == NUM_QUEUE){
										count = 0;
										state = SEND;
 bae:	0f 2e       	mov	r0, r31
 bb0:	f3 e0       	ldi	r31, 0x03	; 3
 bb2:	8f 2e       	mov	r8, r31
 bb4:	f0 2d       	mov	r31, r0
									break;
								case R:
									oxygenSaturationData[6*count+2] = ADCL;
									oxygenSaturationData[6*count+1] = ADCH;
									IR_ON;
									led_state = I;
 bb6:	26 2c       	mov	r2, r6
 bb8:	43 c0       	rjmp	.+134    	; 0xc40 <main+0x2e4>
							} //switch(led_state)
						} //if (sensor.isInterruptFlagSet())						
					}	
					break;
				case GO2SLEEP:
					SleepOpAmp();
 bba:	41 98       	cbi	0x08, 1	; 8
					//disconnect
					if (nrf.isConnected())
 bbc:	87 e7       	ldi	r24, 0x77	; 119
 bbe:	93 e0       	ldi	r25, 0x03	; 3
 bc0:	0e 94 09 01 	call	0x212	; 0x212 <_ZN3NRF11isConnectedEv>
 bc4:	88 23       	and	r24, r24
 bc6:	29 f0       	breq	.+10     	; 0xbd2 <main+0x276>
						nrf.disconnect(0x01);
 bc8:	65 2d       	mov	r22, r5
 bca:	87 e7       	ldi	r24, 0x77	; 119
 bcc:	93 e0       	ldi	r25, 0x03	; 3
 bce:	0e 94 98 01 	call	0x330	; 0x330 <_ZN3NRF10disconnectEh>
					
					if (!nrf.isConnected()){
 bd2:	87 e7       	ldi	r24, 0x77	; 119
 bd4:	93 e0       	ldi	r25, 0x03	; 3
 bd6:	0e 94 09 01 	call	0x212	; 0x212 <_ZN3NRF11isConnectedEv>
 bda:	81 11       	cpse	r24, r1
 bdc:	2c c0       	rjmp	.+88     	; 0xc36 <main+0x2da>
						//if (!nrf.isSleeping()){
							//nrf.sleep();
						//}																
						//
						//if (nrf.isSleeping() && !nrf.hasDataToSend()){							
							LEDS_OFF;
 bde:	8b b1       	in	r24, 0x0b	; 11
 be0:	8f 71       	andi	r24, 0x1F	; 31
 be2:	8b b9       	out	0x0b, r24	; 11
#define SLEEP_MODE_STANDBY		0b110
#define EnableSleep() 			SMCR |= (1<<SE)
#define DisableSleep()			SMCR &= ~(1<<SE)
void SetSleepMode(uint8_t mode){
	if((mode == SLEEP_MODE_STANDBY) | (mode<=SLEEP_MODE_POWER_SAVE))
	SMCR = (mode<<SM0);
 be4:	33 be       	out	0x33, r3	; 51
						//
						//if (nrf.isSleeping() && !nrf.hasDataToSend()){							
							LEDS_OFF;
							//put uC to sleep							
  							SetSleepMode(SLEEP_MODE_POWER_DOWN);
  							EnableSleep();
 be6:	83 b7       	in	r24, 0x33	; 51
 be8:	81 60       	ori	r24, 0x01	; 1
 bea:	83 bf       	out	0x33, r24	; 51
  							__asm__ __volatile__ ("sleep" ::);
 bec:	88 95       	sleep
 bee:	87 2c       	mov	r8, r7
 bf0:	27 c0       	rjmp	.+78     	; 0xc40 <main+0x2e4>
						//}
					}
					break;
				case WAKEUP:
					DisableSleep();					
 bf2:	83 b7       	in	r24, 0x33	; 51
 bf4:	8e 7f       	andi	r24, 0xFE	; 254
 bf6:	83 bf       	out	0x33, r24	; 51
					
					//wakeup opamp
					WakeOpAmp();
 bf8:	41 9a       	sbi	0x08, 1	; 8
					//wakeup nrf
					//if (nrf.isSleeping() && !nrf.hasDataToSend()){
						//nrf.wakeup();
					//}
					
					if (!nrf.isSleeping() && !nrf.hasDataToSend()){
 bfa:	87 e7       	ldi	r24, 0x77	; 119
 bfc:	93 e0       	ldi	r25, 0x03	; 3
 bfe:	0e 94 1a 01 	call	0x234	; 0x234 <_ZN3NRF10isSleepingEv>
 c02:	81 11       	cpse	r24, r1
 c04:	1a c0       	rjmp	.+52     	; 0xc3a <main+0x2de>
 c06:	87 e7       	ldi	r24, 0x77	; 119
 c08:	93 e0       	ldi	r25, 0x03	; 3
 c0a:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 c0e:	81 11       	cpse	r24, r1
 c10:	16 c0       	rjmp	.+44     	; 0xc3e <main+0x2e2>
						RED_ON;
 c12:	55 98       	cbi	0x0a, 5	; 10
 c14:	8b b1       	in	r24, 0x0b	; 11
 c16:	8f 73       	andi	r24, 0x3F	; 63
 c18:	80 68       	ori	r24, 0x80	; 128
 c1a:	8b b9       	out	0x0b, r24	; 11
						state = CONNECT;
 c1c:	85 2c       	mov	r8, r5
 c1e:	10 c0       	rjmp	.+32     	; 0xc40 <main+0x2e4>
#endif
					break;				
					
				case CONNECT:	//connect
					if (nrf.connect(180,0x0100) == 0x00)
						state = CONNECTING;
 c20:	68 94       	set
 c22:	88 24       	eor	r8, r8
 c24:	81 f8       	bld	r8, 1
 c26:	0c c0       	rjmp	.+24     	; 0xc40 <main+0x2e4>
					break;				
				
				case CONNECTING:	
					if (nrf.isConnected())
						state = IDLE;
 c28:	0f 2e       	mov	r0, r31
 c2a:	f5 e0       	ldi	r31, 0x05	; 5
 c2c:	8f 2e       	mov	r8, r31
 c2e:	f0 2d       	mov	r31, r0
 c30:	07 c0       	rjmp	.+14     	; 0xc40 <main+0x2e4>
					state = IDLE;
					break;				
																
				case IDLE:		//idle
					if(!nrf.isConnected()){
						state = GO2SLEEP;
 c32:	87 2c       	mov	r8, r7
 c34:	05 c0       	rjmp	.+10     	; 0xc40 <main+0x2e4>
 c36:	87 2c       	mov	r8, r7
 c38:	03 c0       	rjmp	.+6      	; 0xc40 <main+0x2e4>
 c3a:	84 2c       	mov	r8, r4
 c3c:	01 c0       	rjmp	.+2      	; 0xc40 <main+0x2e4>
 c3e:	84 2c       	mov	r8, r4
		//display
		//sprintf(line1, " %02X%02X %02X %02X%02X ", nrf.RxCount, nrf.dataCredit, state, nrf.status, nrf.mode);
		sprintf(line2, "%02X%02X %02X %02X%02X ", nrf.RxCount, /*nrf.dataCredit,*/ state, nrf.status, nrf.mode, nrf.lastCommand);
		displayLCD();
#else
		if (nrf.mode == NRF_MODE_SETUP)
 c40:	f8 01       	movw	r30, r16
 c42:	80 81       	ld	r24, Z
 c44:	82 30       	cpi	r24, 0x02	; 2
 c46:	31 f4       	brne	.+12     	; 0xc54 <main+0x2f8>
 c48:	8f e2       	ldi	r24, 0x2F	; 47
 c4a:	95 e7       	ldi	r25, 0x75	; 117
 c4c:	01 97       	sbiw	r24, 0x01	; 1
 c4e:	f1 f7       	brne	.-4      	; 0xc4c <main+0x2f0>
 c50:	00 c0       	rjmp	.+0      	; 0xc52 <main+0x2f6>
 c52:	00 00       	nop
			_delay_ms(15);
#endif			
		nrf.process();		
 c54:	87 e7       	ldi	r24, 0x77	; 119
 c56:	93 e0       	ldi	r25, 0x03	; 3
 c58:	0e 94 61 03 	call	0x6c2	; 0x6c2 <_ZN3NRF7processEv>
	}//while 1
 c5c:	dd ce       	rjmp	.-582    	; 0xa18 <main+0xbc>

00000c5e <__vector_1>:
}//main

ISR(INT0_vect){
 c5e:	1f 92       	push	r1
 c60:	0f 92       	push	r0
 c62:	0f b6       	in	r0, 0x3f	; 63
 c64:	0f 92       	push	r0
 c66:	11 24       	eor	r1, r1
 c68:	8f 93       	push	r24
 c6a:	9f 93       	push	r25
 c6c:	8f e0       	ldi	r24, 0x0F	; 15
 c6e:	97 e2       	ldi	r25, 0x27	; 39
 c70:	01 97       	sbiw	r24, 0x01	; 1
 c72:	f1 f7       	brne	.-4      	; 0xc70 <__vector_1+0x12>
 c74:	00 c0       	rjmp	.+0      	; 0xc76 <__vector_1+0x18>
 c76:	00 00       	nop
	//to debounce switch, wait 5ms, then check for low condition again
	_delay_ms(5);
	if (!(PIND & (1<<PD2)))
 c78:	4a 99       	sbic	0x09, 2	; 9
 c7a:	03 c0       	rjmp	.+6      	; 0xc82 <__vector_1+0x24>
	buttonWasPressed = true;
 c7c:	81 e0       	ldi	r24, 0x01	; 1
 c7e:	80 93 76 03 	sts	0x0376, r24
	
}
 c82:	9f 91       	pop	r25
 c84:	8f 91       	pop	r24
 c86:	0f 90       	pop	r0
 c88:	0f be       	out	0x3f, r0	; 63
 c8a:	0f 90       	pop	r0
 c8c:	1f 90       	pop	r1
 c8e:	18 95       	reti

00000c90 <_GLOBAL__sub_I_nrf>:

//size of pipe in settings.h sets size of queue, which is how many times we read
//the data before we send
#define NUM_QUEUE ((PIPE_OXYGEN_SATURATION_O2_SET_MAX_SIZE-1)/6)

NRF nrf;
 c90:	87 e7       	ldi	r24, 0x77	; 119
 c92:	93 e0       	ldi	r25, 0x03	; 3
 c94:	0e 94 2e 01 	call	0x25c	; 0x25c <_ZN3NRFC1Ev>
 c98:	08 95       	ret

00000c9a <__tablejump2__>:
 c9a:	ee 0f       	add	r30, r30
 c9c:	ff 1f       	adc	r31, r31

00000c9e <__tablejump__>:
 c9e:	05 90       	lpm	r0, Z+
 ca0:	f4 91       	lpm	r31, Z
 ca2:	e0 2d       	mov	r30, r0
 ca4:	09 94       	ijmp

00000ca6 <_exit>:
 ca6:	f8 94       	cli

00000ca8 <__stop_program>:
 ca8:	ff cf       	rjmp	.-2      	; 0xca8 <__stop_program>
