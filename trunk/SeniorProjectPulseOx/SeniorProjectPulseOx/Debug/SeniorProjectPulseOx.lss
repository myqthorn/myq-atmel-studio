
SeniorProjectPulseOx.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000274  00800100  00000cca  00000d5e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000cca  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000077  00800374  00800374  00000fd2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000fd2  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000320  00000000  00000000  00001002  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00004162  00000000  00000000  00001322  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000b4d  00000000  00000000  00005484  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000d0b  00000000  00000000  00005fd1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000007dc  00000000  00000000  00006cdc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000137f  00000000  00000000  000074b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000024e9  00000000  00000000  00008837  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000300  00000000  00000000  0000ad20  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__ctors_end>
   4:	0c 94 3f 06 	jmp	0xc7e	; 0xc7e <__vector_1>
   8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
   c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  14:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  18:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  1c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  2c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  30:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  34:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  44:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  54:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  64:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  68:	2a 03       	fmul	r18, r18
  6a:	2e 03       	fmul	r18, r22
  6c:	32 03       	mulsu	r19, r18
  6e:	36 03       	mulsu	r19, r22
  70:	3a 03       	fmul	r19, r18
  72:	3e 03       	fmul	r19, r22
  74:	48 03       	fmul	r20, r16
  76:	4c 03       	fmul	r20, r20
  78:	50 03       	mulsu	r21, r16
  7a:	58 03       	fmul	r21, r16
  7c:	5c 03       	fmul	r21, r20
  7e:	60 03       	mulsu	r22, r16
  80:	92 03       	fmuls	r17, r18
  82:	73 03       	mulsu	r23, r19
  84:	92 03       	fmuls	r17, r18
  86:	92 03       	fmuls	r17, r18
  88:	92 03       	fmuls	r17, r18
  8a:	77 03       	mulsu	r23, r23
  8c:	92 03       	fmuls	r17, r18
  8e:	92 03       	fmuls	r17, r18
  90:	92 03       	fmuls	r17, r18
  92:	92 03       	fmuls	r17, r18
  94:	92 03       	fmuls	r17, r18
  96:	92 03       	fmuls	r17, r18
  98:	7b 03       	fmul	r23, r19
  9a:	7f 03       	fmul	r23, r23
  9c:	83 03       	fmuls	r16, r19
  9e:	87 03       	fmuls	r16, r23
  a0:	8b 03       	fmulsu	r16, r19
  a2:	8f 03       	fmulsu	r16, r23
  a4:	ea 03       	fmulsu	r22, r18
  a6:	08 04       	cpc	r0, r8
  a8:	13 04       	cpc	r1, r3
  aa:	16 04       	cpc	r1, r6
  ac:	1a 04       	cpc	r1, r10
  ae:	1f 04       	cpc	r1, r15
  b0:	22 04       	cpc	r2, r2
  b2:	2b 04       	cpc	r2, r11
  b4:	3e 04       	cpc	r3, r14
  b6:	47 04       	cpc	r4, r7
  b8:	68 04       	cpc	r6, r8
  ba:	e0 03       	fmuls	r22, r16
  bc:	64 04       	cpc	r6, r4
  be:	41 04       	cpc	r4, r1
  c0:	44 04       	cpc	r4, r4
  c2:	65 05       	cpc	r22, r5
  c4:	72 05       	cpc	r23, r2
  c6:	7e 05       	cpc	r23, r14
  c8:	85 05       	cpc	r24, r5
  ca:	98 05       	cpc	r25, r8
  cc:	a2 05       	cpc	r26, r2
  ce:	f8 05       	cpc	r31, r8
  d0:	18 06       	cpc	r1, r24

000000d2 <__ctors_start>:
  d2:	90 04       	cpc	r9, r0
  d4:	58 06       	cpc	r5, r24

000000d6 <__ctors_end>:
  d6:	11 24       	eor	r1, r1
  d8:	1f be       	out	0x3f, r1	; 63
  da:	cf ef       	ldi	r28, 0xFF	; 255
  dc:	d4 e0       	ldi	r29, 0x04	; 4
  de:	de bf       	out	0x3e, r29	; 62
  e0:	cd bf       	out	0x3d, r28	; 61

000000e2 <__do_copy_data>:
  e2:	13 e0       	ldi	r17, 0x03	; 3
  e4:	a0 e0       	ldi	r26, 0x00	; 0
  e6:	b1 e0       	ldi	r27, 0x01	; 1
  e8:	ea ec       	ldi	r30, 0xCA	; 202
  ea:	fc e0       	ldi	r31, 0x0C	; 12
  ec:	02 c0       	rjmp	.+4      	; 0xf2 <__do_copy_data+0x10>
  ee:	05 90       	lpm	r0, Z+
  f0:	0d 92       	st	X+, r0
  f2:	a4 37       	cpi	r26, 0x74	; 116
  f4:	b1 07       	cpc	r27, r17
  f6:	d9 f7       	brne	.-10     	; 0xee <__do_copy_data+0xc>

000000f8 <__do_clear_bss>:
  f8:	23 e0       	ldi	r18, 0x03	; 3
  fa:	a4 e7       	ldi	r26, 0x74	; 116
  fc:	b3 e0       	ldi	r27, 0x03	; 3
  fe:	01 c0       	rjmp	.+2      	; 0x102 <.do_clear_bss_start>

00000100 <.do_clear_bss_loop>:
 100:	1d 92       	st	X+, r1

00000102 <.do_clear_bss_start>:
 102:	ab 3e       	cpi	r26, 0xEB	; 235
 104:	b2 07       	cpc	r27, r18
 106:	e1 f7       	brne	.-8      	; 0x100 <.do_clear_bss_loop>

00000108 <__do_global_ctors>:
 108:	10 e0       	ldi	r17, 0x00	; 0
 10a:	c6 ed       	ldi	r28, 0xD6	; 214
 10c:	d0 e0       	ldi	r29, 0x00	; 0
 10e:	04 c0       	rjmp	.+8      	; 0x118 <__do_global_ctors+0x10>
 110:	22 97       	sbiw	r28, 0x02	; 2
 112:	fe 01       	movw	r30, r28
 114:	0e 94 5f 06 	call	0xcbe	; 0xcbe <__tablejump__>
 118:	c2 3d       	cpi	r28, 0xD2	; 210
 11a:	d1 07       	cpc	r29, r17
 11c:	c9 f7       	brne	.-14     	; 0x110 <__do_global_ctors+0x8>
 11e:	0e 94 df 04 	call	0x9be	; 0x9be <main>
 122:	0c 94 63 06 	jmp	0xcc6	; 0xcc6 <_exit>

00000126 <__bad_interrupt>:
 126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <_ZN6ANALOG12reinitializeEv>:
	
}

void ANALOG::reinitialize(){
	//Power reduction ADC bit must be zero to enable ADC
	PRR &= ~(1<<PRADC);
 12a:	e4 e6       	ldi	r30, 0x64	; 100
 12c:	f0 e0       	ldi	r31, 0x00	; 0
 12e:	20 81       	ld	r18, Z
 130:	2e 7f       	andi	r18, 0xFE	; 254
 132:	20 83       	st	Z, r18
	
	
	//ADC clock needs to be between 50kHz and 200kHz
	//8MHz/64 = 125kHz
	ADCSRA = (1<<ADEN | prescalar<<ADPS0);
 134:	dc 01       	movw	r26, r24
 136:	11 96       	adiw	r26, 0x01	; 1
 138:	2c 91       	ld	r18, X
 13a:	11 97       	sbiw	r26, 0x01	; 1
 13c:	20 68       	ori	r18, 0x80	; 128
 13e:	20 93 7a 00 	sts	0x007A, r18
	
	//Disable the digital input for the ADC channel we will be using
	DIDR0 |= (1<<channel);
 142:	ee e7       	ldi	r30, 0x7E	; 126
 144:	f0 e0       	ldi	r31, 0x00	; 0
 146:	40 81       	ld	r20, Z
 148:	21 e0       	ldi	r18, 0x01	; 1
 14a:	30 e0       	ldi	r19, 0x00	; 0
 14c:	b9 01       	movw	r22, r18
 14e:	0c 90       	ld	r0, X
 150:	02 c0       	rjmp	.+4      	; 0x156 <_ZN6ANALOG12reinitializeEv+0x2c>
 152:	66 0f       	add	r22, r22
 154:	77 1f       	adc	r23, r23
 156:	0a 94       	dec	r0
 158:	e2 f7       	brpl	.-8      	; 0x152 <_ZN6ANALOG12reinitializeEv+0x28>
 15a:	cb 01       	movw	r24, r22
 15c:	84 2b       	or	r24, r20
 15e:	80 83       	st	Z, r24
 160:	08 95       	ret

00000162 <_ZN6ANALOGC1Ehh>:
	reinitialize();
}

//@brief initialize AD converter on Atmega168 for
ANALOG::ANALOG(uint8_t ch, uint8_t pscalar){
	channel = ch;
 162:	fc 01       	movw	r30, r24
 164:	60 83       	st	Z, r22
	prescalar = pscalar;
 166:	41 83       	std	Z+1, r20	; 0x01
	reinitialize();
 168:	0e 94 95 00 	call	0x12a	; 0x12a <_ZN6ANALOG12reinitializeEv>
 16c:	08 95       	ret

0000016e <_ZN6ANALOG5startEv>:
	return (ADC);
}

void ANALOG::start(){
	//set ADC channel
	ADMUX = (1<<REFS0) | channel;
 16e:	fc 01       	movw	r30, r24
 170:	80 81       	ld	r24, Z
 172:	80 64       	ori	r24, 0x40	; 64
 174:	80 93 7c 00 	sts	0x007C, r24
	
	//start conversion
	ADCSRA |= (1<<ADSC);
 178:	ea e7       	ldi	r30, 0x7A	; 122
 17a:	f0 e0       	ldi	r31, 0x00	; 0
 17c:	80 81       	ld	r24, Z
 17e:	80 64       	ori	r24, 0x40	; 64
 180:	80 83       	st	Z, r24
 182:	08 95       	ret

00000184 <_ZN6ANALOG18isInterruptFlagSetEv>:
uint8_t ANALOG::isReading(){
	return (ADCSRA & (1<<ADSC));	
}

uint8_t	ANALOG::isInterruptFlagSet(){
	return(ADCSRA & (1<<ADIF));
 184:	80 91 7a 00 	lds	r24, 0x007A
}
 188:	80 71       	andi	r24, 0x10	; 16
 18a:	08 95       	ret

0000018c <_ZN6ANALOG9clearFlagEv>:

void ANALOG::clearFlag(){
	//clear interrupt by setting ADIF to 1
	ADCSRA |= (1<<ADIF);
 18c:	ea e7       	ldi	r30, 0x7A	; 122
 18e:	f0 e0       	ldi	r31, 0x00	; 0
 190:	80 81       	ld	r24, Z
 192:	80 61       	ori	r24, 0x10	; 16
 194:	80 83       	st	Z, r24
 196:	08 95       	ret

00000198 <_ZN3SPI4initEh>:
		init(SPCRvalue);
	}
	void SPI::init(uint8_t SPCRvalue)
	// Initialize pins for spi communication
	{
		DDR_SPI &= ~((1<<DD_MOSI)|(1<<DD_MISO)|(1<<DD_SS)|(1<<DD_SCK));
 198:	84 b1       	in	r24, 0x04	; 4
 19a:	83 7c       	andi	r24, 0xC3	; 195
 19c:	84 b9       	out	0x04, r24	; 4
		// Define the following pins as output
		DDR_SPI |= ((1<<DD_MOSI)|(1<<DD_SS)|(1<<DD_SCK));
 19e:	84 b1       	in	r24, 0x04	; 4
 1a0:	8c 62       	ori	r24, 0x2C	; 44
 1a2:	84 b9       	out	0x04, r24	; 4

		if (SPCRvalue == 0x00){
 1a4:	61 11       	cpse	r22, r1
 1a6:	03 c0       	rjmp	.+6      	; 0x1ae <_ZN3SPI4initEh+0x16>
			(0<<SPIE)|              // SPI Interrupt Enable
			(0<<DORD)|              // Data Order (0:MSB first / 1:LSB first)
			(1<<MSTR)|              // Master/Slave select
			(0<<SPR1)|(1<<SPR0)|    // SPI Clock Rate
			(0<<CPOL)|              // Clock Polarity (0:SCK low / 1:SCK hi when idle)
			(0<<CPHA));             // Clock Phase (0:leading / 1:trailing edge sampling)
 1a8:	81 e5       	ldi	r24, 0x51	; 81
 1aa:	8c bd       	out	0x2c, r24	; 44
 1ac:	08 95       	ret
		}
		else SPCR = SPCRvalue;
 1ae:	6c bd       	out	0x2c, r22	; 44
 1b0:	08 95       	ret

000001b2 <_ZN3SPIC1Eh>:
	
	SPI::SPI(){
		init(0x00);
	}
	SPI::SPI(uint8_t SPCRvalue){
		init(SPCRvalue);
 1b2:	0e 94 cc 00 	call	0x198	; 0x198 <_ZN3SPI4initEh>
 1b6:	08 95       	ret

000001b8 <_ZN3SPI8transferEPhS0_h>:
	
	void SPI::transfer (uint8_t * dataout, uint8_t * datain, uint8_t length)
	// Shift full array through target device
	{
		uint8_t i;
		for (i = 0; i < length; i++) {
 1b8:	22 23       	and	r18, r18
 1ba:	81 f0       	breq	.+32     	; 0x1dc <_ZN3SPI8transferEPhS0_h+0x24>
 1bc:	96 2f       	mov	r25, r22
 1be:	a4 2f       	mov	r26, r20
 1c0:	b5 2f       	mov	r27, r21
 1c2:	e6 2f       	mov	r30, r22
 1c4:	f7 2f       	mov	r31, r23
			SPDR = dataout[i];
 1c6:	81 91       	ld	r24, Z+
 1c8:	8e bd       	out	0x2e, r24	; 46
			while((SPSR & (1<<SPIF))==0);
 1ca:	0d b4       	in	r0, 0x2d	; 45
 1cc:	07 fe       	sbrs	r0, 7
 1ce:	fd cf       	rjmp	.-6      	; 0x1ca <_ZN3SPI8transferEPhS0_h+0x12>
			datain[i] = SPDR;
 1d0:	8e b5       	in	r24, 0x2e	; 46
 1d2:	8d 93       	st	X+, r24
 1d4:	8e 2f       	mov	r24, r30
 1d6:	89 1b       	sub	r24, r25
	
	void SPI::transfer (uint8_t * dataout, uint8_t * datain, uint8_t length)
	// Shift full array through target device
	{
		uint8_t i;
		for (i = 0; i < length; i++) {
 1d8:	82 17       	cp	r24, r18
 1da:	a8 f3       	brcs	.-22     	; 0x1c6 <_ZN3SPI8transferEPhS0_h+0xe>
 1dc:	08 95       	ret

000001de <_ZN3SPI13transfer1byteEh>:
	}
	
	uint8_t SPI::transfer1byte (uint8_t dataout)
	// Clocks only one byte to target device and returns the received one
	{
		SPDR = dataout;
 1de:	6e bd       	out	0x2e, r22	; 46
		while((SPSR & (1<<SPIF))==0);
 1e0:	0d b4       	in	r0, 0x2d	; 45
 1e2:	07 fe       	sbrs	r0, 7
 1e4:	fd cf       	rjmp	.-6      	; 0x1e0 <_ZN3SPI13transfer1byteEh+0x2>
		return SPDR;
 1e6:	8e b5       	in	r24, 0x2e	; 46
	}
 1e8:	08 95       	ret

000001ea <_ZN3NRF14isInitializingEv>:
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 1ea:	fc 01       	movw	r30, r24
 1ec:	ef 58       	subi	r30, 0x8F	; 143
 1ee:	ff 4f       	sbci	r31, 0xFF	; 255
 1f0:	81 e0       	ldi	r24, 0x01	; 1
 1f2:	90 81       	ld	r25, Z
 1f4:	92 30       	cpi	r25, 0x02	; 2
 1f6:	09 f0       	breq	.+2      	; 0x1fa <_ZN3NRF14isInitializingEv+0x10>
 1f8:	80 e0       	ldi	r24, 0x00	; 0
}
 1fa:	08 95       	ret

000001fc <_ZN3NRF13hasDataToSendEv>:
uint8_t NRF::hasDataToSend(void){
	return ((status & (1<<NRF_TX_READY))?TRUE:FALSE);
 1fc:	fc 01       	movw	r30, r24
 1fe:	82 8d       	ldd	r24, Z+26	; 0x1a
}
 200:	86 fb       	bst	r24, 6
 202:	88 27       	eor	r24, r24
 204:	80 f9       	bld	r24, 0
 206:	08 95       	ret

00000208 <_ZN3NRF18waitingForResponseEv>:
uint8_t NRF::isReadyToReceiveData(){
	return ((status & (1<<NRF_RX_READY))?TRUE:FALSE);
}
uint8_t NRF::waitingForResponse(void){
	return ((status & (1<<NRF_WAIT_FOR_RESPONSE))?TRUE:FALSE);
 208:	fc 01       	movw	r30, r24
 20a:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
 20c:	82 95       	swap	r24
 20e:	81 70       	andi	r24, 0x01	; 1
 210:	08 95       	ret

00000212 <_ZN3NRF11isConnectedEv>:
uint8_t NRF::isConnected(void){
	return ((status & (1<<NRF_CONNECTED))?TRUE:FALSE);
 212:	fc 01       	movw	r30, r24
 214:	82 8d       	ldd	r24, Z+26	; 0x1a
}	
 216:	83 fb       	bst	r24, 3
 218:	88 27       	eor	r24, r24
 21a:	80 f9       	bld	r24, 0
 21c:	08 95       	ret

0000021e <_ZN3NRF16hasDataToProcessEv>:
uint8_t NRF::isBonded(void){
	return ((status & (1<<NRF_BONDED))?TRUE:FALSE);	
}
uint8_t NRF::hasDataToProcess(void){
	return ((status & (1<<NRF_DATA_TO_PROCESS))?TRUE:FALSE);
 21e:	fc 01       	movw	r30, r24
 220:	82 8d       	ldd	r24, Z+26	; 0x1a
}
 222:	85 fb       	bst	r24, 5
 224:	88 27       	eor	r24, r24
 226:	80 f9       	bld	r24, 0
 228:	08 95       	ret

0000022a <_ZN3NRF20dataHasBeenProcessedEv>:
void	NRF::dataHasBeenProcessed(void){
	status &= ~(1<<NRF_DATA_TO_PROCESS);
 22a:	fc 01       	movw	r30, r24
 22c:	22 8d       	ldd	r18, Z+26	; 0x1a
 22e:	2f 7d       	andi	r18, 0xDF	; 223
 230:	22 8f       	std	Z+26, r18	; 0x1a
 232:	08 95       	ret

00000234 <_ZN3NRF15isSystemCommandEh>:
uint8_t	NRF::isSystemCommand(uint8_t command){
	return ((	command == NRF_CMD_SET_LOCAL_DATA	||
		command == NRF_CMD_SEND_DATA		||
		command == NRF_CMD_SEND_DATA_ACK	||
		command == NRF_CMD_REQUEST_DATA		||
		command == NRF_CMD_SEND_DATA_NACK	 )	? FALSE: TRUE);
 234:	6d 30       	cpi	r22, 0x0D	; 13
 236:	31 f0       	breq	.+12     	; 0x244 <_ZN3NRF15isSystemCommandEh+0x10>
	status &= ~(1<<NRF_DATA_TO_PROCESS);
}
#pragma endregion Status Functions

uint8_t	NRF::isSystemCommand(uint8_t command){
	return ((	command == NRF_CMD_SET_LOCAL_DATA	||
 238:	65 51       	subi	r22, 0x15	; 21
 23a:	81 e0       	ldi	r24, 0x01	; 1
 23c:	64 30       	cpi	r22, 0x04	; 4
 23e:	18 f4       	brcc	.+6      	; 0x246 <_ZN3NRF15isSystemCommandEh+0x12>
 240:	80 e0       	ldi	r24, 0x00	; 0
 242:	08 95       	ret
		command == NRF_CMD_SEND_DATA		||
		command == NRF_CMD_SEND_DATA_ACK	||
		command == NRF_CMD_REQUEST_DATA		||
		command == NRF_CMD_SEND_DATA_NACK	 )	? FALSE: TRUE);
 244:	80 e0       	ldi	r24, 0x00	; 0
}
 246:	08 95       	ret

00000248 <_ZN3NRF4initEv>:
}


void NRF::init(){
	//ACT and RDYN set as inputs	
	ACT_DDR &= ~(1<<ACT_PIN);	
 248:	20 98       	cbi	0x04, 0	; 4
	RDYN_DDR &= ~(1<<RDYN_PIN);
 24a:	22 98       	cbi	0x04, 2	; 4
	
	//REQN set as output
	REQN_DDR |= (1<<REQN_PIN);
 24c:	21 9a       	sbi	0x04, 1	; 4
	//////DON'T KNOW WHY THIS IS CAUSING A PROBLEM********************************************************
	//set pullup on RDYN
	//RDYN_PORT |= (1<<RDYN_PIN);
	
	//REQN is active low, so initialize it HIGH
	SetREQN();
 24e:	29 9a       	sbi	0x05, 1	; 5
 250:	08 95       	ret

00000252 <_ZN3NRFC1Ev>:

//uint8_t initCodes[12][32];
static uint8_t initCount = 0;

//NRF::NRF(hal_aci_data_t *message){
NRF::NRF(){
 252:	cf 93       	push	r28
 254:	df 93       	push	r29
 256:	ec 01       	movw	r28, r24
	//msg = message;
	
	init();
 258:	0e 94 24 01 	call	0x248	; 0x248 <_ZN3NRF4initEv>
	RxCount = 0x00;
 25c:	1d 8a       	std	Y+21, r1	; 0x15
	//mode = 0x00;
	//set to INIT_MODE and RX_READY
	//we are waiting for a NRF_EVT_DEVICE_STARTED in NRF_MODE_SETUP
	//status |= (1<<NRF_RX_READY | 1<<NRF_INIT_MODE | 1<<NRF_WAIT_FOR_RESPONSE);
	status |= (1<<NRF_RX_READY | 1<<NRF_WAIT_FOR_RESPONSE);
 25e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 260:	80 69       	ori	r24, 0x90	; 144
 262:	8a 8f       	std	Y+26, r24	; 0x1a
}
 264:	df 91       	pop	r29
 266:	cf 91       	pop	r28
 268:	08 95       	ret

0000026a <_ZN3NRF11clearTxDataEv>:
		}
		
	}//else if(RDYN == 0)	
	
}//transferACI()
void NRF::clearTxData(){
 26a:	fc 01       	movw	r30, r24
 26c:	fb 96       	adiw	r30, 0x3b	; 59
	for(int i = 0; i<32; i++) 
 26e:	20 e0       	ldi	r18, 0x00	; 0
 270:	30 e0       	ldi	r19, 0x00	; 0
		TxData[i] = 0x00;		
 272:	11 92       	st	Z+, r1
		
	}//else if(RDYN == 0)	
	
}//transferACI()
void NRF::clearTxData(){
	for(int i = 0; i<32; i++) 
 274:	2f 5f       	subi	r18, 0xFF	; 255
 276:	3f 4f       	sbci	r19, 0xFF	; 255
 278:	20 32       	cpi	r18, 0x20	; 32
 27a:	31 05       	cpc	r19, r1
 27c:	d1 f7       	brne	.-12     	; 0x272 <_ZN3NRF11clearTxDataEv+0x8>
		TxData[i] = 0x00;		
}
 27e:	08 95       	ret

00000280 <_ZN3NRF13PrepareTxDataEhPhh>:
///@brief Send data from uC to nRF8001
///@param command
///@param data
///@param length Length of data
///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::PrepareTxData(uint8_t command, uint8_t *data, uint8_t length){
 280:	ef 92       	push	r14
 282:	ff 92       	push	r15
 284:	0f 93       	push	r16
 286:	1f 93       	push	r17
 288:	cf 93       	push	r28
 28a:	df 93       	push	r29
 28c:	ec 01       	movw	r28, r24
 28e:	16 2f       	mov	r17, r22
 290:	e4 2e       	mov	r14, r20
 292:	f5 2e       	mov	r15, r21
 294:	02 2f       	mov	r16, r18
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 296:	fc 01       	movw	r30, r24
 298:	ef 58       	subi	r30, 0x8F	; 143
 29a:	ff 4f       	sbci	r31, 0xFF	; 255
///@param length Length of data
///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::PrepareTxData(uint8_t command, uint8_t *data, uint8_t length){
	//TODO: write this function
	int i;
	if (isInitializing())
 29c:	80 81       	ld	r24, Z
 29e:	82 30       	cpi	r24, 0x02	; 2
 2a0:	e1 f0       	breq	.+56     	; 0x2da <_ZN3NRF13PrepareTxDataEhPhh+0x5a>
		return 0x01;
	if (hasDataToSend())
 2a2:	ce 01       	movw	r24, r28
 2a4:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 2a8:	81 11       	cpse	r24, r1
 2aa:	19 c0       	rjmp	.+50     	; 0x2de <_ZN3NRF13PrepareTxDataEhPhh+0x5e>
		return 0x02;
	if (waitingForResponse() && isSystemCommand(command))
 2ac:	ce 01       	movw	r24, r28
 2ae:	0e 94 04 01 	call	0x208	; 0x208 <_ZN3NRF18waitingForResponseEv>
 2b2:	88 23       	and	r24, r24
 2b4:	c1 f0       	breq	.+48     	; 0x2e6 <_ZN3NRF13PrepareTxDataEhPhh+0x66>
 2b6:	61 2f       	mov	r22, r17
 2b8:	ce 01       	movw	r24, r28
 2ba:	0e 94 1a 01 	call	0x234	; 0x234 <_ZN3NRF15isSystemCommandEh>
 2be:	81 11       	cpse	r24, r1
 2c0:	10 c0       	rjmp	.+32     	; 0x2e2 <_ZN3NRF13PrepareTxDataEhPhh+0x62>
 2c2:	11 c0       	rjmp	.+34     	; 0x2e6 <_ZN3NRF13PrepareTxDataEhPhh+0x66>
	
	//populate TxData with length and data
	TxData[0] = length + 1;
	TxData[1] = command;
	for(i = 0; i < length; i++)
		TxData[i+2] = data[i];	
 2c4:	41 91       	ld	r20, Z+
 2c6:	4d 93       	st	X+, r20
	clearTxData();
	
	//populate TxData with length and data
	TxData[0] = length + 1;
	TxData[1] = command;
	for(i = 0; i < length; i++)
 2c8:	01 96       	adiw	r24, 0x01	; 1
 2ca:	82 17       	cp	r24, r18
 2cc:	93 07       	cpc	r25, r19
 2ce:	d4 f3       	brlt	.-12     	; 0x2c4 <_ZN3NRF13PrepareTxDataEhPhh+0x44>
		TxData[i+2] = data[i];	
		
	//data to send flag
	status |= (1<<NRF_TX_READY);
 2d0:	8a 8d       	ldd	r24, Y+26	; 0x1a
 2d2:	80 64       	ori	r24, 0x40	; 64
 2d4:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;	//success
 2d6:	80 e0       	ldi	r24, 0x00	; 0
 2d8:	1d c0       	rjmp	.+58     	; 0x314 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::PrepareTxData(uint8_t command, uint8_t *data, uint8_t length){
	//TODO: write this function
	int i;
	if (isInitializing())
		return 0x01;
 2da:	81 e0       	ldi	r24, 0x01	; 1
 2dc:	1b c0       	rjmp	.+54     	; 0x314 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
	if (hasDataToSend())
		return 0x02;
 2de:	82 e0       	ldi	r24, 0x02	; 2
 2e0:	19 c0       	rjmp	.+50     	; 0x314 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
	if (waitingForResponse() && isSystemCommand(command))
		return 0x03;
 2e2:	83 e0       	ldi	r24, 0x03	; 3
 2e4:	17 c0       	rjmp	.+46     	; 0x314 <_ZN3NRF13PrepareTxDataEhPhh+0x94>
	
	lastCommand = command;
 2e6:	fe 01       	movw	r30, r28
 2e8:	ed 58       	subi	r30, 0x8D	; 141
 2ea:	ff 4f       	sbci	r31, 0xFF	; 255
 2ec:	10 83       	st	Z, r17
	
	clearTxData();
 2ee:	ce 01       	movw	r24, r28
 2f0:	0e 94 35 01 	call	0x26a	; 0x26a <_ZN3NRF11clearTxDataEv>
	
	//populate TxData with length and data
	TxData[0] = length + 1;
 2f4:	81 e0       	ldi	r24, 0x01	; 1
 2f6:	80 0f       	add	r24, r16
 2f8:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = command;
 2fa:	1c af       	std	Y+60, r17	; 0x3c
	for(i = 0; i < length; i++)
 2fc:	20 2f       	mov	r18, r16
 2fe:	30 e0       	ldi	r19, 0x00	; 0
 300:	12 16       	cp	r1, r18
 302:	13 06       	cpc	r1, r19
 304:	2c f7       	brge	.-54     	; 0x2d0 <_ZN3NRF13PrepareTxDataEhPhh+0x50>
 306:	ee 2d       	mov	r30, r14
 308:	ff 2d       	mov	r31, r15
 30a:	de 01       	movw	r26, r28
 30c:	dd 96       	adiw	r26, 0x3d	; 61
 30e:	80 e0       	ldi	r24, 0x00	; 0
 310:	90 e0       	ldi	r25, 0x00	; 0
 312:	d8 cf       	rjmp	.-80     	; 0x2c4 <_ZN3NRF13PrepareTxDataEhPhh+0x44>
		TxData[i+2] = data[i];	
		
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData
 314:	df 91       	pop	r29
 316:	cf 91       	pop	r28
 318:	1f 91       	pop	r17
 31a:	0f 91       	pop	r16
 31c:	ff 90       	pop	r15
 31e:	ef 90       	pop	r14
 320:	08 95       	ret

00000322 <_ZN3NRF10disconnectEh>:
	localData[2] = (advInterval&0x00FF);	//LSB
	localData[3] = (advInterval&0xFF00)>>8; //MSB
	return (PrepareTxData(NRF_CMD_BOND, localData, 4));
}//

uint8_t NRF::disconnect(uint8_t reason){
 322:	cf 93       	push	r28
 324:	df 93       	push	r29
 326:	1f 92       	push	r1
 328:	cd b7       	in	r28, 0x3d	; 61
 32a:	de b7       	in	r29, 0x3e	; 62
 32c:	69 83       	std	Y+1, r22	; 0x01
	return (PrepareTxData(NRF_CMD_DISCONNECT, &reason, 1));
 32e:	21 e0       	ldi	r18, 0x01	; 1
 330:	ae 01       	movw	r20, r28
 332:	4f 5f       	subi	r20, 0xFF	; 255
 334:	5f 4f       	sbci	r21, 0xFF	; 255
 336:	61 e1       	ldi	r22, 0x11	; 17
 338:	0e 94 40 01 	call	0x280	; 0x280 <_ZN3NRF13PrepareTxDataEhPhh>
}//
 33c:	0f 90       	pop	r0
 33e:	df 91       	pop	r29
 340:	cf 91       	pop	r28
 342:	08 95       	ret

00000344 <_ZN3NRF11requestDataEh>:
	if (retVal == 0x00)
		dataCredit-=1;
	return (retVal);
}//

uint8_t NRF::requestData(uint8_t servicePipeNumber){
 344:	0f 93       	push	r16
 346:	1f 93       	push	r17
 348:	cf 93       	push	r28
 34a:	df 93       	push	r29
 34c:	1f 92       	push	r1
 34e:	cd b7       	in	r28, 0x3d	; 61
 350:	de b7       	in	r29, 0x3e	; 62
 352:	8c 01       	movw	r16, r24
 354:	69 83       	std	Y+1, r22	; 0x01
	uint8_t retVal = PrepareTxData(NRF_CMD_REQUEST_DATA, &servicePipeNumber, 1);
 356:	21 e0       	ldi	r18, 0x01	; 1
 358:	ae 01       	movw	r20, r28
 35a:	4f 5f       	subi	r20, 0xFF	; 255
 35c:	5f 4f       	sbci	r21, 0xFF	; 255
 35e:	67 e1       	ldi	r22, 0x17	; 23
 360:	0e 94 40 01 	call	0x280	; 0x280 <_ZN3NRF13PrepareTxDataEhPhh>
	if (retVal == 0x00)
 364:	81 11       	cpse	r24, r1
 366:	06 c0       	rjmp	.+12     	; 0x374 <_ZN3NRF11requestDataEh+0x30>
		dataCredit-=1;
 368:	f8 01       	movw	r30, r16
 36a:	ee 58       	subi	r30, 0x8E	; 142
 36c:	ff 4f       	sbci	r31, 0xFF	; 255
 36e:	90 81       	ld	r25, Z
 370:	91 50       	subi	r25, 0x01	; 1
 372:	90 83       	st	Z, r25
	return (retVal);
}//
 374:	0f 90       	pop	r0
 376:	df 91       	pop	r29
 378:	cf 91       	pop	r28
 37a:	1f 91       	pop	r17
 37c:	0f 91       	pop	r16
 37e:	08 95       	ret

00000380 <_ZN3NRF13PrepareTxDataEhhPhh>:
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command, uint8_t content, uint8_t *data, uint8_t length){
 380:	df 92       	push	r13
 382:	ef 92       	push	r14
 384:	ff 92       	push	r15
 386:	0f 93       	push	r16
 388:	1f 93       	push	r17
 38a:	cf 93       	push	r28
 38c:	df 93       	push	r29
 38e:	ec 01       	movw	r28, r24
 390:	16 2f       	mov	r17, r22
 392:	f4 2e       	mov	r15, r20
 394:	d2 2e       	mov	r13, r18
 396:	e3 2e       	mov	r14, r19
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 398:	fc 01       	movw	r30, r24
 39a:	ef 58       	subi	r30, 0x8F	; 143
 39c:	ff 4f       	sbci	r31, 0xFF	; 255
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command, uint8_t content, uint8_t *data, uint8_t length){
	
	int i;
	if (isInitializing())
 39e:	80 81       	ld	r24, Z
 3a0:	82 30       	cpi	r24, 0x02	; 2
 3a2:	e1 f0       	breq	.+56     	; 0x3dc <_ZN3NRF13PrepareTxDataEhhPhh+0x5c>
		return 0x01;
	if (hasDataToSend())
 3a4:	ce 01       	movw	r24, r28
 3a6:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 3aa:	81 11       	cpse	r24, r1
 3ac:	19 c0       	rjmp	.+50     	; 0x3e0 <_ZN3NRF13PrepareTxDataEhhPhh+0x60>
		return 0x02;
	if (waitingForResponse() && isSystemCommand(command))
 3ae:	ce 01       	movw	r24, r28
 3b0:	0e 94 04 01 	call	0x208	; 0x208 <_ZN3NRF18waitingForResponseEv>
 3b4:	88 23       	and	r24, r24
 3b6:	c1 f0       	breq	.+48     	; 0x3e8 <_ZN3NRF13PrepareTxDataEhhPhh+0x68>
 3b8:	61 2f       	mov	r22, r17
 3ba:	ce 01       	movw	r24, r28
 3bc:	0e 94 1a 01 	call	0x234	; 0x234 <_ZN3NRF15isSystemCommandEh>
 3c0:	81 11       	cpse	r24, r1
 3c2:	10 c0       	rjmp	.+32     	; 0x3e4 <_ZN3NRF13PrepareTxDataEhhPhh+0x64>
 3c4:	11 c0       	rjmp	.+34     	; 0x3e8 <_ZN3NRF13PrepareTxDataEhhPhh+0x68>
	//populate TxData with length and data
	TxData[0] = length + 2;
	TxData[1] = command;
	TxData[2] = content;
	for(i = 0; i < length; i++)
		TxData[i+3] = data[i];
 3c6:	21 91       	ld	r18, Z+
 3c8:	2d 93       	st	X+, r18
	clearTxData();
	//populate TxData with length and data
	TxData[0] = length + 2;
	TxData[1] = command;
	TxData[2] = content;
	for(i = 0; i < length; i++)
 3ca:	01 96       	adiw	r24, 0x01	; 1
 3cc:	80 17       	cp	r24, r16
 3ce:	91 07       	cpc	r25, r17
 3d0:	d4 f3       	brlt	.-12     	; 0x3c6 <_ZN3NRF13PrepareTxDataEhhPhh+0x46>
		TxData[i+3] = data[i];
	
	//data to send flag
	status |= (1<<NRF_TX_READY);
 3d2:	8a 8d       	ldd	r24, Y+26	; 0x1a
 3d4:	80 64       	ori	r24, 0x40	; 64
 3d6:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;	//success
 3d8:	80 e0       	ldi	r24, 0x00	; 0
 3da:	1d c0       	rjmp	.+58     	; 0x416 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>

uint8_t NRF::PrepareTxData(uint8_t command, uint8_t content, uint8_t *data, uint8_t length){
	
	int i;
	if (isInitializing())
		return 0x01;
 3dc:	81 e0       	ldi	r24, 0x01	; 1
 3de:	1b c0       	rjmp	.+54     	; 0x416 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>
	if (hasDataToSend())
		return 0x02;
 3e0:	82 e0       	ldi	r24, 0x02	; 2
 3e2:	19 c0       	rjmp	.+50     	; 0x416 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>
	if (waitingForResponse() && isSystemCommand(command))
		return 0x03;
 3e4:	83 e0       	ldi	r24, 0x03	; 3
 3e6:	17 c0       	rjmp	.+46     	; 0x416 <_ZN3NRF13PrepareTxDataEhhPhh+0x96>
	
	lastCommand = command;
 3e8:	fe 01       	movw	r30, r28
 3ea:	ed 58       	subi	r30, 0x8D	; 141
 3ec:	ff 4f       	sbci	r31, 0xFF	; 255
 3ee:	10 83       	st	Z, r17
	
	clearTxData();
 3f0:	ce 01       	movw	r24, r28
 3f2:	0e 94 35 01 	call	0x26a	; 0x26a <_ZN3NRF11clearTxDataEv>
	//populate TxData with length and data
	TxData[0] = length + 2;
 3f6:	82 e0       	ldi	r24, 0x02	; 2
 3f8:	80 0f       	add	r24, r16
 3fa:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = command;
 3fc:	1c af       	std	Y+60, r17	; 0x3c
	TxData[2] = content;
 3fe:	fd ae       	std	Y+61, r15	; 0x3d
	for(i = 0; i < length; i++)
 400:	10 e0       	ldi	r17, 0x00	; 0
 402:	10 16       	cp	r1, r16
 404:	11 06       	cpc	r1, r17
 406:	2c f7       	brge	.-54     	; 0x3d2 <_ZN3NRF13PrepareTxDataEhhPhh+0x52>
 408:	ed 2d       	mov	r30, r13
 40a:	fe 2d       	mov	r31, r14
 40c:	de 01       	movw	r26, r28
 40e:	de 96       	adiw	r26, 0x3e	; 62
 410:	80 e0       	ldi	r24, 0x00	; 0
 412:	90 e0       	ldi	r25, 0x00	; 0
 414:	d8 cf       	rjmp	.-80     	; 0x3c6 <_ZN3NRF13PrepareTxDataEhhPhh+0x46>
		TxData[i+3] = data[i];
	
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData
 416:	df 91       	pop	r29
 418:	cf 91       	pop	r28
 41a:	1f 91       	pop	r17
 41c:	0f 91       	pop	r16
 41e:	ff 90       	pop	r15
 420:	ef 90       	pop	r14
 422:	df 90       	pop	r13
 424:	08 95       	ret

00000426 <_ZN3NRF12setLocalDataEhPhh>:
return (PrepareTxData(NRF_CMD_CLOSE_REMOTE_PIPE, &servicePipeNumber, 1));
}//
#pragma endregion System Command Functions

#pragma region Data Command Functions
uint8_t NRF::setLocalData(uint8_t servicePipeNumber, uint8_t *data, uint8_t length){	
 426:	0f 93       	push	r16
	return (PrepareTxData(NRF_CMD_SET_LOCAL_DATA, servicePipeNumber, data, length));
 428:	02 2f       	mov	r16, r18
 42a:	9a 01       	movw	r18, r20
 42c:	46 2f       	mov	r20, r22
 42e:	6d e0       	ldi	r22, 0x0D	; 13
 430:	0e 94 c0 01 	call	0x380	; 0x380 <_ZN3NRF13PrepareTxDataEhhPhh>
}//
 434:	0f 91       	pop	r16
 436:	08 95       	ret

00000438 <_ZN3NRF13PrepareTxDataEh>:
	//data to send flag
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command){
 438:	1f 93       	push	r17
 43a:	cf 93       	push	r28
 43c:	df 93       	push	r29
 43e:	ec 01       	movw	r28, r24
 440:	16 2f       	mov	r17, r22
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 442:	fc 01       	movw	r30, r24
 444:	ef 58       	subi	r30, 0x8F	; 143
 446:	ff 4f       	sbci	r31, 0xFF	; 255
	status |= (1<<NRF_TX_READY);
	return 0x00;	//success
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command){
	if (isInitializing())
 448:	80 81       	ld	r24, Z
 44a:	82 30       	cpi	r24, 0x02	; 2
 44c:	91 f0       	breq	.+36     	; 0x472 <_ZN3NRF13PrepareTxDataEh+0x3a>
		return 0x01;
	if (hasDataToSend())
 44e:	ce 01       	movw	r24, r28
 450:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 454:	81 11       	cpse	r24, r1
 456:	0f c0       	rjmp	.+30     	; 0x476 <_ZN3NRF13PrepareTxDataEh+0x3e>
		return 0x02;
	if (waitingForResponse() && isSystemCommand(command))
 458:	ce 01       	movw	r24, r28
 45a:	0e 94 04 01 	call	0x208	; 0x208 <_ZN3NRF18waitingForResponseEv>
 45e:	88 23       	and	r24, r24
 460:	61 f0       	breq	.+24     	; 0x47a <_ZN3NRF13PrepareTxDataEh+0x42>
 462:	61 2f       	mov	r22, r17
 464:	ce 01       	movw	r24, r28
 466:	0e 94 1a 01 	call	0x234	; 0x234 <_ZN3NRF15isSystemCommandEh>
 46a:	88 23       	and	r24, r24
 46c:	31 f0       	breq	.+12     	; 0x47a <_ZN3NRF13PrepareTxDataEh+0x42>
		return 0x03;
 46e:	83 e0       	ldi	r24, 0x03	; 3
 470:	12 c0       	rjmp	.+36     	; 0x496 <_ZN3NRF13PrepareTxDataEh+0x5e>
	return 0x00;	//success
}//PrepareTxData

uint8_t NRF::PrepareTxData(uint8_t command){
	if (isInitializing())
		return 0x01;
 472:	81 e0       	ldi	r24, 0x01	; 1
 474:	10 c0       	rjmp	.+32     	; 0x496 <_ZN3NRF13PrepareTxDataEh+0x5e>
	if (hasDataToSend())
		return 0x02;
 476:	82 e0       	ldi	r24, 0x02	; 2
 478:	0e c0       	rjmp	.+28     	; 0x496 <_ZN3NRF13PrepareTxDataEh+0x5e>
	if (waitingForResponse() && isSystemCommand(command))
		return 0x03;
	
	lastCommand = command;
 47a:	fe 01       	movw	r30, r28
 47c:	ed 58       	subi	r30, 0x8D	; 141
 47e:	ff 4f       	sbci	r31, 0xFF	; 255
 480:	10 83       	st	Z, r17
	
	clearTxData();
 482:	ce 01       	movw	r24, r28
 484:	0e 94 35 01 	call	0x26a	; 0x26a <_ZN3NRF11clearTxDataEv>
	TxData[0] = 0x01;
 488:	81 e0       	ldi	r24, 0x01	; 1
 48a:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = command;
 48c:	1c af       	std	Y+60, r17	; 0x3c
	status |= (1<<NRF_TX_READY);
 48e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 490:	80 64       	ori	r24, 0x40	; 64
 492:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;
 494:	80 e0       	ldi	r24, 0x00	; 0
}
 496:	df 91       	pop	r29
 498:	cf 91       	pop	r28
 49a:	1f 91       	pop	r17
 49c:	08 95       	ret

0000049e <_ZN3NRF5sleepEv>:
	localData[1] = command&0x00FF;		//LSB
	return (PrepareTxData(NRF_CMD_DTM_COMMAND, localData, 2));
}//DTMcommand

uint8_t NRF::sleep(){
	return (PrepareTxData(NRF_CMD_SLEEP));
 49e:	64 e0       	ldi	r22, 0x04	; 4
 4a0:	0e 94 1c 02 	call	0x438	; 0x438 <_ZN3NRF13PrepareTxDataEh>
}//sleep
 4a4:	08 95       	ret

000004a6 <_ZN3NRF6wakeupEv>:

///@returns	error 0x00: success, 0x01: NRF initializing, 0x02: uC has not sent current data to NRF, 0x03: nRF has not responded from last command yet
uint8_t NRF::wakeup(void){	
	return (PrepareTxData(NRF_CMD_WAKEUP));
 4a6:	65 e0       	ldi	r22, 0x05	; 5
 4a8:	0e 94 1c 02 	call	0x438	; 0x438 <_ZN3NRF13PrepareTxDataEh>
}
 4ac:	08 95       	ret

000004ae <_ZN3NRF7connectEjj>:

uint8_t NRF::radioReset(){
	return (PrepareTxData(NRF_CMD_RADIO_RESET));
}//

uint8_t NRF::connect(uint16_t timeout, uint16_t advInterval){	
 4ae:	ef 92       	push	r14
 4b0:	ff 92       	push	r15
 4b2:	0f 93       	push	r16
 4b4:	1f 93       	push	r17
 4b6:	cf 93       	push	r28
 4b8:	df 93       	push	r29
 4ba:	ec 01       	movw	r28, r24
 4bc:	e6 2e       	mov	r14, r22
 4be:	f7 2e       	mov	r15, r23
 4c0:	04 2f       	mov	r16, r20
 4c2:	15 2f       	mov	r17, r21
#pragma endregion Data Command Functions

#pragma region Status Functions
uint8_t NRF::isInitializing(void){
	//return ((status & (1<<NRF_INIT_MODE))?TRUE:FALSE);
	return (mode == NRF_MODE_SETUP);
 4c4:	fc 01       	movw	r30, r24
 4c6:	ef 58       	subi	r30, 0x8F	; 143
 4c8:	ff 4f       	sbci	r31, 0xFF	; 255
	//localData[1] = (timeout&0xFF00)>>8; //MSB
	//localData[2] = (advInterval&0x00FF);	//LSB
	//localData[3] = (advInterval&0xFF00)>>8; //MSB
	//return (PrepareTxData(NRF_CMD_CONNECT, localData, 4));
	
	if (isInitializing())
 4ca:	80 81       	ld	r24, Z
 4cc:	82 30       	cpi	r24, 0x02	; 2
 4ce:	11 f1       	breq	.+68     	; 0x514 <__stack+0x15>
	return 0x01;
	if (hasDataToSend())
 4d0:	ce 01       	movw	r24, r28
 4d2:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 4d6:	81 11       	cpse	r24, r1
 4d8:	1f c0       	rjmp	.+62     	; 0x518 <__stack+0x19>
	return 0x02;
	if (waitingForResponse())
 4da:	ce 01       	movw	r24, r28
 4dc:	0e 94 04 01 	call	0x208	; 0x208 <_ZN3NRF18waitingForResponseEv>
 4e0:	81 11       	cpse	r24, r1
 4e2:	1c c0       	rjmp	.+56     	; 0x51c <__stack+0x1d>
	return 0x03;
	
	lastCommand = TxData[1];
 4e4:	fe 01       	movw	r30, r28
 4e6:	ed 58       	subi	r30, 0x8D	; 141
 4e8:	ff 4f       	sbci	r31, 0xFF	; 255
 4ea:	8c ad       	ldd	r24, Y+60	; 0x3c
 4ec:	80 83       	st	Z, r24
	
	clearTxData();
 4ee:	ce 01       	movw	r24, r28
 4f0:	0e 94 35 01 	call	0x26a	; 0x26a <_ZN3NRF11clearTxDataEv>
	TxData[0] = 0x05;	//length
 4f4:	85 e0       	ldi	r24, 0x05	; 5
 4f6:	8b af       	std	Y+59, r24	; 0x3b
	TxData[1] = NRF_CMD_CONNECT;
 4f8:	8f e0       	ldi	r24, 0x0F	; 15
 4fa:	8c af       	std	Y+60, r24	; 0x3c
	TxData[2] = (timeout&0x00FF);	//LSB
 4fc:	ed ae       	std	Y+61, r14	; 0x3d
	TxData[3] = (timeout&0xFF00)>>8; //MSB
 4fe:	fe ae       	std	Y+62, r15	; 0x3e
	TxData[4] = (advInterval&0x00FF);	//LSB
 500:	0f af       	std	Y+63, r16	; 0x3f
	TxData[5] = (advInterval&0xFF00)>>8; //MSB
 502:	fe 01       	movw	r30, r28
 504:	e0 5c       	subi	r30, 0xC0	; 192
 506:	ff 4f       	sbci	r31, 0xFF	; 255
 508:	10 83       	st	Z, r17
	status |= (1<<NRF_TX_READY);
 50a:	8a 8d       	ldd	r24, Y+26	; 0x1a
 50c:	80 64       	ori	r24, 0x40	; 64
 50e:	8a 8f       	std	Y+26, r24	; 0x1a
	return 0x00;
 510:	80 e0       	ldi	r24, 0x00	; 0
 512:	05 c0       	rjmp	.+10     	; 0x51e <__stack+0x1f>
	//localData[2] = (advInterval&0x00FF);	//LSB
	//localData[3] = (advInterval&0xFF00)>>8; //MSB
	//return (PrepareTxData(NRF_CMD_CONNECT, localData, 4));
	
	if (isInitializing())
	return 0x01;
 514:	81 e0       	ldi	r24, 0x01	; 1
 516:	03 c0       	rjmp	.+6      	; 0x51e <__stack+0x1f>
	if (hasDataToSend())
	return 0x02;
 518:	82 e0       	ldi	r24, 0x02	; 2
 51a:	01 c0       	rjmp	.+2      	; 0x51e <__stack+0x1f>
	if (waitingForResponse())
	return 0x03;
 51c:	83 e0       	ldi	r24, 0x03	; 3
	TxData[3] = (timeout&0xFF00)>>8; //MSB
	TxData[4] = (advInterval&0x00FF);	//LSB
	TxData[5] = (advInterval&0xFF00)>>8; //MSB
	status |= (1<<NRF_TX_READY);
	return 0x00;
}//
 51e:	df 91       	pop	r29
 520:	cf 91       	pop	r28
 522:	1f 91       	pop	r17
 524:	0f 91       	pop	r16
 526:	ff 90       	pop	r15
 528:	ef 90       	pop	r14
 52a:	08 95       	ret

0000052c <_ZN3NRF11transferACIEv>:
nRF8001 is capable of receiving an ACI command simultaneously as it sends an ACI event to the
application controller.
The application controller shall always read the length byte from nRF8001 and check if the length is
greater than 0. If the length is greater than 0 the data on the MISO line shall be read
*/
void NRF::transferACI(void){
 52c:	1f 93       	push	r17
 52e:	cf 93       	push	r28
 530:	df 93       	push	r29
 532:	ec 01       	movw	r28, r24
	uint8_t length; 
	
	//transmit and receive
	if (hasDataToSend() && (TxData[0] > 0)){			
 534:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 538:	88 23       	and	r24, r24
 53a:	09 f4       	brne	.+2      	; 0x53e <_ZN3NRF11transferACIEv+0x12>
 53c:	40 c0       	rjmp	.+128    	; 0x5be <_ZN3NRF11transferACIEv+0x92>
 53e:	8b ad       	ldd	r24, Y+59	; 0x3b
 540:	81 11       	cpse	r24, r1
 542:	40 c0       	rjmp	.+128    	; 0x5c4 <_ZN3NRF11transferACIEv+0x98>
 544:	3c c0       	rjmp	.+120    	; 0x5be <_ZN3NRF11transferACIEv+0x92>
		SetREQN();
		
		//when data is received, clear the ready to receive flag until
		//the received data is handled by the process function
		if (RxData[0] != 0x00){
			status &= ~(1<<NRF_RX_READY);
 546:	8a 8d       	ldd	r24, Y+26	; 0x1a
 548:	8f 77       	andi	r24, 0x7F	; 127
 54a:	8a 8f       	std	Y+26, r24	; 0x1a
		}
		
		
		lastCommand = TxData[1];
 54c:	6c ad       	ldd	r22, Y+60	; 0x3c
 54e:	fe 01       	movw	r30, r28
 550:	ed 58       	subi	r30, 0x8D	; 141
 552:	ff 4f       	sbci	r31, 0xFF	; 255
 554:	60 83       	st	Z, r22
		
		//clear the NRF_TX_READY flag in the status register
		status &= ~(1<<NRF_TX_READY);
 556:	1a 8d       	ldd	r17, Y+26	; 0x1a
 558:	1f 7b       	andi	r17, 0xBF	; 191
		
		if (isSystemCommand(TxData[1]))
 55a:	ce 01       	movw	r24, r28
 55c:	0e 94 1a 01 	call	0x234	; 0x234 <_ZN3NRF15isSystemCommandEh>
 560:	81 11       	cpse	r24, r1
 562:	02 c0       	rjmp	.+4      	; 0x568 <_ZN3NRF11transferACIEv+0x3c>
		
		
		lastCommand = TxData[1];
		
		//clear the NRF_TX_READY flag in the status register
		status &= ~(1<<NRF_TX_READY);
 564:	1a 8f       	std	Y+26, r17	; 0x1a
 566:	58 c0       	rjmp	.+176    	; 0x618 <_ZN3NRF11transferACIEv+0xec>
		
		if (isSystemCommand(TxData[1]))
			status |= (1<<NRF_WAIT_FOR_RESPONSE);
 568:	10 61       	ori	r17, 0x10	; 16
 56a:	1a 8f       	std	Y+26, r17	; 0x1a
 56c:	55 c0       	rjmp	.+170    	; 0x618 <_ZN3NRF11transferACIEv+0xec>
	}//if hasDataToSend
	
	//receive only
	else if(RDYN == 0)
	{
		clearTxData();
 56e:	ce 01       	movw	r24, r28
 570:	0e 94 35 01 	call	0x26a	; 0x26a <_ZN3NRF11clearTxDataEv>
		//Request communication with nRF8001
		ClearREQN();
 574:	29 98       	cbi	0x05, 1	; 5
		
		//transmit the DUMMY BYTE and receive the Rx DEBUG BYTE
		//the LENGTH BYTE is not counted as part of the length
		RxData[0] = spi.transfer1byte(0x00);
 576:	60 e0       	ldi	r22, 0x00	; 0
 578:	85 e7       	ldi	r24, 0x75	; 117
 57a:	93 e0       	ldi	r25, 0x03	; 3
 57c:	0e 94 ef 00 	call	0x1de	; 0x1de <_ZN3SPI13transfer1byteEh>
 580:	8b 8f       	std	Y+27, r24	; 0x1b
		
		//Transmit a DUMMY BYTE and receive the LENGTH BYTE
		RxData[0] = spi.transfer1byte(0x00);
 582:	60 e0       	ldi	r22, 0x00	; 0
 584:	85 e7       	ldi	r24, 0x75	; 117
 586:	93 e0       	ldi	r25, 0x03	; 3
 588:	0e 94 ef 00 	call	0x1de	; 0x1de <_ZN3SPI13transfer1byteEh>
 58c:	8b 8f       	std	Y+27, r24	; 0x1b
 58e:	28 2f       	mov	r18, r24
 590:	80 32       	cpi	r24, 0x20	; 32
 592:	08 f0       	brcs	.+2      	; 0x596 <_ZN3NRF11transferACIEv+0x6a>
 594:	2f e1       	ldi	r18, 0x1F	; 31
		
		length = RxData[0];
		if (length>HAL_ACI_MAX_LENGTH)
			length = HAL_ACI_MAX_LENGTH;
		if (length>0)
 596:	22 23       	and	r18, r18
 598:	51 f0       	breq	.+20     	; 0x5ae <_ZN3NRF11transferACIEv+0x82>
		{
			
			spi.transfer(&TxData[2],&RxData[1],length);
 59a:	ae 01       	movw	r20, r28
 59c:	44 5e       	subi	r20, 0xE4	; 228
 59e:	5f 4f       	sbci	r21, 0xFF	; 255
 5a0:	be 01       	movw	r22, r28
 5a2:	63 5c       	subi	r22, 0xC3	; 195
 5a4:	7f 4f       	sbci	r23, 0xFF	; 255
 5a6:	85 e7       	ldi	r24, 0x75	; 117
 5a8:	93 e0       	ldi	r25, 0x03	; 3
 5aa:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN3SPI8transferEPhS0_h>
		}//if length>0
		
		//Set REQN high to terminate the transfer
		SetREQN();
 5ae:	29 9a       	sbi	0x05, 1	; 5
		
		//when data is received, clear the ready to receive flag until
		//the received data is handled by the process function
		if (RxData[0] != 0x00){
 5b0:	8b 8d       	ldd	r24, Y+27	; 0x1b
 5b2:	88 23       	and	r24, r24
 5b4:	89 f1       	breq	.+98     	; 0x618 <_ZN3NRF11transferACIEv+0xec>
			status &= ~(1<<NRF_RX_READY);
 5b6:	8a 8d       	ldd	r24, Y+26	; 0x1a
 5b8:	8f 77       	andi	r24, 0x7F	; 127
 5ba:	8a 8f       	std	Y+26, r24	; 0x1a
 5bc:	2d c0       	rjmp	.+90     	; 0x618 <_ZN3NRF11transferACIEv+0xec>
			status |= (1<<NRF_WAIT_FOR_RESPONSE);
				
	}//if hasDataToSend
	
	//receive only
	else if(RDYN == 0)
 5be:	2a 99       	sbic	0x05, 2	; 5
 5c0:	2b c0       	rjmp	.+86     	; 0x618 <_ZN3NRF11transferACIEv+0xec>
 5c2:	d5 cf       	rjmp	.-86     	; 0x56e <_ZN3NRF11transferACIEv+0x42>
	//transmit and receive
	if (hasDataToSend() && (TxData[0] > 0)){			
		length = TxData[0];
	
		//Request communication with nRF8001
		ClearREQN();
 5c4:	29 98       	cbi	0x05, 1	; 5
	
		//Wait for nRF8001 to clear RDYN pin indicating it is ready to receive
		while (RDYN == 1);
 5c6:	85 b1       	in	r24, 0x05	; 5
	
		//transmit the Tx LENGTH BYTE and receive the Rx DEBUG BYTE
		//the LENGTH BYTE is not counted as part of the length
		RxData[0] = spi.transfer1byte(TxData[0]);
 5c8:	6b ad       	ldd	r22, Y+59	; 0x3b
 5ca:	85 e7       	ldi	r24, 0x75	; 117
 5cc:	93 e0       	ldi	r25, 0x03	; 3
 5ce:	0e 94 ef 00 	call	0x1de	; 0x1de <_ZN3SPI13transfer1byteEh>
 5d2:	8b 8f       	std	Y+27, r24	; 0x1b
	
	
		//transmit the first byte of data while receiving the length byte
		//we are discarding the Rx DEBUG BYTE
		RxData[0] = spi.transfer1byte(TxData[1]);
 5d4:	6c ad       	ldd	r22, Y+60	; 0x3c
 5d6:	85 e7       	ldi	r24, 0x75	; 117
 5d8:	93 e0       	ldi	r25, 0x03	; 3
 5da:	0e 94 ef 00 	call	0x1de	; 0x1de <_ZN3SPI13transfer1byteEh>
 5de:	8b 8f       	std	Y+27, r24	; 0x1b
	
		////set length to the greater of TxData less the byte we already sent or 
		////RxData length
		length = (RxData[0]>(TxData[0] -1))?RxData[0]:(TxData[0]-1);
 5e0:	4b ad       	ldd	r20, Y+59	; 0x3b
 5e2:	50 e0       	ldi	r21, 0x00	; 0
 5e4:	41 50       	subi	r20, 0x01	; 1
 5e6:	51 09       	sbc	r21, r1
 5e8:	28 2f       	mov	r18, r24
 5ea:	30 e0       	ldi	r19, 0x00	; 0
 5ec:	24 17       	cp	r18, r20
 5ee:	35 07       	cpc	r19, r21
 5f0:	0c f4       	brge	.+2      	; 0x5f4 <_ZN3NRF11transferACIEv+0xc8>
 5f2:	9a 01       	movw	r18, r20
 5f4:	20 32       	cpi	r18, 0x20	; 32
 5f6:	08 f0       	brcs	.+2      	; 0x5fa <_ZN3NRF11transferACIEv+0xce>
 5f8:	2f e1       	ldi	r18, 0x1F	; 31
		if (length>HAL_ACI_MAX_LENGTH) 
			length = HAL_ACI_MAX_LENGTH;
			
		//if (length>0)
		spi.transfer(&TxData[2],&RxData[1],length);
 5fa:	ae 01       	movw	r20, r28
 5fc:	44 5e       	subi	r20, 0xE4	; 228
 5fe:	5f 4f       	sbci	r21, 0xFF	; 255
 600:	be 01       	movw	r22, r28
 602:	63 5c       	subi	r22, 0xC3	; 195
 604:	7f 4f       	sbci	r23, 0xFF	; 255
 606:	85 e7       	ldi	r24, 0x75	; 117
 608:	93 e0       	ldi	r25, 0x03	; 3
 60a:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN3SPI8transferEPhS0_h>
		//for (uint8_t i = 0; i< length; i++){
			//RxData[i+1] = spi.transfer1byte(TxData[i+2]); 
		//}
	
		//Set REQN high to terminate the transfer
		SetREQN();
 60e:	29 9a       	sbi	0x05, 1	; 5
		
		//when data is received, clear the ready to receive flag until
		//the received data is handled by the process function
		if (RxData[0] != 0x00){
 610:	8b 8d       	ldd	r24, Y+27	; 0x1b
 612:	81 11       	cpse	r24, r1
 614:	98 cf       	rjmp	.-208    	; 0x546 <_ZN3NRF11transferACIEv+0x1a>
 616:	9a cf       	rjmp	.-204    	; 0x54c <_ZN3NRF11transferACIEv+0x20>
			status &= ~(1<<NRF_RX_READY);
		}
		
	}//else if(RDYN == 0)	
	
}//transferACI()
 618:	df 91       	pop	r29
 61a:	cf 91       	pop	r28
 61c:	1f 91       	pop	r17
 61e:	08 95       	ret

00000620 <_ZN3NRF11clearRxDataEv>:
void NRF::clearTxData(){
	for(int i = 0; i<32; i++) 
		TxData[i] = 0x00;		
}
void NRF::clearRxData(){
 620:	fc 01       	movw	r30, r24
 622:	7b 96       	adiw	r30, 0x1b	; 27
	for(int i = 0; i<32; i++)
 624:	20 e0       	ldi	r18, 0x00	; 0
 626:	30 e0       	ldi	r19, 0x00	; 0
		RxData[i] = 0x00;
 628:	11 92       	st	Z+, r1
void NRF::clearTxData(){
	for(int i = 0; i<32; i++) 
		TxData[i] = 0x00;		
}
void NRF::clearRxData(){
	for(int i = 0; i<32; i++)
 62a:	2f 5f       	subi	r18, 0xFF	; 255
 62c:	3f 4f       	sbci	r19, 0xFF	; 255
 62e:	20 32       	cpi	r18, 0x20	; 32
 630:	31 05       	cpc	r19, r1
 632:	d1 f7       	brne	.-12     	; 0x628 <_ZN3NRF11clearRxDataEv+0x8>
		RxData[i] = 0x00;
}
 634:	08 95       	ret

00000636 <_ZN3NRF22processCommandResponseEv>:
			
		}
	}//else RxData
}//process

void NRF::processCommandResponse(){
 636:	cf 93       	push	r28
 638:	df 93       	push	r29
 63a:	ec 01       	movw	r28, r24
	//	2		CommandOpCode (see switch statement below)
	//	3		Status of command execution
	//	4..31	Command specific data
	
	
	switch (RxData[2]){	//CommandOpCode
 63c:	4d 8d       	ldd	r20, Y+29	; 0x1d
 63e:	50 e0       	ldi	r21, 0x00	; 0
 640:	fa 01       	movw	r30, r20
 642:	31 97       	sbiw	r30, 0x01	; 1
 644:	ee 31       	cpi	r30, 0x1E	; 30
 646:	f1 05       	cpc	r31, r1
 648:	08 f0       	brcs	.+2      	; 0x64c <_ZN3NRF22processCommandResponseEv+0x16>
 64a:	6c c0       	rjmp	.+216    	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
 64c:	ec 5c       	subi	r30, 0xCC	; 204
 64e:	ff 4f       	sbci	r31, 0xFF	; 255
 650:	0c 94 5d 06 	jmp	0xcba	; 0xcba <__tablejump2__>
			//RxData[3]	:	Status
			//					ACI_STATUS_ERROR_DEVICE_STATE_INVALID when used in incorrect mode
			//						can only be used in NRF_MODE_TEST, NRF_MODE_SETUP, NRF_MODE_STANDBY
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 654:	8a 8d       	ldd	r24, Y+26	; 0x1a
 656:	8f 7e       	andi	r24, 0xEF	; 239
 658:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 65a:	64 c0       	rjmp	.+200    	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[3]	:	Status
			//					ACI_STATUS_ERROR_DEVICE_STATE_INVALID when used in incorrect mode
			//						can only be used in NRF_MODE_TEST
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 65c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 65e:	8f 7e       	andi	r24, 0xEF	; 239
 660:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 662:	60 c0       	rjmp	.+192    	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[4-5]	:	DTM Event (2 bytes MSB/LSB)
			//Refer to Bluetooth Core specification v4.0, Volume 6, Part F, Direct Test Mode,
			//Sect.3.4, ‘Events’, for description of DTM event format and content
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 664:	8a 8d       	ldd	r24, Y+26	; 0x1a
 666:	8f 7e       	andi	r24, 0xEF	; 239
 668:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 66a:	5c c0       	rjmp	.+184    	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[3]	:	Status
			//					ACI_STATUS_ERROR_DEVICE_STATE_INVALID when used in incorrect mode
			//						can only be used in NRF_MODE_STANDBY
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 66c:	8a 8d       	ldd	r24, Y+26	; 0x1a
 66e:	8f 7e       	andi	r24, 0xEF	; 239
 670:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 672:	58 c0       	rjmp	.+176    	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
			//then a NRF_EVT_COMMAND_RESPONSE with a NRF_CMD_WAKEUP, which brings us here
			//RxData[3]		: status - better be success
			//RxData[4]		: none
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 674:	8a 8d       	ldd	r24, Y+26	; 0x1a
 676:	8f 7e       	andi	r24, 0xEF	; 239
 678:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 67a:	54 c0       	rjmp	.+168    	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
			
				
			//on the last run of CMD_SETUP
			//do NOT clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			//the NRF_CMD_SETUP will be followed by NRF_EVT_DEVICE_STARTED			
			if (RxData[3] == ACI_STATUS_TRANSACTION_CONTINUE){
 67c:	8e 8d       	ldd	r24, Y+30	; 0x1e
 67e:	81 30       	cpi	r24, 0x01	; 1
 680:	19 f4       	brne	.+6      	; 0x688 <_ZN3NRF22processCommandResponseEv+0x52>
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 682:	8a 8d       	ldd	r24, Y+26	; 0x1a
 684:	8f 7e       	andi	r24, 0xEF	; 239
 686:	8a 8f       	std	Y+26, r24	; 0x1a
			}
			
			//set the NRF_RX_READY bit in the status register
			status |= (1<<NRF_RX_READY);
 688:	8a 8d       	ldd	r24, Y+26	; 0x1a
 68a:	80 68       	ori	r24, 0x80	; 128
 68c:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 68e:	4a c0       	rjmp	.+148    	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_READ_DYNAMIC_DATA:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 690:	8a 8d       	ldd	r24, Y+26	; 0x1a
 692:	8f 7e       	andi	r24, 0xEF	; 239
 694:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 696:	46 c0       	rjmp	.+140    	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_WRITE_DYNAMIC_DATA:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 698:	8a 8d       	ldd	r24, Y+26	; 0x1a
 69a:	8f 7e       	andi	r24, 0xEF	; 239
 69c:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 69e:	42 c0       	rjmp	.+132    	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
			//RxData[4-5]	:	Config ID - (LSB/MSB)
			//RxData[6]		:	ACI Protocol version
			//
		
			//TODO: finish this
			version = RxData[6];
 6a0:	89 a1       	ldd	r24, Y+33	; 0x21
 6a2:	90 e0       	ldi	r25, 0x00	; 0
 6a4:	99 8f       	std	Y+25, r25	; 0x19
 6a6:	88 8f       	std	Y+24, r24	; 0x18
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6a8:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6aa:	8f 7e       	andi	r24, 0xEF	; 239
 6ac:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6ae:	3a c0       	rjmp	.+116    	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_GET_DEVICE_ADDRESS:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6b0:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6b2:	8f 7e       	andi	r24, 0xEF	; 239
 6b4:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6b6:	36 c0       	rjmp	.+108    	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_GET_BATTERY_LEVEL:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6b8:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6ba:	8f 7e       	andi	r24, 0xEF	; 239
 6bc:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6be:	32 c0       	rjmp	.+100    	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
			// RxData[5] : temperature MSB
		
			//data[0] = NRF_CMD_GET_TEMPERATURE;
			//data[1] = RxData[4];
			//data[2] = RxData[3];
			if (RxData[3] == ACI_STATUS_SUCCESS)
 6c0:	8e 8d       	ldd	r24, Y+30	; 0x1e
 6c2:	81 11       	cpse	r24, r1
 6c4:	09 c0       	rjmp	.+18     	; 0x6d8 <_ZN3NRF22processCommandResponseEv+0xa2>
			temperature = (RxData[5]<<4 | RxData[4]);
 6c6:	88 a1       	ldd	r24, Y+32	; 0x20
 6c8:	20 e1       	ldi	r18, 0x10	; 16
 6ca:	82 9f       	mul	r24, r18
 6cc:	c0 01       	movw	r24, r0
 6ce:	11 24       	eor	r1, r1
 6d0:	2f 8d       	ldd	r18, Y+31	; 0x1f
 6d2:	82 2b       	or	r24, r18
 6d4:	9f 8b       	std	Y+23, r25	; 0x17
 6d6:	8e 8b       	std	Y+22, r24	; 0x16
			clearRxData();
 6d8:	ce 01       	movw	r24, r28
 6da:	0e 94 10 03 	call	0x620	; 0x620 <_ZN3NRF11clearRxDataEv>
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6de:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6e0:	8f 7e       	andi	r24, 0xEF	; 239
 6e2:	8a 8f       	std	Y+26, r24	; 0x1a
		break;
 6e4:	1f c0       	rjmp	.+62     	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
			case NRF_CMD_RADIO_RESET:
			//will initialization have to be redone upon reset?
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6e6:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6e8:	8f 7e       	andi	r24, 0xEF	; 239
 6ea:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6ec:	1b c0       	rjmp	.+54     	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
			//status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
			break;
		case NRF_CMD_SET_TX_POWER:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6ee:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6f0:	8f 7e       	andi	r24, 0xEF	; 239
 6f2:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6f4:	17 c0       	rjmp	.+46     	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
			//or by NRF_EVT_PIPE_ERROR(failure)
			break;
		case NRF_CMD_SET_APP_LATENCY:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6f6:	8a 8d       	ldd	r24, Y+26	; 0x1a
 6f8:	8f 7e       	andi	r24, 0xEF	; 239
 6fa:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 6fc:	13 c0       	rjmp	.+38     	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_SET_KEY:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 6fe:	8a 8d       	ldd	r24, Y+26	; 0x1a
 700:	8f 7e       	andi	r24, 0xEF	; 239
 702:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 704:	0f c0       	rjmp	.+30     	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_OPEN_ADV_PIPE:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 706:	8a 8d       	ldd	r24, Y+26	; 0x1a
 708:	8f 7e       	andi	r24, 0xEF	; 239
 70a:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 70c:	0b c0       	rjmp	.+22     	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_BROADCAST:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 70e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 710:	8f 7e       	andi	r24, 0xEF	; 239
 712:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 714:	07 c0       	rjmp	.+14     	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_BOND_SEC_REQUEST:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 716:	8a 8d       	ldd	r24, Y+26	; 0x1a
 718:	8f 7e       	andi	r24, 0xEF	; 239
 71a:	8a 8f       	std	Y+26, r24	; 0x1a
			break;
 71c:	03 c0       	rjmp	.+6      	; 0x724 <_ZN3NRF22processCommandResponseEv+0xee>
		case NRF_CMD_DIRECT_CONNECT:
		
			//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
			status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 71e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 720:	8f 7e       	andi	r24, 0xEF	; 239
 722:	8a 8f       	std	Y+26, r24	; 0x1a
		default:
			break;
		
	}//end switch RxData[2]
	
}//processCommandResponse()
 724:	df 91       	pop	r29
 726:	cf 91       	pop	r28
 728:	08 95       	ret

0000072a <_ZN3NRF7processEv>:
	//set to INIT_MODE and RX_READY
	//we are waiting for a NRF_EVT_DEVICE_STARTED in NRF_MODE_SETUP
	//status |= (1<<NRF_RX_READY | 1<<NRF_INIT_MODE | 1<<NRF_WAIT_FOR_RESPONSE);
	status |= (1<<NRF_RX_READY | 1<<NRF_WAIT_FOR_RESPONSE);
}
void NRF::process(void){	
 72a:	1f 93       	push	r17
 72c:	cf 93       	push	r28
 72e:	df 93       	push	r29
 730:	ec 01       	movw	r28, r24
	uint8_t i;
	if (isReadyToReceiveData()){
 732:	8a 8d       	ldd	r24, Y+26	; 0x1a
 734:	88 23       	and	r24, r24
 736:	1c f4       	brge	.+6      	; 0x73e <_ZN3NRF7processEv+0x14>
		clearRxData();
 738:	ce 01       	movw	r24, r28
 73a:	0e 94 10 03 	call	0x620	; 0x620 <_ZN3NRF11clearRxDataEv>
	}
		
	
	//setup message from services.h file loaded onto nRF8001
	if( (mode == NRF_MODE_SETUP)  && !hasDataToSend() && !waitingForResponse() ) {
 73e:	fe 01       	movw	r30, r28
 740:	ef 58       	subi	r30, 0x8F	; 143
 742:	ff 4f       	sbci	r31, 0xFF	; 255
 744:	80 81       	ld	r24, Z
 746:	82 30       	cpi	r24, 0x02	; 2
 748:	31 f5       	brne	.+76     	; 0x796 <_ZN3NRF7processEv+0x6c>
 74a:	ce 01       	movw	r24, r28
 74c:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 750:	81 11       	cpse	r24, r1
 752:	21 c0       	rjmp	.+66     	; 0x796 <_ZN3NRF7processEv+0x6c>
 754:	ce 01       	movw	r24, r28
 756:	0e 94 04 01 	call	0x208	; 0x208 <_ZN3NRF18waitingForResponseEv>
 75a:	88 23       	and	r24, r24
 75c:	09 f4       	brne	.+2      	; 0x760 <_ZN3NRF7processEv+0x36>
 75e:	c7 c0       	rjmp	.+398    	; 0x8ee <_ZN3NRF7processEv+0x1c4>
 760:	1a c0       	rjmp	.+52     	; 0x796 <_ZN3NRF7processEv+0x6c>
		//load current line of setup msg into TX buffer
		for(int i = 0; i <= setup_msgs[initCount].buffer[0]; i++){
#ifdef PROGRAMSPACE			
			TxData[i] = pgm_read_byte(&setup_msgs[initCount].buffer[i]);
#else
			TxData[i] = setup_msgs[initCount].buffer[i];
 762:	dc 01       	movw	r26, r24
 764:	a2 0f       	add	r26, r18
 766:	b3 1f       	adc	r27, r19
 768:	11 96       	adiw	r26, 0x01	; 1
 76a:	6c 91       	ld	r22, X
 76c:	61 93       	st	Z+, r22
		
	
	//setup message from services.h file loaded onto nRF8001
	if( (mode == NRF_MODE_SETUP)  && !hasDataToSend() && !waitingForResponse() ) {
		//load current line of setup msg into TX buffer
		for(int i = 0; i <= setup_msgs[initCount].buffer[0]; i++){
 76e:	2f 5f       	subi	r18, 0xFF	; 255
 770:	3f 4f       	sbci	r19, 0xFF	; 255
 772:	42 17       	cp	r20, r18
 774:	53 07       	cpc	r21, r19
 776:	ac f7       	brge	.-22     	; 0x762 <_ZN3NRF7processEv+0x38>
			TxData[i] = setup_msgs[initCount].buffer[i];
#endif
		}
		
		//set transmit ready and wait for response flags in status register
		status |= ((1<<NRF_TX_READY));
 778:	9a 8d       	ldd	r25, Y+26	; 0x1a
 77a:	90 64       	ori	r25, 0x40	; 64
 77c:	9a 8f       	std	Y+26, r25	; 0x1a
		
		initCount++;
 77e:	81 e0       	ldi	r24, 0x01	; 1
 780:	87 0f       	add	r24, r23
		////after the last setup message
		if (initCount > NB_SETUP_MESSAGES) 
 782:	84 31       	cpi	r24, 0x14	; 20
 784:	18 f4       	brcc	.+6      	; 0x78c <_ZN3NRF7processEv+0x62>
		}
		
		//set transmit ready and wait for response flags in status register
		status |= ((1<<NRF_TX_READY));
		
		initCount++;
 786:	80 93 74 03 	sts	0x0374, r24
 78a:	05 c0       	rjmp	.+10     	; 0x796 <_ZN3NRF7processEv+0x6c>
		////after the last setup message
		if (initCount > NB_SETUP_MESSAGES) 
		{
			initCount = 0;
 78c:	10 92 74 03 	sts	0x0374, r1
			
			clearTxData();
 790:	ce 01       	movw	r24, r28
 792:	0e 94 35 01 	call	0x26a	; 0x26a <_ZN3NRF11clearTxDataEv>
}
uint8_t NRF::hasDataToSend(void){
	return ((status & (1<<NRF_TX_READY))?TRUE:FALSE);
}
uint8_t NRF::isReadyToReceiveData(){
	return ((status & (1<<NRF_RX_READY))?TRUE:FALSE);
 796:	1a 8d       	ldd	r17, Y+26	; 0x1a
	}//setup message
	
	
	//handle messages received from nRF8001
	//else //testing**************************************************************************************
	if (!isReadyToReceiveData()){
 798:	11 23       	and	r17, r17
 79a:	0c f4       	brge	.+2      	; 0x79e <_ZN3NRF7processEv+0x74>
 79c:	9d c0       	rjmp	.+314    	; 0x8d8 <_ZN3NRF7processEv+0x1ae>
		RxCount++;
 79e:	8d 89       	ldd	r24, Y+21	; 0x15
 7a0:	91 e0       	ldi	r25, 0x01	; 1
 7a2:	98 0f       	add	r25, r24
 7a4:	9d 8b       	std	Y+21, r25	; 0x15
				
		switch (RxData[1]){
 7a6:	4c 8d       	ldd	r20, Y+28	; 0x1c
 7a8:	50 e0       	ldi	r21, 0x00	; 0
 7aa:	fa 01       	movw	r30, r20
 7ac:	e1 58       	subi	r30, 0x81	; 129
 7ae:	f1 09       	sbc	r31, r1
 7b0:	ef 30       	cpi	r30, 0x0F	; 15
 7b2:	f1 05       	cpc	r31, r1
 7b4:	08 f0       	brcs	.+2      	; 0x7b8 <_ZN3NRF7processEv+0x8e>
 7b6:	8b c0       	rjmp	.+278    	; 0x8ce <_ZN3NRF7processEv+0x1a4>
 7b8:	ee 5a       	subi	r30, 0xAE	; 174
 7ba:	ff 4f       	sbci	r31, 0xFF	; 255
 7bc:	0c 94 5d 06 	jmp	0xcba	; 0xcba <__tablejump2__>
				//RxData[2]		:	service pipe number
				//RxData[3..23]	:	Data
				
				// Fill data with RxData values
				
				for (i = 0; i< RxData[0] - 1;i++){
 7c0:	5b 8d       	ldd	r21, Y+27	; 0x1b
 7c2:	25 2f       	mov	r18, r21
 7c4:	30 e0       	ldi	r19, 0x00	; 0
 7c6:	21 50       	subi	r18, 0x01	; 1
 7c8:	31 09       	sbc	r19, r1
 7ca:	12 16       	cp	r1, r18
 7cc:	13 06       	cpc	r1, r19
 7ce:	0c f4       	brge	.+2      	; 0x7d2 <_ZN3NRF7processEv+0xa8>
 7d0:	68 c0       	rjmp	.+208    	; 0x8a2 <_ZN3NRF7processEv+0x178>
 7d2:	75 c0       	rjmp	.+234    	; 0x8be <_ZN3NRF7processEv+0x194>
				//					0x02	Setup
				//					0x03	Standby
				//RxData[3]	:	HWError 0x01 = error, 0x00 = no error
				//RxData[4]	:	DataCreditAvailable - Number of DataCommand buffers available
				
				if (RxData[2]>0)
 7d4:	8d 8d       	ldd	r24, Y+29	; 0x1d
 7d6:	88 23       	and	r24, r24
 7d8:	21 f0       	breq	.+8      	; 0x7e2 <_ZN3NRF7processEv+0xb8>
					mode = RxData[2];
 7da:	fe 01       	movw	r30, r28
 7dc:	ef 58       	subi	r30, 0x8F	; 143
 7de:	ff 4f       	sbci	r31, 0xFF	; 255
 7e0:	80 83       	st	Z, r24
				
				
				//when NRF_CMD_WAKEUP has been called, the NRF_WAIT_FOR_RESPONSE bit in the status register should NOT be cleared
				//when finishing a NRF_CMD_SETUP, the NRF_WAIT_FOR_RESPONSE bit in the status register SHOULD be cleared
				if (mode == NRF_MODE_SETUP){
 7e2:	fe 01       	movw	r30, r28
 7e4:	ef 58       	subi	r30, 0x8F	; 143
 7e6:	ff 4f       	sbci	r31, 0xFF	; 255
 7e8:	80 81       	ld	r24, Z
 7ea:	82 30       	cpi	r24, 0x02	; 2
 7ec:	19 f4       	brne	.+6      	; 0x7f4 <_ZN3NRF7processEv+0xca>
				//if (isInitializing()){
					//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
					status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 7ee:	1f 7e       	andi	r17, 0xEF	; 239
 7f0:	1a 8f       	std	Y+26, r17	; 0x1a
 7f2:	0a c0       	rjmp	.+20     	; 0x808 <_ZN3NRF7processEv+0xde>
					
				}
				
				
				if (mode == NRF_MODE_STANDBY){
 7f4:	83 30       	cpi	r24, 0x03	; 3
 7f6:	41 f4       	brne	.+16     	; 0x808 <_ZN3NRF7processEv+0xde>
					//clear the NRF_INIT_MODE bit in the status register when SETUP finishes
					//status &= ~(1<<NRF_INIT_MODE);
					dataCredit = RxData[4];
 7f8:	8f 8d       	ldd	r24, Y+31	; 0x1f
 7fa:	fe 01       	movw	r30, r28
 7fc:	ee 58       	subi	r30, 0x8E	; 142
 7fe:	ff 4f       	sbci	r31, 0xFF	; 255
 800:	80 83       	st	Z, r24
					status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 802:	8a 8d       	ldd	r24, Y+26	; 0x1a
 804:	8f 7e       	andi	r24, 0xEF	; 239
 806:	8a 8f       	std	Y+26, r24	; 0x1a
				}
				
				
				
				//set the NRF_RX_READY bit in the status register
				status |= (1<<NRF_RX_READY);
 808:	8a 8d       	ldd	r24, Y+26	; 0x1a
 80a:	80 68       	ori	r24, 0x80	; 128
 80c:	8a 8f       	std	Y+26, r24	; 0x1a
				
				//TODO: error handling
				break;
 80e:	60 c0       	rjmp	.+192    	; 0x8d0 <_ZN3NRF7processEv+0x1a6>
			case NRF_EVT_ECHO:				//0x82
				//returns an identical copy of the PDU sent using the echo command in Test Mode
				//RxData[0]	:	length
				//RxData[1]	:	NRF_EVT_ECHO (0x82)
				//RxData[2..31]	:	Identical message to one sent with NRF_CMD_ECHO
				data[0] = RxData[0];
 810:	8b 8d       	ldd	r24, Y+27	; 0x1b
 812:	88 83       	st	Y, r24
				data[1] = RxData[1];
 814:	82 e8       	ldi	r24, 0x82	; 130
 816:	89 83       	std	Y+1, r24	; 0x01
				data[2] = RxData[2];
 818:	8d 8d       	ldd	r24, Y+29	; 0x1d
 81a:	8a 83       	std	Y+2, r24	; 0x02
				data[3] = RxData[3];
 81c:	8e 8d       	ldd	r24, Y+30	; 0x1e
 81e:	8b 83       	std	Y+3, r24	; 0x03
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 820:	1f 7e       	andi	r17, 0xEF	; 239
 822:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 824:	55 c0       	rjmp	.+170    	; 0x8d0 <_ZN3NRF7processEv+0x1a6>
			case NRF_EVT_HARDWARE_ERROR:	//0x83
				//provides debug information
				//in case of firmware failure, this event follows NRF_EVT_DEVICE_STARTED
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 826:	1f 7e       	andi	r17, 0xEF	; 239
 828:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 82a:	52 c0       	rjmp	.+164    	; 0x8d0 <_ZN3NRF7processEv+0x1a6>
			case NRF_EVT_COMMAND_RESPONSE:	//0x84
				//confirms reception or execution of an ACI command
				processCommandResponse();				
 82c:	ce 01       	movw	r24, r28
 82e:	0e 94 1b 03 	call	0x636	; 0x636 <_ZN3NRF22processCommandResponseEv>
				break;
 832:	4e c0       	rjmp	.+156    	; 0x8d0 <_ZN3NRF7processEv+0x1a6>
				status |= (1<<NRF_CONNECTED);
				
							//do NOT clear the NRF_WAIT_FOR_RESPONSE bit of the status register here
							//there will be either a NRF_EVT_BOND_STATUS or a NRF_EVT_PIPE_STATUS following NRF_EVT_CONNECTED
				//actually it seems to need to be cleared here
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 834:	81 2f       	mov	r24, r17
 836:	8f 7e       	andi	r24, 0xEF	; 239
 838:	88 60       	ori	r24, 0x08	; 8
 83a:	8a 8f       	std	Y+26, r24	; 0x1a
				
				break;
 83c:	49 c0       	rjmp	.+146    	; 0x8d0 <_ZN3NRF7processEv+0x1a6>
				
				//TODO: can we be still connected if we get here through a failure to bond
				status &= ~(1<<NRF_CONNECTED | 1<<NRF_BONDED);
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 83e:	13 7e       	andi	r17, 0xE3	; 227
 840:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 842:	46 c0       	rjmp	.+140    	; 0x8d0 <_ZN3NRF7processEv+0x1a6>
				//					0x02		: generated by the remote peer.
				//	4		:	BondStatus-SecMode1 - LE Security Mode 1
				//	5		:	LE Security Mode 2
				//	6		:	Keys Exchanged (slave)
				//	7		:	Keys Exchanged (master)
				if (RxData[2] == 0x00){ // successful bond
 844:	8d 8d       	ldd	r24, Y+29	; 0x1d
 846:	81 11       	cpse	r24, r1
 848:	02 c0       	rjmp	.+4      	; 0x84e <_ZN3NRF7processEv+0x124>
					status |= (1<<NRF_BONDED);
 84a:	14 60       	ori	r17, 0x04	; 4
 84c:	1a 8f       	std	Y+26, r17	; 0x1a
				}
				
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 84e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 850:	8f 7e       	andi	r24, 0xEF	; 239
 852:	8a 8f       	std	Y+26, r24	; 0x1a
				break;
 854:	3d c0       	rjmp	.+122    	; 0x8d0 <_ZN3NRF7processEv+0x1a6>
 856:	fe 01       	movw	r30, r28
 858:	ed 59       	subi	r30, 0x9D	; 157
 85a:	ff 4f       	sbci	r31, 0xFF	; 255
	//handle messages received from nRF8001
	//else //testing**************************************************************************************
	if (!isReadyToReceiveData()){
		RxCount++;
				
		switch (RxData[1]){
 85c:	80 e0       	ldi	r24, 0x00	; 0
 85e:	df 01       	movw	r26, r30
 860:	a6 54       	subi	r26, 0x46	; 70
 862:	b1 09       	sbc	r27, r1
				//this event is sent when there is a change in service pipe availability
				//RxData[2..9]		: 64-bit PipesOpen bitmap
				//RxData[10..17]	: 64-bit PipesClosed bitmap
				//see pg 148 of datasheet for details
				for (i = 0 ; i<8; i++){
					pipesOpen[i] = RxData[i+2];
 864:	9c 91       	ld	r25, X
 866:	de 96       	adiw	r26, 0x3e	; 62
 868:	9c 93       	st	X, r25
 86a:	d6 97       	sbiw	r26, 0x36	; 54
					pipesClosed[i] = RxData[i+10];
 86c:	9c 91       	ld	r25, X
 86e:	91 93       	st	Z+, r25
			case NRF_EVT_PIPE_STATUS:
				//this event is sent when there is a change in service pipe availability
				//RxData[2..9]		: 64-bit PipesOpen bitmap
				//RxData[10..17]	: 64-bit PipesClosed bitmap
				//see pg 148 of datasheet for details
				for (i = 0 ; i<8; i++){
 870:	8f 5f       	subi	r24, 0xFF	; 255
 872:	88 30       	cpi	r24, 0x08	; 8
 874:	a1 f7       	brne	.-24     	; 0x85e <_ZN3NRF7processEv+0x134>
					pipesOpen[i] = RxData[i+2];
					pipesClosed[i] = RxData[i+10];
				}
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 876:	1f 7e       	andi	r17, 0xEF	; 239
 878:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 87a:	2a c0       	rjmp	.+84     	; 0x8d0 <_ZN3NRF7processEv+0x1a6>
				//RxData[2-3]	: ConnectionInterval (MSB first)
				//RxData[4-5]	: SlaveLatency (LSB/MSB)
				//RxData[6-7]	: SupervisionTimeout (x10ms)
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 87c:	1f 7e       	andi	r17, 0xEF	; 239
 87e:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 880:	27 c0       	rjmp	.+78     	; 0x8d0 <_ZN3NRF7processEv+0x1a6>
			case NRF_EVT_DISPLAY_KEY:
				//RxData[2..7] A fixed 6-byte ASCII string representing the passkey
				//padded with zeros if shorter than 6 digits
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 882:	1f 7e       	andi	r17, 0xEF	; 239
 884:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 886:	24 c0       	rjmp	.+72     	; 0x8d0 <_ZN3NRF7processEv+0x1a6>
			case NRF_EVT_KEY_REQUEST:
				//RxData[2] : key requested
				//must send the SetKey command within 30 seconds after receiving this command
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 888:	1f 7e       	andi	r17, 0xEF	; 239
 88a:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 88c:	21 c0       	rjmp	.+66     	; 0x8d0 <_ZN3NRF7processEv+0x1a6>
			//Data Events:
			case NRF_EVT_DATA_CREDIT:		//0x8A
				//RxData[2]	:	number of data credits returned to the application controller
				dataCredit += RxData[2];	
 88e:	fe 01       	movw	r30, r28
 890:	ee 58       	subi	r30, 0x8E	; 142
 892:	ff 4f       	sbci	r31, 0xFF	; 255
 894:	9d 8d       	ldd	r25, Y+29	; 0x1d
 896:	80 81       	ld	r24, Z
 898:	89 0f       	add	r24, r25
 89a:	80 83       	st	Z, r24
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);			
 89c:	1f 7e       	andi	r17, 0xEF	; 239
 89e:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 8a0:	17 c0       	rjmp	.+46     	; 0x8d0 <_ZN3NRF7processEv+0x1a6>
				//RxData[2]		:	service pipe number
				//RxData[3..23]	:	Data
				
				// Fill data with RxData values
				
				for (i = 0; i< RxData[0] - 1;i++){
 8a2:	80 e0       	ldi	r24, 0x00	; 0
 8a4:	90 e0       	ldi	r25, 0x00	; 0
 8a6:	40 e0       	ldi	r20, 0x00	; 0
					data[i] = RxData[0] + 2;
 8a8:	5e 5f       	subi	r21, 0xFE	; 254
 8aa:	fe 01       	movw	r30, r28
 8ac:	e8 0f       	add	r30, r24
 8ae:	f9 1f       	adc	r31, r25
 8b0:	50 83       	st	Z, r21
				//RxData[2]		:	service pipe number
				//RxData[3..23]	:	Data
				
				// Fill data with RxData values
				
				for (i = 0; i< RxData[0] - 1;i++){
 8b2:	4f 5f       	subi	r20, 0xFF	; 255
 8b4:	84 2f       	mov	r24, r20
 8b6:	90 e0       	ldi	r25, 0x00	; 0
 8b8:	82 17       	cp	r24, r18
 8ba:	93 07       	cpc	r25, r19
 8bc:	b4 f3       	brlt	.-20     	; 0x8aa <_ZN3NRF7processEv+0x180>
				
				//set data flag in status
				status |= (1<<NRF_DATA_TO_PROCESS);
								
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 8be:	81 2f       	mov	r24, r17
 8c0:	8f 7e       	andi	r24, 0xEF	; 239
 8c2:	80 62       	ori	r24, 0x20	; 32
 8c4:	8a 8f       	std	Y+26, r24	; 0x1a
				break;
 8c6:	04 c0       	rjmp	.+8      	; 0x8d0 <_ZN3NRF7processEv+0x1a6>
			case NRF_EVT_PIPE_ERROR:
				
				//clear the NRF_WAIT_FOR_RESPONSE bit in the status register
				status &= ~(1<<NRF_WAIT_FOR_RESPONSE);
 8c8:	1f 7e       	andi	r17, 0xEF	; 239
 8ca:	1a 8f       	std	Y+26, r17	; 0x1a
				break;
 8cc:	01 c0       	rjmp	.+2      	; 0x8d0 <_ZN3NRF7processEv+0x1a6>
			default:			
				RxCount--;
 8ce:	8d 8b       	std	Y+21, r24	; 0x15
				//RxData[0] = 0x00;					
				break;
		}//end switch		
		
		//set the NRF_RX_READY bit in the status register
		status |= (1<<NRF_RX_READY);
 8d0:	8a 8d       	ldd	r24, Y+26	; 0x1a
 8d2:	80 68       	ori	r24, 0x80	; 128
 8d4:	8a 8f       	std	Y+26, r24	; 0x1a
 8d6:	20 c0       	rjmp	.+64     	; 0x918 <_ZN3NRF7processEv+0x1ee>
	else{
		//Receive Buffer doesn't contain useful data
		
		//if nRF8001 is requesting transfer, receive it
		//if we have data to send, send it
		if ((RDYN == 0) || (hasDataToSend())) {			
 8d8:	2a 9b       	sbis	0x05, 2	; 5
 8da:	05 c0       	rjmp	.+10     	; 0x8e6 <_ZN3NRF7processEv+0x1bc>
 8dc:	ce 01       	movw	r24, r28
 8de:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_ZN3NRF13hasDataToSendEv>
 8e2:	88 23       	and	r24, r24
 8e4:	c9 f0       	breq	.+50     	; 0x918 <_ZN3NRF7processEv+0x1ee>
			transferACI();
 8e6:	ce 01       	movw	r24, r28
 8e8:	0e 94 96 02 	call	0x52c	; 0x52c <_ZN3NRF11transferACIEv>
 8ec:	15 c0       	rjmp	.+42     	; 0x918 <_ZN3NRF7processEv+0x1ee>
		
	
	//setup message from services.h file loaded onto nRF8001
	if( (mode == NRF_MODE_SETUP)  && !hasDataToSend() && !waitingForResponse() ) {
		//load current line of setup msg into TX buffer
		for(int i = 0; i <= setup_msgs[initCount].buffer[0]; i++){
 8ee:	70 91 74 03 	lds	r23, 0x0374
 8f2:	61 e2       	ldi	r22, 0x21	; 33
 8f4:	76 9f       	mul	r23, r22
 8f6:	f0 01       	movw	r30, r0
 8f8:	11 24       	eor	r1, r1
 8fa:	e0 50       	subi	r30, 0x00	; 0
 8fc:	ff 4f       	sbci	r31, 0xFF	; 255
 8fe:	41 81       	ldd	r20, Z+1	; 0x01
 900:	50 e0       	ldi	r21, 0x00	; 0
 902:	fe 01       	movw	r30, r28
 904:	fb 96       	adiw	r30, 0x3b	; 59
 906:	20 e0       	ldi	r18, 0x00	; 0
 908:	30 e0       	ldi	r19, 0x00	; 0
#ifdef PROGRAMSPACE			
			TxData[i] = pgm_read_byte(&setup_msgs[initCount].buffer[i]);
#else
			TxData[i] = setup_msgs[initCount].buffer[i];
 90a:	61 e2       	ldi	r22, 0x21	; 33
 90c:	76 9f       	mul	r23, r22
 90e:	c0 01       	movw	r24, r0
 910:	11 24       	eor	r1, r1
 912:	80 50       	subi	r24, 0x00	; 0
 914:	9f 4f       	sbci	r25, 0xFF	; 255
 916:	25 cf       	rjmp	.-438    	; 0x762 <_ZN3NRF7processEv+0x38>
		if ((RDYN == 0) || (hasDataToSend())) {			
			transferACI();
			
		}
	}//else RxData
}//process
 918:	df 91       	pop	r29
 91a:	cf 91       	pop	r28
 91c:	1f 91       	pop	r17
 91e:	08 95       	ret

00000920 <_GLOBAL__sub_I_spi>:
	//(1<<MSTR)|             // Master/Slave select
	//(0<<SPR1)|(1<<SPR0)|   // SPI Clock Rate
	//(0<<CPOL)|             // Clock Polarity (0:SCK low / 1:SCK hi when idle)
	//(0<<CPHA))             // Clock Phase (0:leading / 1:trailing edge sampling)

SPI spi(SPI_SETTING);
 920:	63 e7       	ldi	r22, 0x73	; 115
 922:	85 e7       	ldi	r24, 0x75	; 117
 924:	93 e0       	ldi	r25, 0x03	; 3
 926:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <_ZN3SPIC1Eh>
 92a:	08 95       	ret

0000092c <_ZN6TIMER1C1Ehhj>:
TIMER1::TIMER1(){
	TIMER1(TIMER_DIV1, 0, 0);
}

///@brief initialize AD converter on Atmega168 for
TIMER1::TIMER1(uint8_t pscalar, uint8_t WGMmode, uint16_t rload){
 92c:	fc 01       	movw	r30, r24
	reload = rload;
 92e:	33 83       	std	Z+3, r19	; 0x03
 930:	22 83       	std	Z+2, r18	; 0x02
	mode = WGMmode;
 932:	41 83       	std	Z+1, r20	; 0x01
	prescalar = pscalar;
 934:	60 83       	st	Z, r22
	
	// The PRTIM1 bit in the Power reduction register must be written to zero to enable Timer/Counter1 module.
	PRR &= ~(1<<PRTIM1);
 936:	a4 e6       	ldi	r26, 0x64	; 100
 938:	b0 e0       	ldi	r27, 0x00	; 0
 93a:	8c 91       	ld	r24, X
 93c:	87 7f       	andi	r24, 0xF7	; 247
 93e:	8c 93       	st	X, r24
	
	//disable timer1
	TCCR1B = 0x00;
 940:	10 92 81 00 	sts	0x0081, r1
	
	//clear counter	
	TCNT1 = 0;
 944:	10 92 85 00 	sts	0x0085, r1
 948:	10 92 84 00 	sts	0x0084, r1
	
	//set reload value
	if (mode == 4) OCR1A = reload;
 94c:	81 81       	ldd	r24, Z+1	; 0x01
 94e:	84 30       	cpi	r24, 0x04	; 4
 950:	31 f4       	brne	.+12     	; 0x95e <_ZN6TIMER1C1Ehhj+0x32>
 952:	82 81       	ldd	r24, Z+2	; 0x02
 954:	93 81       	ldd	r25, Z+3	; 0x03
 956:	90 93 89 00 	sts	0x0089, r25
 95a:	80 93 88 00 	sts	0x0088, r24
	if (mode == 12) ICR1 = reload;
 95e:	81 81       	ldd	r24, Z+1	; 0x01
 960:	8c 30       	cpi	r24, 0x0C	; 12
 962:	31 f4       	brne	.+12     	; 0x970 <_ZN6TIMER1C1Ehhj+0x44>
 964:	82 81       	ldd	r24, Z+2	; 0x02
 966:	93 81       	ldd	r25, Z+3	; 0x03
 968:	90 93 87 00 	sts	0x0087, r25
 96c:	80 93 86 00 	sts	0x0086, r24
	if (mode == 0) TCNT1 = reload;
 970:	81 81       	ldd	r24, Z+1	; 0x01
 972:	81 11       	cpse	r24, r1
 974:	06 c0       	rjmp	.+12     	; 0x982 <_ZN6TIMER1C1Ehhj+0x56>
 976:	82 81       	ldd	r24, Z+2	; 0x02
 978:	93 81       	ldd	r25, Z+3	; 0x03
 97a:	90 93 85 00 	sts	0x0085, r25
 97e:	80 93 84 00 	sts	0x0084, r24
	
	//setup and enable timer
	TCCR1A = (mode & 0x03);		//normal timer operation, no PWM, etc
 982:	81 81       	ldd	r24, Z+1	; 0x01
 984:	83 70       	andi	r24, 0x03	; 3
 986:	80 93 80 00 	sts	0x0080, r24
	//TCCR1B = ((mode & 0x0C)<<WGM12) | (prescalar << CS10);
	TCCR1C = 0x00;		//force output compare off	
 98a:	10 92 82 00 	sts	0x0082, r1
 98e:	08 95       	ret

00000990 <_ZN6TIMER15startEv>:
	//sei();
}

void	TIMER1::start(void)
{
	TCCR1B = ((mode & 0x0C)<<WGM12) | (prescalar << CS10);
 990:	fc 01       	movw	r30, r24
 992:	21 81       	ldd	r18, Z+1	; 0x01
 994:	2c 70       	andi	r18, 0x0C	; 12
 996:	22 0f       	add	r18, r18
 998:	22 0f       	add	r18, r18
 99a:	22 0f       	add	r18, r18
 99c:	90 81       	ld	r25, Z
 99e:	82 2f       	mov	r24, r18
 9a0:	89 2b       	or	r24, r25
 9a2:	80 93 81 00 	sts	0x0081, r24
 9a6:	08 95       	ret

000009a8 <_ZN6TIMER117isCompareAFlagSetEv>:
	return ((TIFR1 & 1<<TOV1)? 1:0);
	//return ((EIFR & 1<< INTF0)?1:0);
}

uint8_t TIMER1::isCompareAFlagSet(){
	return ((TIFR1 & 1<<OCF1A)? 1:0);
 9a8:	86 b3       	in	r24, 0x16	; 22
	
}
 9aa:	86 95       	lsr	r24
 9ac:	81 70       	andi	r24, 0x01	; 1
 9ae:	08 95       	ret

000009b0 <_ZN6TIMER117clearCompareAFlagEv>:
	
	//EIFR = (1<<INTF0);		//Reset flag
}

void	TIMER1::clearCompareAFlag(){
	TIFR1 |= (1<<OCF1A);
 9b0:	b1 9a       	sbi	0x16, 1	; 22
 9b2:	08 95       	ret

000009b4 <_ZN6TIMER18setCountEj>:
	
	//EIFR = (1<<INTF0);		//Reset flag
}

void	TIMER1::setCount(uint16_t count){
	TCNT1 = count;
 9b4:	70 93 85 00 	sts	0x0085, r23
 9b8:	60 93 84 00 	sts	0x0084, r22
 9bc:	08 95       	ret

000009be <main>:
//  3. SLEEP;
//	4. After waking, DisableSleep()

#pragma endregion sleep

int main(void){	
 9be:	cf 93       	push	r28
 9c0:	df 93       	push	r29
 9c2:	cd b7       	in	r28, 0x3d	; 61
 9c4:	de b7       	in	r29, 0x3e	; 62
 9c6:	2d 97       	sbiw	r28, 0x0d	; 13
 9c8:	0f b6       	in	r0, 0x3f	; 63
 9ca:	f8 94       	cli
 9cc:	de bf       	out	0x3e, r29	; 62
 9ce:	0f be       	out	0x3f, r0	; 63
 9d0:	cd bf       	out	0x3d, r28	; 61
	//timer
	// 8MHz/90Hz			= 88,888.8888 cycles to count
	// 88,888.888 / 8 (div8)	= 11,111 = 0x2B67
	
	//prescalar, mode, reload
	TIMER1 timer(TIMER_DIV8, 4, 0x2B67);
 9d2:	27 e6       	ldi	r18, 0x67	; 103
 9d4:	3b e2       	ldi	r19, 0x2B	; 43
 9d6:	44 e0       	ldi	r20, 0x04	; 4
 9d8:	62 e0       	ldi	r22, 0x02	; 2
 9da:	ce 01       	movw	r24, r28
 9dc:	08 96       	adiw	r24, 0x08	; 8
 9de:	0e 94 96 04 	call	0x92c	; 0x92c <_ZN6TIMER1C1Ehhj>
	
	//pin, prescalar
	ANALOG sensor(ADC_PIN, ADC_DIV64);
 9e2:	46 e0       	ldi	r20, 0x06	; 6
 9e4:	60 e0       	ldi	r22, 0x00	; 0
 9e6:	ce 01       	movw	r24, r28
 9e8:	0c 96       	adiw	r24, 0x0c	; 12
 9ea:	0e 94 b1 00 	call	0x162	; 0x162 <_ZN6ANALOGC1Ehh>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 9ee:	2f ef       	ldi	r18, 0xFF	; 255
 9f0:	84 e3       	ldi	r24, 0x34	; 52
 9f2:	9c e0       	ldi	r25, 0x0C	; 12
 9f4:	21 50       	subi	r18, 0x01	; 1
 9f6:	80 40       	sbci	r24, 0x00	; 0
 9f8:	90 40       	sbci	r25, 0x00	; 0
 9fa:	e1 f7       	brne	.-8      	; 0x9f4 <main+0x36>
 9fc:	00 c0       	rjmp	.+0      	; 0x9fe <main+0x40>
 9fe:	00 00       	nop
#endif
	
	_delay_ms(500);
	
	//d6,d7 - LEDs
	DDRD = 0xC0;			//set PD7:6 to outputs for LEDs
 a00:	80 ec       	ldi	r24, 0xC0	; 192
 a02:	8a b9       	out	0x0a, r24	; 10
	//PD2 as an input for switch
	RED_ON;					//Set PD7 high and PD6 low
 a04:	8b b1       	in	r24, 0x0b	; 11
 a06:	8f 73       	andi	r24, 0x3F	; 63
 a08:	80 68       	ori	r24, 0x80	; 128
 a0a:	8b b9       	out	0x0b, r24	; 11
	
	//Switch
	PORTD |= (1<<PD2);		//set PD2 to high(pullup resistor) for switch
 a0c:	5a 9a       	sbi	0x0b, 2	; 11
	
	//External Interrupt Mask Register
	EIMSK |= (1<<INT0);	//turn on interrupt 0 (PD2)
 a0e:	e8 9a       	sbi	0x1d, 0	; 29
	
	////External Interrupt Control Register A
	//EICRA = 0x02;		//Interrupt on falling edge of INT0
	EICRA = 0x00;		//Interrupt on low level of INT0
 a10:	10 92 69 00 	sts	0x0069, r1
	
	//opamp is Powered Down when PD is low, initialize HIGH?
	//250nS delay when powering up, 50nS delay when powering down (1/8MHz = 125nS)
	WakeOpAmp();
 a14:	41 9a       	sbi	0x08, 1	; 8
	sensor.clearFlag();
 a16:	ce 01       	movw	r24, r28
 a18:	0c 96       	adiw	r24, 0x0c	; 12
 a1a:	0e 94 c6 00 	call	0x18c	; 0x18c <_ZN6ANALOG9clearFlagEv>
 a1e:	ef ef       	ldi	r30, 0xFF	; 255
 a20:	f4 e3       	ldi	r31, 0x34	; 52
 a22:	2c e0       	ldi	r18, 0x0C	; 12
 a24:	e1 50       	subi	r30, 0x01	; 1
 a26:	f0 40       	sbci	r31, 0x00	; 0
 a28:	20 40       	sbci	r18, 0x00	; 0
 a2a:	e1 f7       	brne	.-8      	; 0xa24 <main+0x66>
 a2c:	00 c0       	rjmp	.+0      	; 0xa2e <main+0x70>
 a2e:	00 00       	nop
	enum lights_t {I,R,O} led_state = R;
		 
	state_t state = INIT;
	uint8_t oxygenSaturationData[PIPE_OXYGEN_SATURATION_O2_SET_MAX_SIZE];// = {0,1,2,3,4,5,6};
	uint8_t count = 0;
	uint8_t settings = 0x00;
 a30:	91 2c       	mov	r9, r1
	ANALOG sensor(ADC_PIN, ADC_DIV64);
	
	enum state_t {INIT = 0x00, CONNECT, CONNECTING, SEND, RECEIVE, IDLE, GO2SLEEP, WAKEUP};
	enum lights_t {I,R,O} led_state = R;
		 
	state_t state = INIT;
 a32:	81 2c       	mov	r8, r1
	
	//pin, prescalar
	ANALOG sensor(ADC_PIN, ADC_DIV64);
	
	enum state_t {INIT = 0x00, CONNECT, CONNECTING, SEND, RECEIVE, IDLE, GO2SLEEP, WAKEUP};
	enum lights_t {I,R,O} led_state = R;
 a34:	22 24       	eor	r2, r2
 a36:	23 94       	inc	r2
			if (nrf.data[0] == PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX){
				settings = nrf.data[1];				
			}
			nrf.dataHasBeenProcessed();
			if (settings == PULSEOX_GO_TO_SLEEP)
				state = GO2SLEEP;
 a38:	0f 2e       	mov	r0, r31
 a3a:	f6 e0       	ldi	r31, 0x06	; 6
 a3c:	7f 2e       	mov	r7, r31
 a3e:	f0 2d       	mov	r31, r0
#endif	
	
	while(1){		
		if (nrf.hasDataToProcess()){
			if (nrf.data[0] == PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX){
				settings = nrf.data[1];				
 a40:	0f 2e       	mov	r0, r31
 a42:	f8 e7       	ldi	r31, 0x78	; 120
 a44:	ef 2e       	mov	r14, r31
 a46:	f3 e0       	ldi	r31, 0x03	; 3
 a48:	ff 2e       	mov	r15, r31
 a4a:	f0 2d       	mov	r31, r0
			nrf.dataHasBeenProcessed();
			if (settings == PULSEOX_GO_TO_SLEEP)
				state = GO2SLEEP;
		}
		
		if (nrf.mode == NRF_MODE_STANDBY){			
 a4c:	08 ee       	ldi	r16, 0xE8	; 232
 a4e:	13 e0       	ldi	r17, 0x03	; 3
					RED_ON;
					//wakeup opamp
					WakeOpAmp();
					//wakeup nrf
					nrf.wakeup();
					state = CONNECT;
 a50:	55 24       	eor	r5, r5
 a52:	53 94       	inc	r5
#define SLEEP_MODE_STANDBY		0b110
#define EnableSleep() 			SMCR |= (1<<SE)
#define DisableSleep()			SMCR &= ~(1<<SE)
void SetSleepMode(uint8_t mode){
	if((mode == SLEEP_MODE_STANDBY) | (mode<=SLEEP_MODE_POWER_SAVE))
	SMCR = (mode<<SM0);
 a54:	68 94       	set
 a56:	33 24       	eor	r3, r3
 a58:	32 f8       	bld	r3, 2
									oxygenSaturationData[6*count+5] = ADCH;
									RED_ON;
									led_state = R;
									break;
								case R:
									oxygenSaturationData[6*count+2] = ADCL;
 a5a:	0f 2e       	mov	r0, r31
 a5c:	f8 e7       	ldi	r31, 0x78	; 120
 a5e:	af 2e       	mov	r10, r31
 a60:	b1 2c       	mov	r11, r1
 a62:	f0 2d       	mov	r31, r0
									oxygenSaturationData[6*count+1] = ADCH;
 a64:	0f 2e       	mov	r0, r31
 a66:	f9 e7       	ldi	r31, 0x79	; 121
 a68:	cf 2e       	mov	r12, r31
 a6a:	d1 2c       	mov	r13, r1
 a6c:	f0 2d       	mov	r31, r0
									IR_ON;
									led_state = I;
 a6e:	61 2c       	mov	r6, r1
							switch(led_state){
								case I:
									oxygenSaturationData[6*count+4] = ADCL;
									oxygenSaturationData[6*count+3] = ADCH;
									LEDS_OFF;
									led_state = O;
 a70:	68 94       	set
 a72:	44 24       	eor	r4, r4
 a74:	41 f8       	bld	r4, 1
#ifdef TESTMODE	
	lcdClearDisplay();
#endif	
	
	while(1){		
		if (nrf.hasDataToProcess()){
 a76:	87 e7       	ldi	r24, 0x77	; 119
 a78:	93 e0       	ldi	r25, 0x03	; 3
 a7a:	0e 94 0f 01 	call	0x21e	; 0x21e <_ZN3NRF16hasDataToProcessEv>
 a7e:	88 23       	and	r24, r24
 a80:	71 f0       	breq	.+28     	; 0xa9e <main+0xe0>
			if (nrf.data[0] == PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX){
 a82:	80 91 77 03 	lds	r24, 0x0377
 a86:	82 30       	cpi	r24, 0x02	; 2
 a88:	11 f4       	brne	.+4      	; 0xa8e <main+0xd0>
				settings = nrf.data[1];				
 a8a:	f7 01       	movw	r30, r14
 a8c:	90 80       	ld	r9, Z
			}
			nrf.dataHasBeenProcessed();
 a8e:	87 e7       	ldi	r24, 0x77	; 119
 a90:	93 e0       	ldi	r25, 0x03	; 3
 a92:	0e 94 15 01 	call	0x22a	; 0x22a <_ZN3NRF20dataHasBeenProcessedEv>
			if (settings == PULSEOX_GO_TO_SLEEP)
 a96:	f1 e0       	ldi	r31, 0x01	; 1
 a98:	9f 12       	cpse	r9, r31
 a9a:	01 c0       	rjmp	.+2      	; 0xa9e <main+0xe0>
				state = GO2SLEEP;
 a9c:	87 2c       	mov	r8, r7
		}
		
		if (nrf.mode == NRF_MODE_STANDBY){			
 a9e:	f8 01       	movw	r30, r16
 aa0:	80 81       	ld	r24, Z
 aa2:	83 30       	cpi	r24, 0x03	; 3
 aa4:	09 f0       	breq	.+2      	; 0xaa8 <main+0xea>
 aa6:	dc c0       	rjmp	.+440    	; 0xc60 <main+0x2a2>
			if(buttonWasPressed){
 aa8:	80 91 76 03 	lds	r24, 0x0376
 aac:	88 23       	and	r24, r24
 aae:	31 f0       	breq	.+12     	; 0xabc <main+0xfe>
				buttonWasPressed = false;
 ab0:	60 92 76 03 	sts	0x0376, r6
				if (state == GO2SLEEP){
 ab4:	f6 e0       	ldi	r31, 0x06	; 6
 ab6:	8f 12       	cpse	r8, r31
 ab8:	9b c0       	rjmp	.+310    	; 0xbf0 <main+0x232>
 aba:	ba c0       	rjmp	.+372    	; 0xc30 <main+0x272>
				}else{
					state = GO2SLEEP;
				}
			}
			
			switch (state){
 abc:	88 2d       	mov	r24, r8
 abe:	90 e0       	ldi	r25, 0x00	; 0
 ac0:	fc 01       	movw	r30, r24
 ac2:	ef 59       	subi	r30, 0x9F	; 159
 ac4:	ff 4f       	sbci	r31, 0xFF	; 255
 ac6:	0c 94 5d 06 	jmp	0xcba	; 0xcba <__tablejump2__>
				case INIT:	//initializing
					if (!nrf.isInitializing()){
 aca:	87 e7       	ldi	r24, 0x77	; 119
 acc:	93 e0       	ldi	r25, 0x03	; 3
 ace:	0e 94 f5 00 	call	0x1ea	; 0x1ea <_ZN3NRF14isInitializingEv>
 ad2:	81 11       	cpse	r24, r1
 ad4:	c5 c0       	rjmp	.+394    	; 0xc60 <main+0x2a2>
						timer.start();
 ad6:	ce 01       	movw	r24, r28
 ad8:	08 96       	adiw	r24, 0x08	; 8
 ada:	0e 94 c8 04 	call	0x990	; 0x990 <_ZN6TIMER15startEv>
						sei();				
 ade:	78 94       	sei
						state = GO2SLEEP;
 ae0:	87 2c       	mov	r8, r7
 ae2:	be c0       	rjmp	.+380    	; 0xc60 <main+0x2a2>
					//_delay_ms(25);
#endif
					break;				
					
				case CONNECT:	//connect
					if (nrf.connect(180,0x0100) == 0x00)
 ae4:	40 e0       	ldi	r20, 0x00	; 0
 ae6:	51 e0       	ldi	r21, 0x01	; 1
 ae8:	64 eb       	ldi	r22, 0xB4	; 180
 aea:	70 e0       	ldi	r23, 0x00	; 0
 aec:	87 e7       	ldi	r24, 0x77	; 119
 aee:	93 e0       	ldi	r25, 0x03	; 3
 af0:	0e 94 57 02 	call	0x4ae	; 0x4ae <_ZN3NRF7connectEjj>
 af4:	88 23       	and	r24, r24
 af6:	09 f4       	brne	.+2      	; 0xafa <main+0x13c>
 af8:	a9 c0       	rjmp	.+338    	; 0xc4c <main+0x28e>
 afa:	b2 c0       	rjmp	.+356    	; 0xc60 <main+0x2a2>
						state = CONNECTING;
					break;				
				
				case CONNECTING:	
					if (nrf.isConnected())
 afc:	87 e7       	ldi	r24, 0x77	; 119
 afe:	93 e0       	ldi	r25, 0x03	; 3
 b00:	0e 94 09 01 	call	0x212	; 0x212 <_ZN3NRF11isConnectedEv>
 b04:	81 11       	cpse	r24, r1
 b06:	a4 c0       	rjmp	.+328    	; 0xc50 <main+0x292>
 b08:	ab c0       	rjmp	.+342    	; 0xc60 <main+0x2a2>
						state = IDLE;
					break;
					
				case SEND:					
					if (0x00 == nrf.setLocalData(PIPE_OXYGEN_SATURATION_O2_SET, oxygenSaturationData, PIPE_OXYGEN_SATURATION_O2_SET_MAX_SIZE)){						
 b0a:	27 e0       	ldi	r18, 0x07	; 7
 b0c:	ae 01       	movw	r20, r28
 b0e:	4f 5f       	subi	r20, 0xFF	; 255
 b10:	5f 4f       	sbci	r21, 0xFF	; 255
 b12:	65 2d       	mov	r22, r5
 b14:	87 e7       	ldi	r24, 0x77	; 119
 b16:	93 e0       	ldi	r25, 0x03	; 3
 b18:	0e 94 13 02 	call	0x426	; 0x426 <_ZN3NRF12setLocalDataEhPhh>
 b1c:	81 11       	cpse	r24, r1
 b1e:	a0 c0       	rjmp	.+320    	; 0xc60 <main+0x2a2>
						oxygenSaturationData[0]++;									
 b20:	89 81       	ldd	r24, Y+1	; 0x01
 b22:	8f 5f       	subi	r24, 0xFF	; 255
 b24:	89 83       	std	Y+1, r24	; 0x01
						state = IDLE;	
 b26:	0f 2e       	mov	r0, r31
 b28:	f5 e0       	ldi	r31, 0x05	; 5
 b2a:	8f 2e       	mov	r8, r31
 b2c:	f0 2d       	mov	r31, r0
 b2e:	98 c0       	rjmp	.+304    	; 0xc60 <main+0x2a2>
					}					
					break;
				
				case RECEIVE:
					nrf.requestData(PIPE_MODIFY_SETTINGS_PULSEOX_SETTING_RX);
 b30:	64 2d       	mov	r22, r4
 b32:	87 e7       	ldi	r24, 0x77	; 119
 b34:	93 e0       	ldi	r25, 0x03	; 3
 b36:	0e 94 a2 01 	call	0x344	; 0x344 <_ZN3NRF11requestDataEh>
					state = IDLE;
 b3a:	0f 2e       	mov	r0, r31
 b3c:	f5 e0       	ldi	r31, 0x05	; 5
 b3e:	8f 2e       	mov	r8, r31
 b40:	f0 2d       	mov	r31, r0
					break;				
 b42:	8e c0       	rjmp	.+284    	; 0xc60 <main+0x2a2>
																
				case IDLE:		//idle
					if(!nrf.isConnected()){
 b44:	87 e7       	ldi	r24, 0x77	; 119
 b46:	93 e0       	ldi	r25, 0x03	; 3
 b48:	0e 94 09 01 	call	0x212	; 0x212 <_ZN3NRF11isConnectedEv>
 b4c:	88 23       	and	r24, r24
 b4e:	09 f4       	brne	.+2      	; 0xb52 <main+0x194>
 b50:	84 c0       	rjmp	.+264    	; 0xc5a <main+0x29c>
						state = GO2SLEEP;
					}else {
						if (timer.isCompareAFlagSet()){
 b52:	ce 01       	movw	r24, r28
 b54:	08 96       	adiw	r24, 0x08	; 8
 b56:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <_ZN6TIMER117isCompareAFlagSetEv>
 b5a:	88 23       	and	r24, r24
 b5c:	71 f0       	breq	.+28     	; 0xb7a <main+0x1bc>
							timer.clearCompareAFlag();
 b5e:	ce 01       	movw	r24, r28
 b60:	08 96       	adiw	r24, 0x08	; 8
 b62:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <_ZN6TIMER117clearCompareAFlagEv>
							timer.setCount(0);
 b66:	60 e0       	ldi	r22, 0x00	; 0
 b68:	70 e0       	ldi	r23, 0x00	; 0
 b6a:	ce 01       	movw	r24, r28
 b6c:	08 96       	adiw	r24, 0x08	; 8
 b6e:	0e 94 da 04 	call	0x9b4	; 0x9b4 <_ZN6TIMER18setCountEj>
							sensor.start();
 b72:	ce 01       	movw	r24, r28
 b74:	0c 96       	adiw	r24, 0x0c	; 12
 b76:	0e 94 b7 00 	call	0x16e	; 0x16e <_ZN6ANALOG5startEv>
 						}//if
 					
 						if (sensor.isInterruptFlagSet()){
 b7a:	ce 01       	movw	r24, r28
 b7c:	0c 96       	adiw	r24, 0x0c	; 12
 b7e:	0e 94 c2 00 	call	0x184	; 0x184 <_ZN6ANALOG18isInterruptFlagSetEv>
 b82:	88 23       	and	r24, r24
 b84:	09 f4       	brne	.+2      	; 0xb88 <main+0x1ca>
 b86:	6c c0       	rjmp	.+216    	; 0xc60 <main+0x2a2>
							sensor.clearFlag();
 b88:	ce 01       	movw	r24, r28
 b8a:	0c 96       	adiw	r24, 0x0c	; 12
 b8c:	0e 94 c6 00 	call	0x18c	; 0x18c <_ZN6ANALOG9clearFlagEv>
							switch(led_state){
 b90:	21 e0       	ldi	r18, 0x01	; 1
 b92:	22 16       	cp	r2, r18
 b94:	e9 f0       	breq	.+58     	; 0xbd0 <main+0x212>
 b96:	22 16       	cp	r2, r18
 b98:	20 f0       	brcs	.+8      	; 0xba2 <main+0x1e4>
 b9a:	82 e0       	ldi	r24, 0x02	; 2
 b9c:	28 16       	cp	r2, r24
 b9e:	61 f0       	breq	.+24     	; 0xbb8 <main+0x1fa>
 ba0:	5f c0       	rjmp	.+190    	; 0xc60 <main+0x2a2>
								case I:
									oxygenSaturationData[6*count+4] = ADCL;
 ba2:	f5 01       	movw	r30, r10
 ba4:	80 81       	ld	r24, Z
 ba6:	8d 83       	std	Y+5, r24	; 0x05
									oxygenSaturationData[6*count+3] = ADCH;
 ba8:	f6 01       	movw	r30, r12
 baa:	80 81       	ld	r24, Z
 bac:	8c 83       	std	Y+4, r24	; 0x04
									LEDS_OFF;
 bae:	8b b1       	in	r24, 0x0b	; 11
 bb0:	8f 73       	andi	r24, 0x3F	; 63
 bb2:	8b b9       	out	0x0b, r24	; 11
									led_state = O;
 bb4:	24 2c       	mov	r2, r4
									break;
 bb6:	54 c0       	rjmp	.+168    	; 0xc60 <main+0x2a2>
								case O:
									oxygenSaturationData[6*count+6] = ADCL;
 bb8:	f5 01       	movw	r30, r10
 bba:	80 81       	ld	r24, Z
 bbc:	8f 83       	std	Y+7, r24	; 0x07
									oxygenSaturationData[6*count+5] = ADCH;
 bbe:	f6 01       	movw	r30, r12
 bc0:	80 81       	ld	r24, Z
 bc2:	8e 83       	std	Y+6, r24	; 0x06
									RED_ON;
 bc4:	8b b1       	in	r24, 0x0b	; 11
 bc6:	8f 73       	andi	r24, 0x3F	; 63
 bc8:	80 68       	ori	r24, 0x80	; 128
 bca:	8b b9       	out	0x0b, r24	; 11
									led_state = R;
 bcc:	25 2c       	mov	r2, r5
									break;
 bce:	48 c0       	rjmp	.+144    	; 0xc60 <main+0x2a2>
								case R:
									oxygenSaturationData[6*count+2] = ADCL;
 bd0:	f5 01       	movw	r30, r10
 bd2:	80 81       	ld	r24, Z
 bd4:	8b 83       	std	Y+3, r24	; 0x03
									oxygenSaturationData[6*count+1] = ADCH;
 bd6:	f6 01       	movw	r30, r12
 bd8:	80 81       	ld	r24, Z
 bda:	8a 83       	std	Y+2, r24	; 0x02
									IR_ON;
 bdc:	8b b1       	in	r24, 0x0b	; 11
 bde:	8f 73       	andi	r24, 0x3F	; 63
 be0:	80 64       	ori	r24, 0x40	; 64
 be2:	8b b9       	out	0x0b, r24	; 11
									led_state = I;
									if (++count == NUM_QUEUE){
										count = 0;
										state = SEND;
 be4:	0f 2e       	mov	r0, r31
 be6:	f3 e0       	ldi	r31, 0x03	; 3
 be8:	8f 2e       	mov	r8, r31
 bea:	f0 2d       	mov	r31, r0
									break;
								case R:
									oxygenSaturationData[6*count+2] = ADCL;
									oxygenSaturationData[6*count+1] = ADCH;
									IR_ON;
									led_state = I;
 bec:	26 2c       	mov	r2, r6
 bee:	38 c0       	rjmp	.+112    	; 0xc60 <main+0x2a2>
							} //switch(led_state)
						} //if (sensor.isInterruptFlagSet())						
					}	
					break;
				case GO2SLEEP:
					LEDS_OFF;
 bf0:	8b b1       	in	r24, 0x0b	; 11
 bf2:	8f 73       	andi	r24, 0x3F	; 63
 bf4:	8b b9       	out	0x0b, r24	; 11
					//TODO: shut down opamp
					SleepOpAmp();
 bf6:	41 98       	cbi	0x08, 1	; 8
					//disconnect
					if (nrf.isConnected())
 bf8:	87 e7       	ldi	r24, 0x77	; 119
 bfa:	93 e0       	ldi	r25, 0x03	; 3
 bfc:	0e 94 09 01 	call	0x212	; 0x212 <_ZN3NRF11isConnectedEv>
 c00:	88 23       	and	r24, r24
 c02:	29 f0       	breq	.+10     	; 0xc0e <main+0x250>
						nrf.disconnect(0x01);
 c04:	65 2d       	mov	r22, r5
 c06:	87 e7       	ldi	r24, 0x77	; 119
 c08:	93 e0       	ldi	r25, 0x03	; 3
 c0a:	0e 94 91 01 	call	0x322	; 0x322 <_ZN3NRF10disconnectEh>
					
					if (!nrf.isConnected()){
 c0e:	87 e7       	ldi	r24, 0x77	; 119
 c10:	93 e0       	ldi	r25, 0x03	; 3
 c12:	0e 94 09 01 	call	0x212	; 0x212 <_ZN3NRF11isConnectedEv>
 c16:	81 11       	cpse	r24, r1
 c18:	22 c0       	rjmp	.+68     	; 0xc5e <main+0x2a0>
						//put nrf to sleep
						nrf.sleep();	
 c1a:	87 e7       	ldi	r24, 0x77	; 119
 c1c:	93 e0       	ldi	r25, 0x03	; 3
 c1e:	0e 94 4f 02 	call	0x49e	; 0x49e <_ZN3NRF5sleepEv>
#define SLEEP_MODE_STANDBY		0b110
#define EnableSleep() 			SMCR |= (1<<SE)
#define DisableSleep()			SMCR &= ~(1<<SE)
void SetSleepMode(uint8_t mode){
	if((mode == SLEEP_MODE_STANDBY) | (mode<=SLEEP_MODE_POWER_SAVE))
	SMCR = (mode<<SM0);
 c22:	33 be       	out	0x33, r3	; 51
					if (!nrf.isConnected()){
						//put nrf to sleep
						nrf.sleep();	
						//put uC to sleep							
						SetSleepMode(SLEEP_MODE_POWER_DOWN);
						EnableSleep();
 c24:	83 b7       	in	r24, 0x33	; 51
 c26:	81 60       	ori	r24, 0x01	; 1
 c28:	83 bf       	out	0x33, r24	; 51
						__asm__ __volatile__ ("sleep" ::);
 c2a:	88 95       	sleep
 c2c:	87 2c       	mov	r8, r7
 c2e:	18 c0       	rjmp	.+48     	; 0xc60 <main+0x2a2>
					}
					break;
				case WAKEUP:
					DisableSleep();					
 c30:	83 b7       	in	r24, 0x33	; 51
 c32:	8e 7f       	andi	r24, 0xFE	; 254
 c34:	83 bf       	out	0x33, r24	; 51
					RED_ON;
 c36:	8b b1       	in	r24, 0x0b	; 11
 c38:	8f 73       	andi	r24, 0x3F	; 63
 c3a:	80 68       	ori	r24, 0x80	; 128
 c3c:	8b b9       	out	0x0b, r24	; 11
					//wakeup opamp
					WakeOpAmp();
 c3e:	41 9a       	sbi	0x08, 1	; 8
					//wakeup nrf
					nrf.wakeup();
 c40:	87 e7       	ldi	r24, 0x77	; 119
 c42:	93 e0       	ldi	r25, 0x03	; 3
 c44:	0e 94 53 02 	call	0x4a6	; 0x4a6 <_ZN3NRF6wakeupEv>
					state = CONNECT;
 c48:	85 2c       	mov	r8, r5
					break;
 c4a:	0a c0       	rjmp	.+20     	; 0xc60 <main+0x2a2>
#endif
					break;				
					
				case CONNECT:	//connect
					if (nrf.connect(180,0x0100) == 0x00)
						state = CONNECTING;
 c4c:	84 2c       	mov	r8, r4
 c4e:	08 c0       	rjmp	.+16     	; 0xc60 <main+0x2a2>
					break;				
				
				case CONNECTING:	
					if (nrf.isConnected())
						state = IDLE;
 c50:	0f 2e       	mov	r0, r31
 c52:	f5 e0       	ldi	r31, 0x05	; 5
 c54:	8f 2e       	mov	r8, r31
 c56:	f0 2d       	mov	r31, r0
 c58:	03 c0       	rjmp	.+6      	; 0xc60 <main+0x2a2>
					state = IDLE;
					break;				
																
				case IDLE:		//idle
					if(!nrf.isConnected()){
						state = GO2SLEEP;
 c5a:	87 2c       	mov	r8, r7
 c5c:	01 c0       	rjmp	.+2      	; 0xc60 <main+0x2a2>
 c5e:	87 2c       	mov	r8, r7
		//display
		//sprintf(line1, " %02X%02X %02X %02X%02X ", nrf.RxCount, nrf.dataCredit, state, nrf.status, nrf.mode);
		sprintf(line2, "%02X%02X %02X %02X%02X ", nrf.RxCount, /*nrf.dataCredit,*/ state, nrf.status, nrf.mode, nrf.lastCommand);
		displayLCD();
#else
		if (nrf.mode == NRF_MODE_SETUP)
 c60:	f8 01       	movw	r30, r16
 c62:	80 81       	ld	r24, Z
 c64:	82 30       	cpi	r24, 0x02	; 2
 c66:	31 f4       	brne	.+12     	; 0xc74 <main+0x2b6>
 c68:	8f e2       	ldi	r24, 0x2F	; 47
 c6a:	95 e7       	ldi	r25, 0x75	; 117
 c6c:	01 97       	sbiw	r24, 0x01	; 1
 c6e:	f1 f7       	brne	.-4      	; 0xc6c <main+0x2ae>
 c70:	00 c0       	rjmp	.+0      	; 0xc72 <main+0x2b4>
 c72:	00 00       	nop
			_delay_ms(15);
#endif			
		nrf.process();		
 c74:	87 e7       	ldi	r24, 0x77	; 119
 c76:	93 e0       	ldi	r25, 0x03	; 3
 c78:	0e 94 95 03 	call	0x72a	; 0x72a <_ZN3NRF7processEv>
	}//while 1
 c7c:	fc ce       	rjmp	.-520    	; 0xa76 <main+0xb8>

00000c7e <__vector_1>:
}//main

ISR(INT0_vect){
 c7e:	1f 92       	push	r1
 c80:	0f 92       	push	r0
 c82:	0f b6       	in	r0, 0x3f	; 63
 c84:	0f 92       	push	r0
 c86:	11 24       	eor	r1, r1
 c88:	8f 93       	push	r24
 c8a:	9f 93       	push	r25
 c8c:	8f e0       	ldi	r24, 0x0F	; 15
 c8e:	97 e2       	ldi	r25, 0x27	; 39
 c90:	01 97       	sbiw	r24, 0x01	; 1
 c92:	f1 f7       	brne	.-4      	; 0xc90 <__vector_1+0x12>
 c94:	00 c0       	rjmp	.+0      	; 0xc96 <__vector_1+0x18>
 c96:	00 00       	nop
	//to debounce switch, wait 5ms, then check for low condition again
	_delay_ms(5);
	if (!(PIND & (1<<PD2)))
 c98:	4a 99       	sbic	0x09, 2	; 9
 c9a:	03 c0       	rjmp	.+6      	; 0xca2 <__vector_1+0x24>
	buttonWasPressed = true;
 c9c:	81 e0       	ldi	r24, 0x01	; 1
 c9e:	80 93 76 03 	sts	0x0376, r24
	
}
 ca2:	9f 91       	pop	r25
 ca4:	8f 91       	pop	r24
 ca6:	0f 90       	pop	r0
 ca8:	0f be       	out	0x3f, r0	; 63
 caa:	0f 90       	pop	r0
 cac:	1f 90       	pop	r1
 cae:	18 95       	reti

00000cb0 <_GLOBAL__sub_I_nrf>:

//size of pipe in settings.h sets size of queue, which is how many times we read
//the data before we send
#define NUM_QUEUE ((PIPE_OXYGEN_SATURATION_O2_SET_MAX_SIZE-1)/6)

NRF nrf;
 cb0:	87 e7       	ldi	r24, 0x77	; 119
 cb2:	93 e0       	ldi	r25, 0x03	; 3
 cb4:	0e 94 29 01 	call	0x252	; 0x252 <_ZN3NRFC1Ev>
 cb8:	08 95       	ret

00000cba <__tablejump2__>:
 cba:	ee 0f       	add	r30, r30
 cbc:	ff 1f       	adc	r31, r31

00000cbe <__tablejump__>:
 cbe:	05 90       	lpm	r0, Z+
 cc0:	f4 91       	lpm	r31, Z
 cc2:	e0 2d       	mov	r30, r0
 cc4:	09 94       	ijmp

00000cc6 <_exit>:
 cc6:	f8 94       	cli

00000cc8 <__stop_program>:
 cc8:	ff cf       	rjmp	.-2      	; 0xcc8 <__stop_program>
